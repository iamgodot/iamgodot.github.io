<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Code | Godot's Blog</title><meta name=keywords content><meta name=description content><meta name=author content><link rel=canonical href=https://iamgodot.com/categories/code/><link crossorigin=anonymous href=/assets/css/stylesheet.min.7cb1aaa4414c482febc7034a427761d087a2cf358f1be8f7beba5afc947b57d0.css integrity="sha256-fLGqpEFMSC/rxwNKQndh0IeizzWPG+j3vrpa/JR7V9A=" rel="preload stylesheet" as=style><link rel=icon href=https://iamgodot.com/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://iamgodot.com/icons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://iamgodot.com/icons/favicon-32x32.png><link rel=apple-touch-icon href=https://iamgodot.com/icons/apple-touch-icon.png><link rel=mask-icon href=https://iamgodot.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://iamgodot.com/categories/code/index.xml><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=preload as=style href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;700&family=Source+Code+Pro:wght@400;700&display=swap"><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;700&family=Source+Code+Pro:wght@400;700&display=swap" media=print onload='this.media="all"'><link rel=preconnect href=https://plausible.iamgodot.com><script defer data-domain=iamgodot.com src=https://plausible.iamgodot.com/js/plausible.js></script>
<script>window.plausible=window.plausible||function(){(window.plausible.q=window.plausible.q||[]).push(arguments)}</script><script></script><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-157042624-1","auto"),ga("send","pageview"))</script><meta property="og:title" content="Code"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://iamgodot.com/categories/code/"><meta name=twitter:card content="summary"><meta name=twitter:title content="Code"><meta name=twitter:description content></head><body class="list dark" id=top><header class=header><nav class=nav><div class=logo><a href=https://iamgodot.com accesskey=h title="Godot's Blog (Alt + H)">Godot's Blog</a>
<span class=logo-switches></span></div><ul id=menu></ul></nav></header><main class=main><header class=page-header><h1>Code</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2>关于 HTTP Auth</h2></header><section class=entry-content><p>Auth 代表了 Authentication 和 Authorization 两个概念，也就是认证与授权。基于 HTTP，两者得以遵循一定的标准，SSL/TLS 之后，又出现了 OAuth 2.0，让授权也简单了许多。
Authentication 认证相对来说比较直接，核心就是对 Credential(e.g. username/password) 的验证。HTTP 提供了多种认证方案，比如最常见的 Basic auth, Digest access 和 Bearer.
Basic auth 具体来说就是服务器用 WWW-Authenticate 表示需要认证，比如 WWW-Authenticate: Basic realm='Accessing to xx site'，客户端则通过 Authorization 提供相关信息：Authorization: Basic Zm9vOmJhcg==，后面的一串编码是对用户名密码明文进行 base64 的结果，即可以直接从中 decode 出原始信息 foo:bar. 没有 HTTPS 的保护，这样很不安全，所以 Apache/Nginx 对 BA 的实现都会使用密码的哈希结果而不是原文，拿后者举例：
http { server { location / { auth_basic "Accessing to xx site"; auth_basic_user_file /path/to/authfile; } } } 然后需要在 authfile 中保存 username/password pair，比如 sudo htpasswd -c /path/to/authfile user1，htpasswd 是 Apache 提供的专门用来生成 BA 使用的 Credential file 的工具。不用额外安装，我们直接用 openssl 代替：...</p></section><footer class=entry-footer><span title='2022-01-28 10:16:19 +0800 +0800'>01-28</span>&nbsp;·&nbsp;3 min</footer><a class=entry-link aria-label="post link to 关于 HTTP Auth" href=https://iamgodot.com/posts/about-http-auth/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>关于 SSH 端口转发</h2></header><section class=entry-content><p>SSH 的端口转发很实用，但我总觉得难以理解和记忆，直到最近才有所好转。
因为又派上用场了。以前基本只做做内网穿透，现在更多地拿来绕过防火墙。自己的服务器，大多数端口虽然都是被禁用的（至少禁止入网，这也是正常的安全措施），但是想要连接的话直接本地端口转发就可以了。
TL;DR 本地端口转发在当前机器上设置，然后从本机出发，通过另一台机器，连接其他的机器。适用于防火墙的绕过、多重 SSH 登录等。
远程端口转发在当前机器上设置，然后从另外一台机器出发，通过当前机器，连接本机或者其他的机器。适用于 NAT 网络穿透、暴露内部网络服务等。
本质上都是先建立 SSH 会话，形成隧道，然后在上面进行正向或反向的数据传输。
Local Port Forwarding 为什么叫做本地呢，我想有两个原因：
转发的端口在当前（执行 SSH 命令这台）机器上 请求是从当前机器发出的 当前机器就是我的笔记本，另外一台是服务器。比如，在服务器上部署一个应用，开放给 8000 端口，但是被墙掉了，没办法在本地调试，怎么办？防火墙肯定开放了 SSH 登录的端口，比如 22，那么就让请求从本地的端口发送到服务器的 22 端口，再转发到 8000 端口，最后原路返回。我可以设置本地的端口也是 8000，这样直接用 localhost:8000 来访问应用就好了。
转发的重点在于本地的 8000 端口和服务器的 22 端口之间，因为请求到了服务器之后可以给应用的 8000，也可以给其他的机器，只要服务器能连接到：
# ssh -L local_port:dest_addr:dest_port server # Local 8000 &lt; -- > Server 22 &lt; -- > Server 8000 # -fNT 让 ssh 不要打开服务器 shell，并且转为后台运行 # server 隐含了使用 22 端口登录，当然也可以在 ssh config 中设置任意登录端口 ssh -fNT -L 8000:localhost:8000 server 注意这里的 dest 对应的 src 是 server，也就是说 localhost 及后面的 8000 都是 server 的 IP 和端口。可以理解为 server 是中介，整条通路是 local -> server -> dest....</p></section><footer class=entry-footer><span title='2021-12-22 11:36:49 +0800 +0800'>12-22</span>&nbsp;·&nbsp;2 min</footer><a class=entry-link aria-label="post link to 关于 SSH 端口转发" href=https://iamgodot.com/posts/ssh-port-forwarding/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>From BitTorrent to Firewall</h2></header><section class=entry-content><p>服务器能做什么？在 Awesome-Selfhosted 里可以找到上百种答案。如果带宽不算太小的话，那么 BT 下载是个不错的尝试。借着 No Time to Die 的上映我开始重温 007 系列，从皇家赌场到幽灵党，在服务器上的下载体验是很好的。
BitTorrent 在此之前，我基本上把 BT、种子、磁力、迅雷下载当成同一种东西。下载电影？先找种子或者磁力链接，打开迅雷下载，然后视速度决定要不要开个会员。
实际上这完全曲解了 BT 下载。
首先 BitTorrent 是一种网络协议。还记得计算机网络一开始就提到过除了 C/S 架构之外，还有 P2P(Peer-to-peer)，也就是网络中的各个节点都扮演了同等的角色，既是客户端也是服务器。BT 基于 P2P 实现了去中心化的文件分享，让网络数据的传输不再仅限于服务器的能力，而是共享带宽，每个人下载的同时也在上传，所以越多人参与速度就越快。
类似于 HTTP 和 FTP，BT 也是基于 TCP/IP 的一种应用层协议。基本上它是这么运作的：
我有一部电影，想把资源分享到网络，要先提供一个种子文件
种子文件实际上就是个文本文件，里面主要记录两部分信息
Trackers: 就是 Tracker 服务器的地址，这个服务器不是用来下载资源的，而是用于获取其他 Peers 的联系方式 Files: 一个视频文件会被（逻辑）划分为很多个虚拟分块，每块的索引和验证码都包含在这里 接下来我把种子文件发布出去，等待别人下载
这时候有人获取到种子了，于是开启了 BT 客户端下载
客户端先解析种子文件中的信息，找到 Tracker，然后询问有哪些 Peers
因为是第一个下载者，所以 Tracker 告知 Peer 目前只有我，也就是发布者
之后对方会尝试与我互连，然后根据 Files 信息交换数据，这里基本就是我上传给对方
下载的过程会以分块为单位进行，每块完成下载后会根据验证码再做校验
如果这时又有一个人开始下载，那么我和这第一个下载者都会贡献上传
随着更多用户的参与，（上传）下载的速度就会越来越快
可以发现，整个过程中 Tracker 是很关键的一步，如果没有有效的 Tracker 提供 Peers，后面的下载都无法开始。所以如果你的 BT 下载没有速度，首先要尝试多添加一些 Tracker 服务器，比如 TrackersList....</p></section><footer class=entry-footer><span title='2021-12-20 17:00:00 +0800 +0800'>12-20</span>&nbsp;·&nbsp;2 min</footer><a class=entry-link aria-label="post link to From BitTorrent to Firewall" href=https://iamgodot.com/posts/from-bittorrent-to-firewall/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>Python heapq 源码阅读</h2></header><section class=entry-content><p>Heap 作为一种重要的数据结构，有许多应用场景，比如优先级队列，每次出队的都是最大值或者最小值的元素。很多语言都集成了相关实现，比如 Java 的 PriorityQueue，而 Python 提供了 heapq 模块。
因为 Heap 通常用数组而不是链表存储，所以 Python 里面的 Heap 实质上就是一个列表，而 heapq 提供的几个函数也是以列表对象作为参数的：
from heapq import heappush, heappop, heappify, heapreplace, heappushpop heap = [] heappush(heap, 1) item = heap[0] # 第一个元素代表堆顶元素 heappop(heap) heapify([3, 2, 1, 5, 6, 4]) # 把普通列表转化为堆结构 [1, 2, 3, 4, 5, 6] heapreplace([3, 4, 5], 1) # 直接将堆顶元素 3 替换为 1，最后堆结构为 [1, 4, 5] heappushpop([3, 4, 5], 1) # 先将 1 插入堆中，再 pop 出堆顶元素，最后堆结构为 [3, 4, 5] 为什么 heapq 提供的是最小堆而不是更常见的最大堆呢？这就得从源码中找答案了。...</p></section><footer class=entry-footer><span title='2021-11-29 23:26:37 +0800 +0800'>11-29</span>&nbsp;·&nbsp;4 min</footer><a class=entry-link aria-label="post link to Python heapq 源码阅读" href=https://iamgodot.com/posts/sourcecode-of-python-heapq/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>Python OrderedDict 实现 LRU 缓存</h2></header><section class=entry-content><p>LRUCache 是一种经典的缓存机制，它的基本思路是按照最近使用的时间对元素排序，在清理时优先把搁置最久的删除掉。
如果不想给每个缓存元素都记录一个时间戳的话，可以应用哈希链表来简单地实现 LRU 算法。也就是对一个哈希表中的所有元素增加指针，从而串起一个双链表，这样既可以快速 get value，又可以通过把最近使用过的元素放到头部来维护顺序，删除的时候从末尾开始就好了。
手写双链表并不困难，但是借助 OrderedDict 的话，可以写出非常简短的代码：
from collections import OrderedDict class LRUCache: def __init__(self, capacity): self.capacity = capacity self.hashtable = OrderedDict() def get(self, key: int) -> int: if key in self.hashtable: self.hashtable.move_to_end(key, last=False) return self.hashtable[key] return -1 def put(self, key: int, value: int) -> None: self.hashtable[key] = value self.hashtable.move_to_end(key, last=False) if len(self.hashtable) > self.capacity: self.hashtable.popitem() 其中最神奇的就是 move_to_end 和 popitem 方法（后者默认是弹出最后面的元素）的使用，这也得益于 OD 可以保证 key-value pair 的顺序。那么
OD 是如何做到的呢？其实还是双链表，下面是它的 Python 实现：...</p></section><footer class=entry-footer><span title='2021-11-28 17:50:51 +0800 +0800'>11-28</span>&nbsp;·&nbsp;3 min</footer><a class=entry-link aria-label="post link to Python OrderedDict 实现 LRU 缓存" href=https://iamgodot.com/posts/sourcecode-of-python-ordereddict/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://iamgodot.com/categories/code/page/2/>« Prev Page</a>
<a class=next href=https://iamgodot.com/categories/code/page/4/>Next Page »</a></nav></footer></main><footer class=footer><span>&copy; 2020-2022 <a href=https://iamgodot.com>Godot's Blog</a></span>
<span>| <a href=http://beian.miit.gov.cn/ target=_blank>京ICP备20005558号-2</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script></body></html>