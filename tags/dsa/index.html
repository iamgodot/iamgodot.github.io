<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>dsa | Godot&#39;s Blog</title>
<meta name="keywords" content="">
<meta name="description" content="">
<meta name="author" content="">
<link rel="canonical" href="https://iamgodot.com/tags/dsa/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.7cb1aaa4414c482febc7034a427761d087a2cf358f1be8f7beba5afc947b57d0.css" integrity="sha256-fLGqpEFMSC/rxwNKQndh0IeizzWPG&#43;j3vrpa/JR7V9A=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://iamgodot.com/icons/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://iamgodot.com/icons/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://iamgodot.com/icons/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://iamgodot.com/icons/apple-touch-icon.png">
<link rel="mask-icon" href="https://iamgodot.com/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="https://iamgodot.com/tags/dsa/index.xml">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link rel="preload" as="style" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;700&family=Source+Code+Pro:wght@400;700&display=swap" />
<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;700&family=Source+Code+Pro:wght@400;700&display=swap" media="print" onload="this.media='all'">














    
        <link rel="preconnect" href="https://plausible.iamgodot.com">
    
        
        <script defer data-domain="iamgodot.com" src="https://plausible.iamgodot.com/js/plausible.js" ></script>

<!-- If you are using Content-Security-Policy, do not forget to add this code to your CSP : 
  script-src 'unsafe-inline' https://plausible.iamgodot.com
  connect-src 'unsafe-inline' https://plausible.iamgodot.com
  or just add the partial 'plausible_csp.html' to those 2 csp directives in your 'index.headers' file
-->



    
    <script>window.plausible = window.plausible || function() { (window.plausible.q = window.plausible.q || []).push(arguments) }</script>
    <script>
         
         
         
    </script>

    


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-157042624-1', 'auto');
	
	ga('send', 'pageview');
}
</script><meta property="og:title" content="dsa" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://iamgodot.com/tags/dsa/" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="dsa"/>
<meta name="twitter:description" content=""/>

</head>

<body class="list dark" id="top">

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://iamgodot.com" accesskey="h" title="Godot&#39;s Blog (Alt + H)">Godot&#39;s Blog</a>
            <span class="logo-switches">
            </span>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header">
  <h1>dsa</h1>
</header>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>Amazon OA 2022
    </h2>
  </header>
  <section class="entry-content">
    <p>分享一下今年准备 Amazon OA 时整理的题目。
按照低中高的难度简单分了下类，最后的难题能理解思路是最好的，不建议死记硬背。
Easy 1. Maximum quality sent via a channel 给一个 packets 数组和 k 个 channel，要求每个 channel 里面必须至少有一个数组里面的元素，每个元素只能在一个 channel 里面。其中 packets 中的元素数量是大于等于 k 的。要求算出所有channel中位数之和的最大值。
def solution(packets: List[int], channels: int) -&gt; int: &#34;&#34;&#34; 将 packets 排序，依次把最大的一个元素分配给各 channel， 剩下的元素放到最后一个 channel。 &#34;&#34;&#34; packets.sort() total = 0 length = len(packets) for i in range(length - channels &#43; 1, length): total &#43;= packets[i] rest = length - channels &#43; 1 if rest % 2 == 0: sum = packets[(rest - 1) // 2] &#43; packets[rest // 2] total &#43;= sum // 2 if sum % 2 == 0 else sum // 2 &#43; 1 else: total &#43;= packets[rest // 2] return total 这是当时做 OA 的第一题，很轻松搞定，结果第二题非常 Hard，下面会提到。...</p>
  </section>
  <footer class="entry-footer"><span title='2022-08-11 07:19:04 +0800 CST'>08-11</span>&nbsp;·&nbsp;14 min</footer>
  <a class="entry-link" aria-label="post link to Amazon OA 2022" href="https://iamgodot.com/posts/amazon-oa-2022/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>Sum of Total Strength of Wizards
    </h2>
  </header>
  <section class="entry-content">
    <p>前两天有幸做了一道算法题，虽然没能成功解决，但题目很有意思，充分展现了算法的魅力所在。
抛开题面的包装不谈，核心内容就是给定一个数组，计算它的所有子数组的最小值与加和的乘积的总和。
（这里要注意子数组的定义，一定是连续的，如果不连续的话叫做子序列。）
比如对于 [1, 2, 3] 来说，一共有六种情况：
[1]: 1 * 1 = 1 [2]: 2 * 2 = 4 [3]: 3 * 3 = 9 [1, 2]: 1 * (1 &#43; 2) = 3 [2, 3]: 2 * (2 &#43; 3) = 10 [1, 2, 3]: 1 * (1 &#43; 2 &#43; 3) = 6 最后答案为 1 &#43; 4 &#43; 9 &#43; 3 &#43; 10 &#43; 6 = 33。...</p>
  </section>
  <footer class="entry-footer"><span title='2022-07-26 10:41:55 +0800 CST'>07-26</span>&nbsp;·&nbsp;3 min</footer>
  <a class="entry-link" aria-label="post link to Sum of Total Strength of Wizards" href="https://iamgodot.com/posts/sum-of-total-strength-of-wizards/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>Python heapq 源码阅读
    </h2>
  </header>
  <section class="entry-content">
    <p>Heap 作为一种重要的数据结构，有许多应用场景，比如优先级队列，每次出队的都是最大值或者最小值的元素。很多语言都集成了相关实现，比如 Java 的 PriorityQueue，而 Python 提供了 heapq 模块。
因为 Heap 通常用数组而不是链表存储，所以 Python 里面的 Heap 实质上就是一个列表，而 heapq 提供的几个函数也是以列表对象作为参数的：
from heapq import heappush, heappop, heappify, heapreplace, heappushpop heap = [] heappush(heap, 1) item = heap[0] # 第一个元素代表堆顶元素 heappop(heap) heapify([3, 2, 1, 5, 6, 4]) # 把普通列表转化为堆结构 [1, 2, 3, 4, 5, 6] heapreplace([3, 4, 5], 1) # 直接将堆顶元素 3 替换为 1，最后堆结构为 [1, 4, 5] heappushpop([3, 4, 5], 1) # 先将 1 插入堆中，再 pop 出堆顶元素，最后堆结构为 [3, 4, 5] 为什么 heapq 提供的是最小堆而不是更常见的最大堆呢？这就得从源码中找答案了。...</p>
  </section>
  <footer class="entry-footer"><span title='2021-11-29 23:26:37 +0800 CST'>11-29</span>&nbsp;·&nbsp;4 min</footer>
  <a class="entry-link" aria-label="post link to Python heapq 源码阅读" href="https://iamgodot.com/posts/sourcecode-of-python-heapq/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>Python OrderedDict 实现 LRU 缓存
    </h2>
  </header>
  <section class="entry-content">
    <p>LRUCache 是一种经典的缓存机制，它的基本思路是按照最近使用的时间对元素排序，在清理时优先把搁置最久的删除掉。
如果不想给每个缓存元素都记录一个时间戳的话，可以应用哈希链表来简单地实现 LRU 算法。也就是对一个哈希表中的所有元素增加指针，从而串起一个双链表，这样既可以快速 get value，又可以通过把最近使用过的元素放到头部来维护顺序，删除的时候从末尾开始就好了。
手写双链表并不困难，但是借助 OrderedDict 的话，可以写出非常简短的代码：
from collections import OrderedDict class LRUCache: def __init__(self, capacity): self.capacity = capacity self.hashtable = OrderedDict() def get(self, key: int) -&gt; int: if key in self.hashtable: self.hashtable.move_to_end(key, last=False) return self.hashtable[key] return -1 def put(self, key: int, value: int) -&gt; None: self.hashtable[key] = value self.hashtable.move_to_end(key, last=False) if len(self.hashtable) &gt; self.capacity: self.hashtable.popitem() 其中最神奇的就是 move_to_end 和 popitem 方法（后者默认是弹出最后面的元素）的使用，这也得益于 OD 可以保证 key-value pair 的顺序。那么
OD 是如何做到的呢？其实还是双链表，下面是它的 Python 实现：...</p>
  </section>
  <footer class="entry-footer"><span title='2021-11-28 17:50:51 +0800 CST'>11-28</span>&nbsp;·&nbsp;3 min</footer>
  <a class="entry-link" aria-label="post link to Python OrderedDict 实现 LRU 缓存" href="https://iamgodot.com/posts/sourcecode-of-python-ordereddict/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>Understand Recursion Better
    </h2>
  </header>
  <section class="entry-content">
    <p>在 Simple Recursion 之后，我一度把递归当作一种算法。但通过比较 Divide and Conquer 和 Dynamic Programming，我才发现之前的理解有点问题。
一切还是要从 Algorithmic Paradigm 说起：
An algorithmic paradigm or algorithm design paradigm is a generic model or framework which underlies the design of a class of algorithms. An algorithmic paradigm is an abstraction higher than the notion of an algorithm, just as an algorithm is an abstraction higher than a computer program.
算法范式，是在算法的层面上抽象出来的一种更泛化的思想，常用的有：
Brute-force search 暴力解法 Backtracking 回溯算法 Greedy algorithm 贪心算法 Divide and conquer 分治法 Dynamic programming 动态规划 Divide and Conquer 的基本思路是把复杂的问题分解成多个类似的简单问题，解决之后再组合起来得到最终结果。这种算法有很多应用，比如排序中的 Merge Sort，先将数列分解成单个元素，然后再归并，这时子数组都已经排好顺序了，所以过程很快。...</p>
  </section>
  <footer class="entry-footer"><span title='2021-11-08 18:18:10 +0800 CST'>11-08</span>&nbsp;·&nbsp;2 min</footer>
  <a class="entry-link" aria-label="post link to Understand Recursion Better" href="https://iamgodot.com/posts/understand-recursion-better/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="next" href="https://iamgodot.com/tags/dsa/page/2/">Next Page »</a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
    <span>&copy; 2020-2022 <a href="https://iamgodot.com">Godot&#39;s Blog</a></span>
    <span>
        | <a href="http://beian.miit.gov.cn/" target="_blank">京ICP备20005558号-2</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
</body>

</html>
