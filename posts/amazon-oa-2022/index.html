<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Amazon OA 2022 | Godot&#39;s Blog</title>
<meta name="keywords" content="amazon oa题库, amazon oa一亩三分地, amazon oa 2022">
<meta name="description" content="分享一下今年准备 Amazon OA 时整理的题目。
按照低中高的难度简单分了下类，最后的难题能理解思路是最好的，不建议死记硬背。
Easy 1. Maximum quality sent via a channel 给一个 packets 数组和 k 个 channel，要求每个 channel 里面必须至少有一个数组里面的元素，每个元素只能在一个 channel 里面。其中 packets 中的元素数量是大于等于 k 的。要求算出所有channel中位数之和的最大值。
def solution(packets: List[int], channels: int) -&gt; int: &#34;&#34;&#34; 将 packets 排序，依次把最大的一个元素分配给各 channel， 剩下的元素放到最后一个 channel。 &#34;&#34;&#34; packets.sort() total = 0 length = len(packets) for i in range(length - channels &#43; 1, length): total &#43;= packets[i] rest = length - channels &#43; 1 if rest % 2 == 0: sum = packets[(rest - 1) // 2] &#43; packets[rest // 2] total &#43;= sum // 2 if sum % 2 == 0 else sum // 2 &#43; 1 else: total &#43;= packets[rest // 2] return total 这是当时做 OA 的第一题，很轻松搞定，结果第二题非常 Hard，下面会提到。">
<meta name="author" content="">
<link rel="canonical" href="https://iamgodot.com/posts/amazon-oa-2022/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.7cb1aaa4414c482febc7034a427761d087a2cf358f1be8f7beba5afc947b57d0.css" integrity="sha256-fLGqpEFMSC/rxwNKQndh0IeizzWPG&#43;j3vrpa/JR7V9A=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.e85ad0406048e8176e1c7661b25d5c69297ddfe41dc4124cf75ecb99a4f7b3d1.js" integrity="sha256-6FrQQGBI6BduHHZhsl1caSl93&#43;QdxBJM917LmaT3s9E="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://iamgodot.com/icons/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://iamgodot.com/icons/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://iamgodot.com/icons/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://iamgodot.com/icons/apple-touch-icon.png">
<link rel="mask-icon" href="https://iamgodot.com/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link rel="preload" as="style" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;700&family=Source+Code+Pro:wght@400;700&display=swap" />
<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;700&family=Source+Code+Pro:wght@400;700&display=swap" media="print" onload="this.media='all'">














    
        <link rel="preconnect" href="https://plausible.iamgodot.com">
    
        
        <script defer data-domain="iamgodot.com" src="https://plausible.iamgodot.com/js/plausible.js" ></script>

<!-- If you are using Content-Security-Policy, do not forget to add this code to your CSP : 
  script-src 'unsafe-inline' https://plausible.iamgodot.com
  connect-src 'unsafe-inline' https://plausible.iamgodot.com
  or just add the partial 'plausible_csp.html' to those 2 csp directives in your 'index.headers' file
-->



    
    <script>window.plausible = window.plausible || function() { (window.plausible.q = window.plausible.q || []).push(arguments) }</script>
    <script>
         
         
         
    </script>

    


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-157042624-1', 'auto');
	
	ga('send', 'pageview');
}
</script><meta property="og:title" content="Amazon OA 2022" />
<meta property="og:description" content="分享一下今年准备 Amazon OA 时整理的题目。
按照低中高的难度简单分了下类，最后的难题能理解思路是最好的，不建议死记硬背。
Easy 1. Maximum quality sent via a channel 给一个 packets 数组和 k 个 channel，要求每个 channel 里面必须至少有一个数组里面的元素，每个元素只能在一个 channel 里面。其中 packets 中的元素数量是大于等于 k 的。要求算出所有channel中位数之和的最大值。
def solution(packets: List[int], channels: int) -&gt; int: &#34;&#34;&#34; 将 packets 排序，依次把最大的一个元素分配给各 channel， 剩下的元素放到最后一个 channel。 &#34;&#34;&#34; packets.sort() total = 0 length = len(packets) for i in range(length - channels &#43; 1, length): total &#43;= packets[i] rest = length - channels &#43; 1 if rest % 2 == 0: sum = packets[(rest - 1) // 2] &#43; packets[rest // 2] total &#43;= sum // 2 if sum % 2 == 0 else sum // 2 &#43; 1 else: total &#43;= packets[rest // 2] return total 这是当时做 OA 的第一题，很轻松搞定，结果第二题非常 Hard，下面会提到。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://iamgodot.com/posts/amazon-oa-2022/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-08-11T07:19:04&#43;08:00" />
<meta property="article:modified_time" content="2022-08-11T07:19:04&#43;08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Amazon OA 2022"/>
<meta name="twitter:description" content="分享一下今年准备 Amazon OA 时整理的题目。
按照低中高的难度简单分了下类，最后的难题能理解思路是最好的，不建议死记硬背。
Easy 1. Maximum quality sent via a channel 给一个 packets 数组和 k 个 channel，要求每个 channel 里面必须至少有一个数组里面的元素，每个元素只能在一个 channel 里面。其中 packets 中的元素数量是大于等于 k 的。要求算出所有channel中位数之和的最大值。
def solution(packets: List[int], channels: int) -&gt; int: &#34;&#34;&#34; 将 packets 排序，依次把最大的一个元素分配给各 channel， 剩下的元素放到最后一个 channel。 &#34;&#34;&#34; packets.sort() total = 0 length = len(packets) for i in range(length - channels &#43; 1, length): total &#43;= packets[i] rest = length - channels &#43; 1 if rest % 2 == 0: sum = packets[(rest - 1) // 2] &#43; packets[rest // 2] total &#43;= sum // 2 if sum % 2 == 0 else sum // 2 &#43; 1 else: total &#43;= packets[rest // 2] return total 这是当时做 OA 的第一题，很轻松搞定，结果第二题非常 Hard，下面会提到。"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Posts",
      "item": "https://iamgodot.com/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Amazon OA 2022",
      "item": "https://iamgodot.com/posts/amazon-oa-2022/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Amazon OA 2022",
  "name": "Amazon OA 2022",
  "description": "分享一下今年准备 Amazon OA 时整理的题目。\n按照低中高的难度简单分了下类，最后的难题能理解思路是最好的，不建议死记硬背。\nEasy 1. Maximum quality sent via a channel 给一个 packets 数组和 k 个 channel，要求每个 channel 里面必须至少有一个数组里面的元素，每个元素只能在一个 channel 里面。其中 packets 中的元素数量是大于等于 k 的。要求算出所有channel中位数之和的最大值。\ndef solution(packets: List[int], channels: int) -\u0026gt; int: \u0026#34;\u0026#34;\u0026#34; 将 packets 排序，依次把最大的一个元素分配给各 channel， 剩下的元素放到最后一个 channel。 \u0026#34;\u0026#34;\u0026#34; packets.sort() total = 0 length = len(packets) for i in range(length - channels + 1, length): total += packets[i] rest = length - channels + 1 if rest % 2 == 0: sum = packets[(rest - 1) // 2] + packets[rest // 2] total += sum // 2 if sum % 2 == 0 else sum // 2 + 1 else: total += packets[rest // 2] return total 这是当时做 OA 的第一题，很轻松搞定，结果第二题非常 Hard，下面会提到。",
  "keywords": [
    "amazon oa题库", "amazon oa一亩三分地", "amazon oa 2022"
  ],
  "articleBody": "分享一下今年准备 Amazon OA 时整理的题目。\n按照低中高的难度简单分了下类，最后的难题能理解思路是最好的，不建议死记硬背。\nEasy 1. Maximum quality sent via a channel 给一个 packets 数组和 k 个 channel，要求每个 channel 里面必须至少有一个数组里面的元素，每个元素只能在一个 channel 里面。其中 packets 中的元素数量是大于等于 k 的。要求算出所有channel中位数之和的最大值。\ndef solution(packets: List[int], channels: int) -\u003e int: \"\"\" 将 packets 排序，依次把最大的一个元素分配给各 channel， 剩下的元素放到最后一个 channel。 \"\"\" packets.sort() total = 0 length = len(packets) for i in range(length - channels + 1, length): total += packets[i] rest = length - channels + 1 if rest % 2 == 0: sum = packets[(rest - 1) // 2] + packets[rest // 2] total += sum // 2 if sum % 2 == 0 else sum // 2 + 1 else: total += packets[rest // 2] return total 这是当时做 OA 的第一题，很轻松搞定，结果第二题非常 Hard，下面会提到。\n2. Minimum swaps to make max \u0026 min corners 大意是对于一个数组，把最小值和最大值分别移动到左右两端最少需要多少次交换。\ndef solution(nums: List[int]): ''' 先遍历出最小值和最大值的下标，再计算距离即可。 如果两个值会出现交换则结果减一。 ''' min_, max_ = float('inf'), -float('inf') index_min = index_max = 0 for i in range(len(nums)): num = nums[i] if num \u003c min_: index_min = i min_ = num if num \u003e max_: index_max = i max_ = num swaps = index_min + len(nums) - 1 - index_max return swaps - 1 if index_max \u003c index_min else swaps 3. Grouping digits 给定一个只包含 0 和 1 的数组，将所有的 0 和 1 分别放置到数组的任意两端，最少需要多少次交换。\ndef solution(array: List[int]): ''' 思路是先假设把所有的 1 交换到右端， 从左遍历数组，累积记录交换次数。 当然也可以把 1 交换到左端，所以最后比较选择更小值。 ''' res1 = num_of_1 = 0 for digit in array: if digit == 1: num_of_1 += 1 else: res1 += num_of_1 num_of_0 = len(array) - num_of_1 return min(res1, num_of_0 * num_of_1 - res1) 更详细的解释可以参考 Stackoverflow。\n4. Minimum swaps to make binary palindrome 给一个只有 0 和 1 的数组，找到形成回文结构的最小交换次数。\ndef solution(binary: List[int]): \"\"\" 双指针从两端开始看，记录 diff 总数。 如果 diff 为偶数，那么交换次数为 diff 的一半即可，比如 0101； 如果 diff 为奇数但是总位数为偶数则不可能做到，比如01； 如果 diff 为奇数总位数也为偶数则也交换 diff 的一半次数即可，比如011。 \"\"\" n = len(binary) count = 0 for i in range(n // 2): if binary[i] != binary[n - i - 1]: count += 1 if count % 2 == 1 and n % 2 == 0: return -1 return (count + 1) // 2 5. Max subarray length with product 1 给一个只有 -1 和 1 的数组，找到最长的子数组长度，条件是乘积为 1。\ndef solution(array: List[int]): \"\"\" 思路是如果整个数组中包含偶数个 -1，那么结果为总长度； 否则找到两端的 -1，然后比较两个剩余长度。 \"\"\" neg_count = 0 neg_first = neg_last = 0 length = len(array) for i in range(length): if array[i] == -1: if neg_first == 0: neg_first = i neg_last = i neg_count += 1 return length if neg_count % 2 == 0 else max(length - neg_first - 1, neg_last) 6. Valid discount coupon 大意是对于一个字符串来说，Valid 的条件是空字符串，或者一个 Valid 字符串两端加上相同字符，或者两个 Valid 字符串相连。\ndef solution(s: str): stack = [] for char in s: if not stack or stack[-1] != char: stack.append(char) else: stack.pop() return len(stack) == 0 7. Linked list max pair 给一个偶数个节点的链表，对于每对第 n 个和倒数第 n 个的和，求最大值。\ndef solution(head: ListNode): slow = fast = head while fast and fast.next: slow = slow.next fast = fast.next.next first = head second = slow.next slow.next = None # 这里需要自己实现一个 reverse second = reverse(second) res = -float('inf') while first: res = max(res, first.val + second.val) first = first.next second = second.next return res 8. Combine if left is smaller than right 大意是对一个数组（package 之类的）进行合并，条件是左边元素小于右边，求合并之后数组中的最大值。\ndef solution(nums: List[int]) -\u003e int: \"\"\" 注意要从后往前遍历。 \"\"\" if not nums: return 0 res = cur = nums[-1] for i in range(len(nums) -2, -1, -1): if nums[i] \u003c cur: cur += nums[i] else: cur = nums[i] res = max(res, cur) return res 9. Minimum number of rounds Deliver boxes，一次只能运送两个或三个相同重量的 box，求最小运送次数。\ndef solution(weights: List[int]): from collections import Counter counts = Counter(weights) ans = 0 for k, v in counts.items(): if v == 1: return -1 else: ans += v // 3 ans += 1 if v % 3 != 0 else 0 return ans 10. Kindle pages 大意是在一个 0 和 1 的序列中找到满足 010/101 的组合数量。\ndef solution(s: str) -\u003e int: n = len(s) n1 = s.count('1') n1_cur = 0 res = 0 for i, char in enumerate(s): if char == '0': res += n1_cur * (n1 - n1_cur) else: res += (i - n1_cur) * (n - n1 - i + n1_cur) n1_cur += 1 return res 参考 Leetcode 选择建筑的方案数。\n11. Nearest restaurant 选择最近的 k 个点。\ndef solution(points: List[List[int]], k: int) -\u003e List[List[int]]: heap = [] import heapq for p in points: x, y = p element = [-x**2-y**2, p] if len(heap) == k: heapq.heappushpop(heap, element) else: heapq.heappush(heap, element) return [item[1] for item in heap] 参考 Leetcode 最接近原点的 K 个点。\n12. MEX array 很有意思的一道题。\nThe MEX of an array is equal to the smallest positive integer that is not present in the array.\n给一个大小为 N 的正数数组，元素值各不相同。对于每个元素，如果去掉的话，找到对应的 MEX，返回同样大小为 N 的结果数组。\ndef solution(nums: List[int], n: int): length = 100001 hashtable = [0] * length for i in range(n): hashtable[nums[i]] = 1 mex = 0 for i in range(1, length): if hashtable[i] == 0: mex = i break res = [0] * n for i in range(n): if nums[i] \u003c mex: res[i] = nums[i] else: res[i] = mex return res 参考 Construct MEX array from the given array。\nMedium 1. Maximum number of engineering teams 一个数组表示 engineers，数值表示 skill，组建 team_size 个人的团队，每个团队的 skill 差距不能超过 maxdiff。求最多能组建多少个团队。\ndef solution(team_size: int, maxdiff: int, skill: List[int]): \"\"\"贪心，将 skill 排序后从头查找即可。\"\"\" i = 0 teams = 0 skill.sort() while i \u003c len(skill): if i + team_size - 1 \u003e= len(skill): break if skill[i+team_size-1] - skill[i] \u003e maxdiff: i += 1 continue teams += 1 i += team_size return teams 2. Decreasing ratings 给一个数组，求连续下降的子数组个数。\ndef solution(ratings: List[int]) -\u003e int: \"\"\" 大致思路是滑动窗口找单调递减的子数组。 过程中不断叠加子数组长度即可，比如 [...1, 2, 3...]， 满足条件的有 1, 2, 3, 1 2, 2 3, 1 2 3 一共 1 + 2 + 3= 6 个。 \"\"\" res = 0 left = 0 for right in range(len(ratings)): if right \u003e 0 and ratings[right - 1] - ratings[right] != 1: left = right res += right - left + 1 return res 3. Maximum sustainable cluster size Question on AWS power consumption, given BootingPower[i], processingPower[i], powerMax.\nFor maximum utilization, the data center wishes to group these processors into clusters.\nClusters can only be formed of processors located adjacent to each other.\nFor example, processors 2,3,4,5 can form a cluster, but 1,3,4 cannot. cluster of k processors defined as (i, i+1,…., i+k-1)\nNet power consumption = maximum booting power among the k processors + (sum of processing power of processors)*k.\nA cluster is said to be sustainable if it’s net power consumption does not exceed a given threshold value powerMax.\nExample:\nbootingPower = [3,6,1,3,4]\nprocessingPower = [2,1,3,4,5]\npowerMax = 25\nIf k = 2, any adjacent pair can be choosen.\nThe highest usage is the pair [4,5] with net power consumption 4 + (4 + 5)2 = 22.\nNext, try k = 3. Group the first 3 processors together as:\nHere,\nMax booting power = max(3,6,1)\nSum of processing power = 2 + 1+ 3 = 6\nNet power consumption = 6 + 63 = 24 \u003c= powerMax\nThus, k = 3 is a sustainable cluster.\nExample:\nbootingPower = [8,8,10,9,2]\nprocessingPower = [4,1,4,5,3]\npowerMax = 33\nIf k = 2, consisting of first 2 processors.\nNet power consumption = max(8,8) + (4+1)*2 = 18 \u003c= 33 (powerMax)\nThus, k = 2 is a sustainable cluster.\nExample:\nbootingPower = [11,12,19]\nprocessingPower = [10,8,7]\npowerMax = 6\nk = 0, not possible to form any sustainable clusters.\ndef solution(booting_power, processing_power, power_max) -\u003e int: \"\"\"用单调栈定位 booting_power max，再配合滑动窗口找 max size。\"\"\" size = 0 i = j = 0 total = 0 from collections import deque dq = deque([]) while j \u003c len(processing_power): total += processing_power[j] # 注意没有等号，但是如果保存下标的话就可以用等号 while dq and dq[-1] \u003c booting_power[j]: dq.pop() dq.append(booting_power[j]) while i \u003c= j and dq[0] + total * (j - i + 1) \u003e power_max: if processing_power[i] == dq[0]: dq.popleft() i += 1 size = max(size, j - i + 1) j += 1 return size 4. WIFI router Amazon has installed WiFi routers on the houses along a straight street. The city’s buildings are arranged linearly, denoted by indices 1 to n. There are m Amazon routers, and each has a certain range associated with it. Router j installed at a certain building location /can only provide Internet to the buildings in the range [(i - routerRangelin, (i+ routerRange(iN] inclusive, where routerRangeli] is the range parameter of router j.\nA building is considered to be served if the number of routers providing Internet to the building is greater than or equal to the number of people living in it. Given a list of the number of people living in each building, the locations of the buildings where the routers will be installed and each router’s range, find the number of served buildings in the city.\nExample:\nbuildingCount = [1, 2, 1, 2, 2]\nrouterLocation = [3, 1]\nrouterRange = [1, 2]\nThere are 5 buildings with tenant counts shown in buildingCount.\nRouters are located in buildings 3 and 1 with ranges 1 and 2 as shown in routerLocation and routerRange.\nThe first router is in building 3 and provides Internet to buildings in the range [2, 4].\ndef solution(buildings: List[int], locations: List[int], ranges: List[int]): \"\"\" 思路是使用差分数组做优化，达到 O(n) 复杂度。 差分数组每一位 i 的值是 nums[i] - nums[i-1]， 所以更新 [i, j] 只需要更新 i 和 j 两个位置，前者加，后者减， 最后对差分数组求前缀和就是原数组。 \"\"\" length = len(buildings) cover = [0] * length for i in range(len(locations)): start = min(locations[i] - ranges[i] - 1, 0) end = max(locations[i] + ranges[i], len(locations)) cover[start] += 1 if end \u003c len(locations): cover[end] -= 1 res = pre = 0 for i in range(length): cover[i] += pre pre = cover[i] if cover[i] \u003e= buildings[i]: res += 1 return res 关于差分数组的应用可以参考 Leetcode 航班预订统计。\n5. Robot with strings There are three robots named Ray, Ben, and Kevin. Initially Ray has a string S of length N, while the other two robots have empty strings. We can make either of the following moves:\nMove 1: Remove the first character from Ray’s string and append it to Ben’s string.\nMove 2: Remove the last character from Ben’s string and append it to Kevin’s string.\nYou must perform either fo the two moves mentioned above in such a way that the strings left with Ray and Ben are empty and the string left with Kevin is lexicographically smallest string that Kevin has after completing this activity.\ndef solution(s: str): ''' 主要思路是先找到（第一个）最小的 char 的 index，把中间的字母都入栈，再往后找。 找到之后也需要和栈顶的元素比较，如果栈顶元素更小就不断出栈，即优先使用栈顶元素。 ''' res = [] stack = [] length = len(s) index = 0 while index \u003c length: smallest = index char = s[index] for i in range(smallest + 1, length): if s[i] \u003c char: smallest = i char = s[i] for i in range(index, smallest): stack.append(s[i]) while stack and stack[-1] \u003c= char: res.append(stack.pop()) res.append(char) index = smallest + 1 while stack: res.append(stack.pop()) return ''.join(res) 6. Demolition robots Given a matrix with values 0 (trenches) , 1 (flat) , and 9 (obstacle) you have to find minimum distance to reach 9 (obstacle). If not possible then return -1.\nThe demolition robot must start at the top left corner of the matrix, which is always flat, and can move on block up, down, right, left.\nThe demolition robot cannot enter 0 trenches and cannot leave the matrix.\nSample Input :\n[1, 0, 0],\n[1, 0, 0],\n[1, 9, 1]]\nSample Output :\n3\ndef solution(grid: List[List[int]]) -\u003e int: \"\"\"BFS/DFS 均可。\"\"\" m, n = len(grid), len(grid[0]) res = 0 from collections import deque dq = deque([(0, 0)]) grid[0][0] = 0 while dq: res += 1 for _ in range(len(dq)): i, j = dq.pop() for x, y in (i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1): if 0 \u003c= x \u003c m and 0 \u003c= y \u003c n and grid[x][y] != 0: if grid[x][y] == 9: return res if grid[x][y] == 1: dq.appendleft([x, y]) grid[x][y] = 0 return -1 7. Prime air route This problem is a variant of closest pair sum. You’ll be given two arraysarr1 = { {1, 2000}, {2, 3000}, {3, 4000} }arr2 = { { 1, 5000 }, {2, 3000} }the first element of every pair represents id and the second value represents the value.and a target x = 5000Find the pairs from both the arrays whose vaue add upto a sum which is less than given target and should be closest to the target.\nOutput for the above example:{ {1, 2} } // Note that the output should be in id’s\ndef prime( data_in: List[List[int]], data_out: List[List[int]], target: int ) -\u003e List[List[int]]: \"\"\" 思路大概和 closest 3sum 一致： 1. 两个列表排序 2. sum 大于 target 则 high-- 3. sum 小于等于需要进一步划分 1. 如果 distance 小于之前则清空结果列表，否则不动 2. 加入当前 pair，并且对于 low 和 high 继续往中间查找相同元素，取笛卡尔积并保存结果 \"\"\" from itertools import product data_in.sort(key=lambda x: x[1]) data_out.sort(key=lambda x: x[1]) low, high = 0, len(data_out) - 1 sum, distance = 0, float(\"inf\") res = [] while low \u003c len(data_in) and high \u003e= 0: m, n = data_in[low][1], data_out[high][1] sum = m + n if sum \u003c= target: if abs(sum - target) \u003c distance: res.clear() distance = abs(sum - target) lefts, rights = [], [] while low \u003c len(data_in) and data_in[low][1] == m: lefts.append(data_in[low][0]) low += 1 while high \u003e= 0 and data_out[high][1] == n: rights.append(data_out[high][0]) high -= 1 for id1, id2 in product(lefts, rights): res.append([id1, id2]) else: high -= 1 return res 8. Kindle brackets There is a string with the charcater [,(,),],? find the number of possible ways to divide the string into two substring (Continuoes) such that number of open and closing bracket should be same in both substring with same type, you can use ? as a wild card to satisfy either opening or closing bracket of any type.\ndef brackets(s: str): from collections import Counter, defaultdict right = Counter(s) left = defaultdict(int) ans = 0 for i, c in enumerate(s[:-1]): right[c] -= 1 left[c] += 1 left_bra_diff = abs(left['['] - left[']']) left_par_diff = abs(left['('] - left[')']) left_diff = left_bra_diff + left_par_diff right_bra_diff = abs(right['['] - right[']']) right_par_diff = abs(right['('] - right[')']) right_diff = right_bra_diff + right_par_diff if (left_diff \u003c= left['?'] and (left['?'] - left_diff) % 2 == 0) and (right_diff \u003c= right['?'] and (right['?'] - right_diff) % 2 == 0): ans += 1 return ans 9. DNA sequencing Trie 的应用，主要在于通过倒序插入字符来匹配 Stream 中出现的相似 Pattern。\n参考 Leetcode 字符流。\n10. Insert \u0026 View 自定义一个堆，实现 Insert 和 View 两个接口。每次 View 的时候都会查找下一个最小值，比如第一次查找最小值，第二次查找倒数第二小值，依次类推。\nimport heapq class MaxHeapObj: def __init__(self, val, name): self.val = val self.name = name def __lt__(self, other): if self.val == other.val: return self.name \u003e other.name return self.val \u003e other.val def __eq__(self, other): return self.val == other.val and self.name == other.name def __str__(self): return str(self.val) class CustomHeap: def __init__(self): # 主要思路还是保证 max heap 中有 view_count 个最小的元素， # 这样 min heap 顶端的元素就是第 k 小的，view 的时候直接返回即可 self.min_heap = [] self.max_heap = [] self.view_count = 0 def addToHeap(self, name, value): heapq.heappush(self.min_heap, (value, name)) val, name = heapq.heappop(self.min_heap) heapq.heappush(self.max_heap, MaxHeapObj(val, name)) # maintain the size property if len(self.max_heap) \u003e self.view_count: max_heap_obj = heapq.heappop(self.max_heap) val, name = max_heap_obj.val, max_heap_obj.name heapq.heappush(self.min_heap, (val, name)) def view(self): self.view_count += 1 # 这种情况出现在连续多次 view 的时候； # 应该不用考虑 view 次数超过 item 数量的情况，那样的话 min_heap 空了会报错 while len(self.max_heap) \u003c self.view_count - 1: val, name = heapq.heappop(self.min_heap) heapq.heappush(self.max_heap, MaxHeapObj(val, name)) return self.min_heap[0][1] 11. Province connected 参考 Leetcode 省份数量。\n12. Best combo inventory Amazon Shopping has n items in inventory. Each item has a rating that may be negative. The team wants to work on an algorithm that will suggest combinations of these items that customers might buy, or, combos for short.\nExample:\nn = 3, popularity = [3, 5, -2], k = 3\nOutput [8, 6, 5]\n大意应该是找出最贵的前 k 个组合。\ndef find_max_subsets(array: List[int], k: int): \"\"\"基本思路是最大堆配合回溯。\"\"\" import heapq res = [] heap = [] def bt(index, val): heapq.heappush(heap, -val) for i in range(index, len(array)): val += array[i] bt(i+1, val) val -= array[i] bt(0, 0) for _ in range(k): res.append(-heapq.heappop(heap)) return res Hard 1. Maximum password strength 大意是给一个字符串，对每一个子串计算不同字符的个数，最后求所有子串计算结果的总和。\ndef solution(s: str): \"\"\" 对于重复 letter 也计算，但只算一次。 对于 i 字母结尾的子串，做出的贡献是到前面重复字母之间的长度。 \"\"\" res = count = 0 last = {} for i, char in enumerate(s): count += i - last.get(char, -1) res += count last[char] = i return res 参考 Leetcode 字符串的总引力。\n另外还有一道题很类似，但是计算时只考虑出现一次的字符，重复的则忽略：计算子串中的唯一字符。\n2. Shipment imbalance 给一个数组，对于所有的子数组计算其中最大元素与最小元素的差值，返回所有的差值的和。\ndef solution(nums: List[int]) -\u003e int: \"\"\" 主要是单调栈的应用。 下面的代码还可以进一步简化，比如求两个最小栈可以通过一次循环得到。 \"\"\" length = len(nums) min_left, max_left = [0] * length, [0] * length min_stack, max_stack = [], [] for i in range(length): # min_left 和下面的 min_right 要保证一开一闭，不然会遗漏或重复计算 while min_stack and nums[min_stack[-1]] \u003e nums[i]: min_stack.pop() min_left[i] = min_stack[-1] if min_stack else -1 min_stack.append(i) # max_left 和 max_right 同理 while max_stack and nums[max_stack[-1]] \u003c= nums[i]: max_stack.pop() max_left[i] = max_stack[-1] if max_stack else -1 max_stack.append(i) min_right, max_right = [0] * length, [0] * length min_stack, max_stack = [], [] for i in range(length - 1, -1, -1): while min_stack and nums[min_stack[-1]] \u003e= nums[i]: min_stack.pop() min_right[i] = min_stack[-1] if min_stack else length min_stack.append(i) while max_stack and nums[max_stack[-1]] \u003c nums[i]: max_stack.pop() max_right[i] = max_stack[-1] if max_stack else length max_stack.append(i) res = 0 for i in range(length): res += (i - max_left[i]) * (max_right[i] - i) * nums[i] res -= (i - min_left[i]) * (min_right[i] - i) * nums[i] return res 参考 Leetcode 子数组范围和。\n3. Minimum swaps to sort an array 基于归并排序计算数组中的逆序对，参考 Leetcode 剑指 Offer 51，官方视频讲解非常好，一定要看。\n4. Package shipping minimum cost 一道 DP 题目，大致参考 Leetcode 解决智力问题。\n5. Piles of products def solution(piles: List[int]): ''' dp[i] 表示以 i 位置元素结尾的最大 products 数，则 dp[i] = 等差数列求和[j..i] + dp[j]。 利用单调栈寻找 j 的位置，即 last smaller element，条件为横坐标的差值。 等差数列求和公式：n * (a1 + an) / 2。 ''' res = 0 stack = [] length = len(piles) dp = [0] * length for i in range(length): while stack and piles[stack[-1]] \u003e= piles[i] - (i - stack[-1]): stack.pop() # 注意这里要对 i+1 和 piles[i] 取更小值，因为即使 products 够多，横向可能也不够长 len = min(i + 1, piles[i]) if not stack else i - stack[-1] dp[i] = (piles[i] + piles[i] - len + 1) * len / 2 + (0 if not stack else dp[stack[-1]]) res = max(res, dp[i]) stack.append(i) return res 6. Power subset sums 第二题碰到的便是这个，算是很有难度的一道了。可惜准备不足，当场没有写出理想的解法，后来还专门写了一篇做记录：Sum of Total Strength of Wizards（Leetcode 有原题）。真的碰到不会的话最好写个暴力解法，至少还可以过一些 Simple cases，应该不至于影响最终结果。\n7. Max deviation of all strings 一道 DP 题目，参考 Leetcode 最大波动的子字符串。\n准备的时候尝试看了看，没有特别理解，于是便放弃了，好在也没碰到。\n希望能帮助到有需要的人，Good luck！\n",
  "wordCount" : "2931",
  "inLanguage": "en",
  "datePublished": "2022-08-11T07:19:04+08:00",
  "dateModified": "2022-08-11T07:19:04+08:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://iamgodot.com/posts/amazon-oa-2022/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Godot's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://iamgodot.com/icons/favicon.ico"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://iamgodot.com" accesskey="h" title="Godot&#39;s Blog (Alt + H)">Godot&#39;s Blog</a>
            <span class="logo-switches">
            </span>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Amazon OA 2022
    </h1>
    <div class="post-meta"><span title='2022-08-11 07:19:04 +0800 CST'>08-11</span>&nbsp;·&nbsp;14 min

</div>
  </header> <div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#easy" aria-label="Easy">Easy</a><ul>
                        
                <li>
                    <a href="#1-maximum-quality-sent-via-a-channel" aria-label="1. Maximum quality sent via a channel">1. Maximum quality sent via a channel</a></li>
                <li>
                    <a href="#2-minimum-swaps-to-make-max--min-corners" aria-label="2. Minimum swaps to make max &amp;amp; min corners">2. Minimum swaps to make max &amp; min corners</a></li>
                <li>
                    <a href="#3-grouping-digits" aria-label="3. Grouping digits">3. Grouping digits</a></li>
                <li>
                    <a href="#4-minimum-swaps-to-make-binary-palindrome" aria-label="4. Minimum swaps to make binary palindrome">4. Minimum swaps to make binary palindrome</a></li>
                <li>
                    <a href="#5-max-subarray-length-with-product-1" aria-label="5. Max subarray length with product 1">5. Max subarray length with product 1</a></li>
                <li>
                    <a href="#6-valid-discount-coupon" aria-label="6. Valid discount coupon">6. Valid discount coupon</a></li>
                <li>
                    <a href="#7-linked-list-max-pair" aria-label="7. Linked list max pair">7. Linked list max pair</a></li>
                <li>
                    <a href="#8-combine-if-left-is-smaller-than-right" aria-label="8. Combine if left is smaller than right">8. Combine if left is smaller than right</a></li>
                <li>
                    <a href="#9-minimum-number-of-rounds" aria-label="9. Minimum number of rounds">9. Minimum number of rounds</a></li>
                <li>
                    <a href="#10-kindle-pages" aria-label="10. Kindle pages">10. Kindle pages</a></li>
                <li>
                    <a href="#11-nearest-restaurant" aria-label="11. Nearest restaurant">11. Nearest restaurant</a></li>
                <li>
                    <a href="#12-mex-array" aria-label="12. MEX array">12. MEX array</a></li></ul>
                </li>
                <li>
                    <a href="#medium" aria-label="Medium">Medium</a><ul>
                        
                <li>
                    <a href="#1-maximum-number-of-engineering-teams" aria-label="1. Maximum number of engineering teams">1. Maximum number of engineering teams</a></li>
                <li>
                    <a href="#2-decreasing-ratings" aria-label="2. Decreasing ratings">2. Decreasing ratings</a></li>
                <li>
                    <a href="#3-maximum-sustainable-cluster-size" aria-label="3. Maximum sustainable cluster size">3. Maximum sustainable cluster size</a></li>
                <li>
                    <a href="#4-wifi-router" aria-label="4. WIFI router">4. WIFI router</a></li>
                <li>
                    <a href="#5-robot-with-strings" aria-label="5. Robot with strings">5. Robot with strings</a></li>
                <li>
                    <a href="#6-demolition-robots" aria-label="6. Demolition robots">6. Demolition robots</a></li>
                <li>
                    <a href="#7-prime-air-route" aria-label="7. Prime air route">7. Prime air route</a></li>
                <li>
                    <a href="#8-kindle-brackets" aria-label="8. Kindle brackets">8. Kindle brackets</a></li>
                <li>
                    <a href="#9-dna-sequencing" aria-label="9. DNA sequencing">9. DNA sequencing</a></li>
                <li>
                    <a href="#10-insert--view" aria-label="10. Insert &amp;amp; View">10. Insert &amp; View</a></li>
                <li>
                    <a href="#11-province-connected" aria-label="11. Province connected">11. Province connected</a></li>
                <li>
                    <a href="#12-best-combo-inventory" aria-label="12. Best combo inventory">12. Best combo inventory</a></li></ul>
                </li>
                <li>
                    <a href="#hard" aria-label="Hard">Hard</a><ul>
                        
                <li>
                    <a href="#1-maximum-password-strength" aria-label="1. Maximum password strength">1. Maximum password strength</a></li>
                <li>
                    <a href="#2-shipment-imbalance" aria-label="2. Shipment imbalance">2. Shipment imbalance</a></li>
                <li>
                    <a href="#3-minimum-swaps-to-sort-an-array" aria-label="3. Minimum swaps to sort an array">3. Minimum swaps to sort an array</a></li>
                <li>
                    <a href="#4-package-shipping-minimum-cost" aria-label="4. Package shipping minimum cost">4. Package shipping minimum cost</a></li>
                <li>
                    <a href="#5-piles-of-products" aria-label="5. Piles of products">5. Piles of products</a></li>
                <li>
                    <a href="#6-power-subset-sums" aria-label="6. Power subset sums">6. Power subset sums</a></li>
                <li>
                    <a href="#7-max-deviation-of-all-strings" aria-label="7. Max deviation of all strings">7. Max deviation of all strings</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>分享一下今年准备 Amazon OA 时整理的题目。</p>
<p>按照低中高的难度简单分了下类，最后的难题能理解思路是最好的，不建议死记硬背。</p>
<h1 id="easy">Easy<a hidden class="anchor" aria-hidden="true" href="#easy">#</a></h1>
<h2 id="1-maximum-quality-sent-via-a-channel">1. Maximum quality sent via a channel<a hidden class="anchor" aria-hidden="true" href="#1-maximum-quality-sent-via-a-channel">#</a></h2>
<blockquote>
<p>给一个 packets 数组和 k 个 channel，要求每个 channel 里面必须至少有一个数组里面的元素，每个元素只能在一个 channel 里面。其中 packets 中的元素数量是大于等于 k 的。要求算出所有channel中位数之和的最大值。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">solution</span>(packets: List[int], channels: int) <span style="color:#f92672">-&gt;</span> int:
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    将 packets 排序，依次把最大的一个元素分配给各 channel，
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    剩下的元素放到最后一个 channel。
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    packets<span style="color:#f92672">.</span>sort()
</span></span><span style="display:flex;"><span>    total <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    length <span style="color:#f92672">=</span> len(packets)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(length <span style="color:#f92672">-</span> channels <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, length):
</span></span><span style="display:flex;"><span>        total <span style="color:#f92672">+=</span> packets[i]
</span></span><span style="display:flex;"><span>    rest <span style="color:#f92672">=</span> length <span style="color:#f92672">-</span> channels <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> rest <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
</span></span><span style="display:flex;"><span>        sum <span style="color:#f92672">=</span> packets[(rest <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">//</span> <span style="color:#ae81ff">2</span>] <span style="color:#f92672">+</span> packets[rest <span style="color:#f92672">//</span> <span style="color:#ae81ff">2</span>]
</span></span><span style="display:flex;"><span>        total <span style="color:#f92672">+=</span> sum <span style="color:#f92672">//</span> <span style="color:#ae81ff">2</span> <span style="color:#66d9ef">if</span> sum <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#66d9ef">else</span> sum <span style="color:#f92672">//</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>        total <span style="color:#f92672">+=</span> packets[rest <span style="color:#f92672">//</span> <span style="color:#ae81ff">2</span>]
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> total
</span></span></code></pre></div><p>这是当时做 OA 的第一题，很轻松搞定，结果第二题非常 Hard，下面会提到。</p>
<h2 id="2-minimum-swaps-to-make-max--min-corners">2. Minimum swaps to make max &amp; min corners<a hidden class="anchor" aria-hidden="true" href="#2-minimum-swaps-to-make-max--min-corners">#</a></h2>
<blockquote>
<p>大意是对于一个数组，把最小值和最大值分别移动到左右两端最少需要多少次交换。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">solution</span>(nums: List[int]):
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#39;&#39;&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    先遍历出最小值和最大值的下标，再计算距离即可。
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    如果两个值会出现交换则结果减一。
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#39;&#39;&#39;</span>
</span></span><span style="display:flex;"><span>    min_, max_ <span style="color:#f92672">=</span> float(<span style="color:#e6db74">&#39;inf&#39;</span>), <span style="color:#f92672">-</span>float(<span style="color:#e6db74">&#39;inf&#39;</span>)
</span></span><span style="display:flex;"><span>    index_min <span style="color:#f92672">=</span> index_max <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(nums)):
</span></span><span style="display:flex;"><span>        num <span style="color:#f92672">=</span> nums[i]
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> num <span style="color:#f92672">&lt;</span> min_:
</span></span><span style="display:flex;"><span>            index_min <span style="color:#f92672">=</span> i
</span></span><span style="display:flex;"><span>            min_ <span style="color:#f92672">=</span> num
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> num <span style="color:#f92672">&gt;</span> max_:
</span></span><span style="display:flex;"><span>            index_max <span style="color:#f92672">=</span> i
</span></span><span style="display:flex;"><span>            max_ <span style="color:#f92672">=</span> num
</span></span><span style="display:flex;"><span>    swaps <span style="color:#f92672">=</span> index_min <span style="color:#f92672">+</span> len(nums) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span> index_max
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> swaps <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> <span style="color:#66d9ef">if</span> index_max <span style="color:#f92672">&lt;</span> index_min <span style="color:#66d9ef">else</span> swaps
</span></span></code></pre></div><h2 id="3-grouping-digits">3. Grouping digits<a hidden class="anchor" aria-hidden="true" href="#3-grouping-digits">#</a></h2>
<blockquote>
<p>给定一个只包含 0 和 1 的数组，将所有的 0 和 1 分别放置到数组的任意两端，最少需要多少次交换。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">solution</span>(array: List[int]):
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#39;&#39;&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    思路是先假设把所有的 1 交换到右端，
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    从左遍历数组，累积记录交换次数。
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    当然也可以把 1 交换到左端，所以最后比较选择更小值。
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#39;&#39;&#39;</span>
</span></span><span style="display:flex;"><span>    res1 <span style="color:#f92672">=</span> num_of_1 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> digit <span style="color:#f92672">in</span> array:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> digit <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>:
</span></span><span style="display:flex;"><span>            num_of_1 <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>            res1 <span style="color:#f92672">+=</span> num_of_1
</span></span><span style="display:flex;"><span>    num_of_0 <span style="color:#f92672">=</span> len(array) <span style="color:#f92672">-</span> num_of_1
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> min(res1, num_of_0 <span style="color:#f92672">*</span> num_of_1 <span style="color:#f92672">-</span> res1)
</span></span></code></pre></div><p>更详细的解释可以参考 <a href="https://stackoverflow.com/questions/63513603/what-is-the-minimum-number-of-adjacent-swaps-needed-to-segregate-a-list-of-0s-an">Stackoverflow</a>。</p>
<h2 id="4-minimum-swaps-to-make-binary-palindrome">4. Minimum swaps to make binary palindrome<a hidden class="anchor" aria-hidden="true" href="#4-minimum-swaps-to-make-binary-palindrome">#</a></h2>
<blockquote>
<p>给一个只有 0 和 1 的数组，找到形成回文结构的最小交换次数。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">solution</span>(binary: List[int]):
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    双指针从两端开始看，记录 diff 总数。
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    如果 diff 为偶数，那么交换次数为 diff 的一半即可，比如 0101；
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    如果 diff 为奇数但是总位数为偶数则不可能做到，比如01；
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    如果 diff 为奇数总位数也为偶数则也交换 diff 的一半次数即可，比如011。
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    n <span style="color:#f92672">=</span> len(binary)
</span></span><span style="display:flex;"><span>    count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(n <span style="color:#f92672">//</span> <span style="color:#ae81ff">2</span>):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> binary[i] <span style="color:#f92672">!=</span> binary[n <span style="color:#f92672">-</span> i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>]:
</span></span><span style="display:flex;"><span>            count <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> count <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">and</span> n <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> (count <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">//</span> <span style="color:#ae81ff">2</span>
</span></span></code></pre></div><h2 id="5-max-subarray-length-with-product-1">5. Max subarray length with product 1<a hidden class="anchor" aria-hidden="true" href="#5-max-subarray-length-with-product-1">#</a></h2>
<blockquote>
<p>给一个只有 -1 和 1 的数组，找到最长的子数组长度，条件是乘积为 1。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">solution</span>(array: List[int]):
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    思路是如果整个数组中包含偶数个 -1，那么结果为总长度；
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    否则找到两端的 -1，然后比较两个剩余长度。
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    neg_count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    neg_first <span style="color:#f92672">=</span> neg_last <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    length <span style="color:#f92672">=</span> len(array)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(length):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> array[i] <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> neg_first <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
</span></span><span style="display:flex;"><span>                neg_first <span style="color:#f92672">=</span> i
</span></span><span style="display:flex;"><span>            neg_last <span style="color:#f92672">=</span> i
</span></span><span style="display:flex;"><span>            neg_count <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> length <span style="color:#66d9ef">if</span> neg_count <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#66d9ef">else</span> max(length <span style="color:#f92672">-</span> neg_first <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, neg_last)
</span></span></code></pre></div><h2 id="6-valid-discount-coupon">6. Valid discount coupon<a hidden class="anchor" aria-hidden="true" href="#6-valid-discount-coupon">#</a></h2>
<blockquote>
<p>大意是对于一个字符串来说，Valid 的条件是空字符串，或者一个 Valid 字符串两端加上相同字符，或者两个 Valid 字符串相连。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">solution</span>(s: str):
</span></span><span style="display:flex;"><span>    stack <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> char <span style="color:#f92672">in</span> s:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> stack <span style="color:#f92672">or</span> stack[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">!=</span> char:
</span></span><span style="display:flex;"><span>            stack<span style="color:#f92672">.</span>append(char)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>            stack<span style="color:#f92672">.</span>pop()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> len(stack) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>
</span></span></code></pre></div><h2 id="7-linked-list-max-pair">7. Linked list max pair<a hidden class="anchor" aria-hidden="true" href="#7-linked-list-max-pair">#</a></h2>
<blockquote>
<p>给一个偶数个节点的链表，对于每对第 n 个和倒数第 n 个的和，求最大值。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">solution</span>(head: ListNode):
</span></span><span style="display:flex;"><span>    slow <span style="color:#f92672">=</span> fast <span style="color:#f92672">=</span> head
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> fast <span style="color:#f92672">and</span> fast<span style="color:#f92672">.</span>next:
</span></span><span style="display:flex;"><span>        slow <span style="color:#f92672">=</span> slow<span style="color:#f92672">.</span>next
</span></span><span style="display:flex;"><span>        fast <span style="color:#f92672">=</span> fast<span style="color:#f92672">.</span>next<span style="color:#f92672">.</span>next
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    first <span style="color:#f92672">=</span> head
</span></span><span style="display:flex;"><span>    second <span style="color:#f92672">=</span> slow<span style="color:#f92672">.</span>next
</span></span><span style="display:flex;"><span>    slow<span style="color:#f92672">.</span>next <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># 这里需要自己实现一个 reverse</span>
</span></span><span style="display:flex;"><span>    second <span style="color:#f92672">=</span> reverse(second)
</span></span><span style="display:flex;"><span>    res <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>float(<span style="color:#e6db74">&#39;inf&#39;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> first:
</span></span><span style="display:flex;"><span>        res <span style="color:#f92672">=</span> max(res, first<span style="color:#f92672">.</span>val <span style="color:#f92672">+</span> second<span style="color:#f92672">.</span>val)
</span></span><span style="display:flex;"><span>        first <span style="color:#f92672">=</span> first<span style="color:#f92672">.</span>next
</span></span><span style="display:flex;"><span>        second <span style="color:#f92672">=</span> second<span style="color:#f92672">.</span>next
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> res
</span></span></code></pre></div><h2 id="8-combine-if-left-is-smaller-than-right">8. Combine if left is smaller than right<a hidden class="anchor" aria-hidden="true" href="#8-combine-if-left-is-smaller-than-right">#</a></h2>
<blockquote>
<p>大意是对一个数组（package 之类的）进行合并，条件是左边元素小于右边，求合并之后数组中的最大值。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">solution</span>(nums: List[int]) <span style="color:#f92672">-&gt;</span> int:
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    注意要从后往前遍历。
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> nums:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    res <span style="color:#f92672">=</span> cur <span style="color:#f92672">=</span> nums[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(nums) <span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> nums[i] <span style="color:#f92672">&lt;</span> cur:
</span></span><span style="display:flex;"><span>            cur <span style="color:#f92672">+=</span> nums[i]
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>            cur <span style="color:#f92672">=</span> nums[i]
</span></span><span style="display:flex;"><span>        res <span style="color:#f92672">=</span> max(res, cur)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> res
</span></span></code></pre></div><h2 id="9-minimum-number-of-rounds">9. Minimum number of rounds<a hidden class="anchor" aria-hidden="true" href="#9-minimum-number-of-rounds">#</a></h2>
<blockquote>
<p>Deliver boxes，一次只能运送两个或三个相同重量的 box，求最小运送次数。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">solution</span>(weights: List[int]):
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">from</span> collections <span style="color:#f92672">import</span> Counter
</span></span><span style="display:flex;"><span>    counts <span style="color:#f92672">=</span> Counter(weights)
</span></span><span style="display:flex;"><span>    ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> k, v <span style="color:#f92672">in</span> counts<span style="color:#f92672">.</span>items():
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> v <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>            ans <span style="color:#f92672">+=</span> v <span style="color:#f92672">//</span> <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>            ans <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span> <span style="color:#66d9ef">if</span> v <span style="color:#f92672">%</span> <span style="color:#ae81ff">3</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> <span style="color:#66d9ef">else</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> ans
</span></span></code></pre></div><h2 id="10-kindle-pages">10. Kindle pages<a hidden class="anchor" aria-hidden="true" href="#10-kindle-pages">#</a></h2>
<blockquote>
<p>大意是在一个 0 和 1 的序列中找到满足 010/101 的组合数量。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">solution</span>(s: str) <span style="color:#f92672">-&gt;</span> int:
</span></span><span style="display:flex;"><span>    n <span style="color:#f92672">=</span> len(s)
</span></span><span style="display:flex;"><span>    n1 <span style="color:#f92672">=</span> s<span style="color:#f92672">.</span>count(<span style="color:#e6db74">&#39;1&#39;</span>)
</span></span><span style="display:flex;"><span>    n1_cur <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    res <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i, char <span style="color:#f92672">in</span> enumerate(s):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> char <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;0&#39;</span>:
</span></span><span style="display:flex;"><span>            res <span style="color:#f92672">+=</span> n1_cur <span style="color:#f92672">*</span> (n1 <span style="color:#f92672">-</span> n1_cur)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>            res <span style="color:#f92672">+=</span> (i <span style="color:#f92672">-</span> n1_cur) <span style="color:#f92672">*</span> (n <span style="color:#f92672">-</span> n1 <span style="color:#f92672">-</span> i <span style="color:#f92672">+</span> n1_cur)
</span></span><span style="display:flex;"><span>            n1_cur <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> res
</span></span></code></pre></div><p>参考 Leetcode <a href="https://leetcode.cn/problems/number-of-ways-to-select-buildings/">选择建筑的方案数</a>。</p>
<h2 id="11-nearest-restaurant">11. Nearest restaurant<a hidden class="anchor" aria-hidden="true" href="#11-nearest-restaurant">#</a></h2>
<blockquote>
<p>选择最近的 k 个点。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">solution</span>(points: List[List[int]], k: int) <span style="color:#f92672">-&gt;</span> List[List[int]]:
</span></span><span style="display:flex;"><span>    heap <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">import</span> heapq
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> p <span style="color:#f92672">in</span> points:
</span></span><span style="display:flex;"><span>        x, y <span style="color:#f92672">=</span> p 
</span></span><span style="display:flex;"><span>        element <span style="color:#f92672">=</span> [<span style="color:#f92672">-</span>x<span style="color:#f92672">**</span><span style="color:#ae81ff">2</span><span style="color:#f92672">-</span>y<span style="color:#f92672">**</span><span style="color:#ae81ff">2</span>, p]
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> len(heap) <span style="color:#f92672">==</span> k:
</span></span><span style="display:flex;"><span>            heapq<span style="color:#f92672">.</span>heappushpop(heap, element)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>            heapq<span style="color:#f92672">.</span>heappush(heap, element)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> [item[<span style="color:#ae81ff">1</span>] <span style="color:#66d9ef">for</span> item <span style="color:#f92672">in</span> heap]
</span></span></code></pre></div><p>参考 Leetcode <a href="https://leetcode.cn/problems/k-closest-points-to-origin/">最接近原点的 K 个点</a>。</p>
<h2 id="12-mex-array">12. MEX array<a hidden class="anchor" aria-hidden="true" href="#12-mex-array">#</a></h2>
<blockquote>
<p>很有意思的一道题。</p>
<p>The MEX of an array is equal to the smallest positive integer that is not present in the array.</p>
<p>给一个大小为 N 的正数数组，元素值各不相同。对于每个元素，如果去掉的话，找到对应的 MEX，返回同样大小为 N 的结果数组。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">solution</span>(nums: List[int], n: int):
</span></span><span style="display:flex;"><span>    length <span style="color:#f92672">=</span> <span style="color:#ae81ff">100001</span>
</span></span><span style="display:flex;"><span>    hashtable <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> length
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(n):
</span></span><span style="display:flex;"><span>        hashtable[nums[i]] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    mex <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, length):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> hashtable[i] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
</span></span><span style="display:flex;"><span>            mex <span style="color:#f92672">=</span> i
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>    res <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> n
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(n):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> nums[i] <span style="color:#f92672">&lt;</span> mex:
</span></span><span style="display:flex;"><span>            res[i] <span style="color:#f92672">=</span> nums[i]
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>            res[i] <span style="color:#f92672">=</span> mex
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> res
</span></span></code></pre></div><p>参考 <a href="https://www.geeksforgeeks.org/construct-mex-array-from-the-given-array/">Construct MEX array from the given array</a>。</p>
<h1 id="medium">Medium<a hidden class="anchor" aria-hidden="true" href="#medium">#</a></h1>
<h2 id="1-maximum-number-of-engineering-teams">1. Maximum number of engineering teams<a hidden class="anchor" aria-hidden="true" href="#1-maximum-number-of-engineering-teams">#</a></h2>
<blockquote>
<p>一个数组表示 engineers，数值表示 skill，组建 team_size 个人的团队，每个团队的 skill 差距不能超过 maxdiff。求最多能组建多少个团队。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">solution</span>(team_size: int, maxdiff: int, skill: List[int]):
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;&#34;&#34;贪心，将 skill 排序后从头查找即可。&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    teams <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    skill<span style="color:#f92672">.</span>sort()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> i <span style="color:#f92672">&lt;</span> len(skill):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> i <span style="color:#f92672">+</span> team_size <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&gt;=</span> len(skill):
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> skill[i<span style="color:#f92672">+</span>team_size<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">-</span> skill[i] <span style="color:#f92672">&gt;</span> maxdiff:
</span></span><span style="display:flex;"><span>            i <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">continue</span>
</span></span><span style="display:flex;"><span>        teams <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>        i <span style="color:#f92672">+=</span> team_size
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> teams
</span></span></code></pre></div><h2 id="2-decreasing-ratings">2. Decreasing ratings<a hidden class="anchor" aria-hidden="true" href="#2-decreasing-ratings">#</a></h2>
<blockquote>
<p>给一个数组，求连续下降的子数组个数。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">solution</span>(ratings: List[int]) <span style="color:#f92672">-&gt;</span> int:
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    大致思路是滑动窗口找单调递减的子数组。
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    过程中不断叠加子数组长度即可，比如 [...1, 2, 3...]，
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    满足条件的有 1, 2, 3, 1 2, 2 3, 1 2 3 一共 1 + 2 + 3= 6 个。
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    res <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    left <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> right <span style="color:#f92672">in</span> range(len(ratings)):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> right <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">and</span> ratings[right <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">-</span> ratings[right] <span style="color:#f92672">!=</span> <span style="color:#ae81ff">1</span>:
</span></span><span style="display:flex;"><span>            left <span style="color:#f92672">=</span> right
</span></span><span style="display:flex;"><span>        res <span style="color:#f92672">+=</span> right <span style="color:#f92672">-</span> left <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> res
</span></span></code></pre></div><h2 id="3-maximum-sustainable-cluster-size">3. Maximum sustainable cluster size<a hidden class="anchor" aria-hidden="true" href="#3-maximum-sustainable-cluster-size">#</a></h2>
<blockquote>
<p>Question on AWS power consumption, given BootingPower[i], processingPower[i], powerMax.</p>
<p>For maximum utilization, the data center wishes to group these processors into clusters.</p>
<p>Clusters can only be formed of processors located adjacent to each other.</p>
<p>For example, processors 2,3,4,5 can form a cluster, but 1,3,4 cannot.    cluster of k processors defined as (i, i+1,&hellip;., i+k-1)</p>
<p>Net power consumption = maximum booting power among the k processors + (sum of processing power of processors)*k.</p>
<p>A cluster is said to be sustainable if it&rsquo;s net power consumption does not exceed a given threshold value powerMax.</p>
<p>Example:</p>
<p>bootingPower = [3,6,1,3,4]</p>
<p>processingPower = [2,1,3,4,5]</p>
<p>powerMax = 25</p>
<p>If k = 2, any adjacent pair can be choosen.</p>
<p>The highest usage is the pair [4,5] with net power consumption 4 + (4 + 5)2 = 22.</p>
<p>Next, try k = 3. Group the first 3 processors together as:</p>
<p>Here,</p>
<p>Max booting power = max(3,6,1)</p>
<p>Sum of processing power = 2 + 1+ 3 = 6</p>
<p>Net power consumption = 6 + 63 = 24 &lt;= powerMax</p>
<p>Thus, k = 3 is a sustainable cluster.</p>
<p>Example:</p>
<p>bootingPower = [8,8,10,9,2]</p>
<p>processingPower = [4,1,4,5,3]</p>
<p>powerMax = 33</p>
<p>If k = 2, consisting of first 2 processors.</p>
<p>Net power consumption = max(8,8) + (4+1)*2 = 18 &lt;= 33 (powerMax)</p>
<p>Thus, k = 2 is a sustainable cluster.</p>
<p>Example:</p>
<p>bootingPower = [11,12,19]</p>
<p>processingPower = [10,8,7]</p>
<p>powerMax = 6</p>
<p>k = 0, not possible to form any sustainable clusters.</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">solution</span>(booting_power, processing_power, power_max) <span style="color:#f92672">-&gt;</span> int:
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;&#34;&#34;用单调栈定位 booting_power max，再配合滑动窗口找 max size。&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    size <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    i <span style="color:#f92672">=</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    total <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">from</span> collections <span style="color:#f92672">import</span> deque
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    dq <span style="color:#f92672">=</span> deque([])
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> j <span style="color:#f92672">&lt;</span> len(processing_power):
</span></span><span style="display:flex;"><span>        total <span style="color:#f92672">+=</span> processing_power[j]
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># 注意没有等号，但是如果保存下标的话就可以用等号</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> dq <span style="color:#f92672">and</span> dq[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">&lt;</span> booting_power[j]:
</span></span><span style="display:flex;"><span>            dq<span style="color:#f92672">.</span>pop()
</span></span><span style="display:flex;"><span>        dq<span style="color:#f92672">.</span>append(booting_power[j])
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> i <span style="color:#f92672">&lt;=</span> j <span style="color:#f92672">and</span> dq[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">+</span> total <span style="color:#f92672">*</span> (j <span style="color:#f92672">-</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">&gt;</span> power_max:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> processing_power[i] <span style="color:#f92672">==</span> dq[<span style="color:#ae81ff">0</span>]:
</span></span><span style="display:flex;"><span>                dq<span style="color:#f92672">.</span>popleft()
</span></span><span style="display:flex;"><span>            i <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>        size <span style="color:#f92672">=</span> max(size, j <span style="color:#f92672">-</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        j <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> size
</span></span></code></pre></div><h2 id="4-wifi-router">4. WIFI router<a hidden class="anchor" aria-hidden="true" href="#4-wifi-router">#</a></h2>
<blockquote>
<p>Amazon has installed WiFi routers on the houses along a straight street. The city&rsquo;s buildings are arranged linearly, denoted by indices 1 to n. There are m Amazon routers, and each has a certain range associated with it. Router j installed at a certain building location /can only provide Internet to the buildings in the range [(i - routerRangelin, (i+ routerRange(iN] inclusive, where routerRangeli] is the range parameter of router j.</p>
<p>A building is considered to be served if the number of routers providing Internet to the building is greater than or equal to the number of people living in it. Given a list of the number of people living in each building, the locations of the buildings where the routers will be installed and each router&rsquo;s range, find the number of served buildings in the city.</p>
<p>Example:</p>
<p>buildingCount = [1, 2, 1, 2, 2]</p>
<p>routerLocation = [3, 1]</p>
<p>routerRange = [1, 2]</p>
<p>There are 5 buildings with tenant counts shown in buildingCount.</p>
<p>Routers are located in buildings 3 and 1 with ranges 1 and 2 as shown in routerLocation and routerRange.</p>
<p>The first router is in building 3 and provides Internet to buildings in the range [2, 4].</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">solution</span>(buildings: List[int], locations: List[int], ranges: List[int]):
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    思路是使用差分数组做优化，达到 O(n) 复杂度。
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    差分数组每一位 i 的值是 nums[i] - nums[i-1]，
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    所以更新 [i, j] 只需要更新 i 和 j 两个位置，前者加，后者减，
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    最后对差分数组求前缀和就是原数组。
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    length <span style="color:#f92672">=</span> len(buildings)
</span></span><span style="display:flex;"><span>    cover <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> length
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(locations)):
</span></span><span style="display:flex;"><span>        start <span style="color:#f92672">=</span> min(locations[i] <span style="color:#f92672">-</span> ranges[i] <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>        end <span style="color:#f92672">=</span> max(locations[i] <span style="color:#f92672">+</span> ranges[i], len(locations))
</span></span><span style="display:flex;"><span>        cover[start] <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> end <span style="color:#f92672">&lt;</span> len(locations):
</span></span><span style="display:flex;"><span>            cover[end] <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    res <span style="color:#f92672">=</span> pre <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(length):
</span></span><span style="display:flex;"><span>        cover[i] <span style="color:#f92672">+=</span> pre
</span></span><span style="display:flex;"><span>        pre <span style="color:#f92672">=</span> cover[i]
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> cover[i] <span style="color:#f92672">&gt;=</span> buildings[i]:
</span></span><span style="display:flex;"><span>            res <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> res
</span></span></code></pre></div><p>关于差分数组的应用可以参考 Leetcode <a href="https://leetcode.cn/problems/corporate-flight-bookings/">航班预订统计</a>。</p>
<h2 id="5-robot-with-strings">5. Robot with strings<a hidden class="anchor" aria-hidden="true" href="#5-robot-with-strings">#</a></h2>
<blockquote>
<p>There are three robots named Ray, Ben, and Kevin. Initially Ray has a string S of length N, while the other two robots have empty strings. We can make either of the following moves:</p>
<p>Move 1: Remove the first character from Ray&rsquo;s string and append it to Ben&rsquo;s string.</p>
<p>Move 2: Remove the last character from Ben&rsquo;s string and append it to Kevin&rsquo;s string.</p>
<p>You must perform either fo the two moves mentioned above in such a way that the strings left with Ray and Ben are empty and the string left with Kevin is lexicographically smallest string that Kevin has after completing this activity.</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">solution</span>(s: str):
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#39;&#39;&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    主要思路是先找到（第一个）最小的 char 的 index，把中间的字母都入栈，再往后找。
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    找到之后也需要和栈顶的元素比较，如果栈顶元素更小就不断出栈，即优先使用栈顶元素。
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#39;&#39;&#39;</span>
</span></span><span style="display:flex;"><span>    res <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>    stack <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>    length <span style="color:#f92672">=</span> len(s)
</span></span><span style="display:flex;"><span>    index <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> index <span style="color:#f92672">&lt;</span> length:
</span></span><span style="display:flex;"><span>        smallest <span style="color:#f92672">=</span> index
</span></span><span style="display:flex;"><span>        char <span style="color:#f92672">=</span> s[index]
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(smallest <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, length):
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> s[i] <span style="color:#f92672">&lt;</span> char:
</span></span><span style="display:flex;"><span>                smallest <span style="color:#f92672">=</span> i 
</span></span><span style="display:flex;"><span>                char <span style="color:#f92672">=</span> s[i]
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(index, smallest):
</span></span><span style="display:flex;"><span>            stack<span style="color:#f92672">.</span>append(s[i])
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> stack <span style="color:#f92672">and</span> stack[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">&lt;=</span> char:
</span></span><span style="display:flex;"><span>            res<span style="color:#f92672">.</span>append(stack<span style="color:#f92672">.</span>pop())
</span></span><span style="display:flex;"><span>        res<span style="color:#f92672">.</span>append(char)
</span></span><span style="display:flex;"><span>        index <span style="color:#f92672">=</span> smallest <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> stack:
</span></span><span style="display:flex;"><span>        res<span style="color:#f92672">.</span>append(stack<span style="color:#f92672">.</span>pop())
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#39;&#39;</span><span style="color:#f92672">.</span>join(res)
</span></span></code></pre></div><h2 id="6-demolition-robots">6. Demolition robots<a hidden class="anchor" aria-hidden="true" href="#6-demolition-robots">#</a></h2>
<blockquote>
<p>Given a matrix with values 0 (trenches) , 1 (flat) , and 9 (obstacle) you have to find minimum distance to reach 9 (obstacle). If not possible then return -1.</p>
<p>The demolition robot must start at the top left corner of the matrix, which is always flat, and can move on block up, down, right, left.</p>
<p>The demolition robot cannot enter 0 trenches and cannot leave the matrix.</p>
<p>Sample Input :</p>
<p>[1, 0, 0],</p>
<p>[1, 0, 0],</p>
<p>[1, 9, 1]]</p>
<p>Sample Output :</p>
<p>3</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">solution</span>(grid: List[List[int]]) <span style="color:#f92672">-&gt;</span> int:
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;&#34;&#34;BFS/DFS 均可。&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    m, n <span style="color:#f92672">=</span> len(grid), len(grid[<span style="color:#ae81ff">0</span>])
</span></span><span style="display:flex;"><span>    res <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">from</span> collections <span style="color:#f92672">import</span> deque
</span></span><span style="display:flex;"><span>    dq <span style="color:#f92672">=</span> deque([(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>)])
</span></span><span style="display:flex;"><span>    grid[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> dq:
</span></span><span style="display:flex;"><span>        res <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(len(dq)):
</span></span><span style="display:flex;"><span>            i, j <span style="color:#f92672">=</span> dq<span style="color:#f92672">.</span>pop()
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> x, y <span style="color:#f92672">in</span> (i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, j), (i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, j), (i, j <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>), (i, j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>):
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&lt;=</span> x <span style="color:#f92672">&lt;</span> m <span style="color:#f92672">and</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&lt;=</span> y <span style="color:#f92672">&lt;</span> n <span style="color:#f92672">and</span> grid[x][y] <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>:
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">if</span> grid[x][y] <span style="color:#f92672">==</span> <span style="color:#ae81ff">9</span>:
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">return</span> res
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">if</span> grid[x][y] <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>:
</span></span><span style="display:flex;"><span>                        dq<span style="color:#f92672">.</span>appendleft([x, y])
</span></span><span style="display:flex;"><span>                        grid[x][y] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
</span></span></code></pre></div><h2 id="7-prime-air-route">7. Prime air route<a hidden class="anchor" aria-hidden="true" href="#7-prime-air-route">#</a></h2>
<blockquote>
<p>This problem is a variant of closest pair sum. You&rsquo;ll be given two arraysarr1 = <code>{ {1, 2000}, {2, 3000}, {3, 4000} }</code>arr2 = <code>{ { 1, 5000 }, {2, 3000} }</code>the first element of every pair represents <em>id</em> and the second value represents the <em>value</em>.and a target <code>x = 5000</code>Find the pairs from both the arrays whose vaue add upto a sum which is less than given target and should be closest to the target.</p>
<p>Output for the above example:<code>{ {1, 2} }</code> // Note that the output should be in id&rsquo;s</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">prime</span>(
</span></span><span style="display:flex;"><span>    data_in: List[List[int]], data_out: List[List[int]], target: int
</span></span><span style="display:flex;"><span>) <span style="color:#f92672">-&gt;</span> List[List[int]]:
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    思路大概和 closest 3sum 一致：
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    1. 两个列表排序
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    2. sum 大于 target 则 high--
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    3. sum 小于等于需要进一步划分
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">      1. 如果 distance 小于之前则清空结果列表，否则不动
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">      2. 加入当前 pair，并且对于 low 和 high 继续往中间查找相同元素，取笛卡尔积并保存结果
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">from</span> itertools <span style="color:#f92672">import</span> product
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    data_in<span style="color:#f92672">.</span>sort(key<span style="color:#f92672">=</span><span style="color:#66d9ef">lambda</span> x: x[<span style="color:#ae81ff">1</span>])
</span></span><span style="display:flex;"><span>    data_out<span style="color:#f92672">.</span>sort(key<span style="color:#f92672">=</span><span style="color:#66d9ef">lambda</span> x: x[<span style="color:#ae81ff">1</span>])
</span></span><span style="display:flex;"><span>    low, high <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, len(data_out) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    sum, distance <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, float(<span style="color:#e6db74">&#34;inf&#34;</span>)
</span></span><span style="display:flex;"><span>    res <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> low <span style="color:#f92672">&lt;</span> len(data_in) <span style="color:#f92672">and</span> high <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>:
</span></span><span style="display:flex;"><span>        m, n <span style="color:#f92672">=</span> data_in[low][<span style="color:#ae81ff">1</span>], data_out[high][<span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>        sum <span style="color:#f92672">=</span> m <span style="color:#f92672">+</span> n
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> sum <span style="color:#f92672">&lt;=</span> target:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> abs(sum <span style="color:#f92672">-</span> target) <span style="color:#f92672">&lt;</span> distance:
</span></span><span style="display:flex;"><span>                res<span style="color:#f92672">.</span>clear()
</span></span><span style="display:flex;"><span>                distance <span style="color:#f92672">=</span> abs(sum <span style="color:#f92672">-</span> target)
</span></span><span style="display:flex;"><span>            lefts, rights <span style="color:#f92672">=</span> [], []
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">while</span> low <span style="color:#f92672">&lt;</span> len(data_in) <span style="color:#f92672">and</span> data_in[low][<span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> m:
</span></span><span style="display:flex;"><span>                lefts<span style="color:#f92672">.</span>append(data_in[low][<span style="color:#ae81ff">0</span>])
</span></span><span style="display:flex;"><span>                low <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">while</span> high <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">and</span> data_out[high][<span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> n:
</span></span><span style="display:flex;"><span>                rights<span style="color:#f92672">.</span>append(data_out[high][<span style="color:#ae81ff">0</span>])
</span></span><span style="display:flex;"><span>                high <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> id1, id2 <span style="color:#f92672">in</span> product(lefts, rights):
</span></span><span style="display:flex;"><span>                res<span style="color:#f92672">.</span>append([id1, id2])
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>            high <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> res
</span></span></code></pre></div><h2 id="8-kindle-brackets">8. Kindle brackets<a hidden class="anchor" aria-hidden="true" href="#8-kindle-brackets">#</a></h2>
<blockquote>
<p>There is a string with the charcater [,(,),],? find the number of possible ways to divide the string into two substring (Continuoes) such that number of open and closing bracket should be same in both substring with same type, you can use ? as a wild card to satisfy either opening or closing bracket of any type.</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">brackets</span>(s: str):
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">from</span> collections <span style="color:#f92672">import</span> Counter, defaultdict
</span></span><span style="display:flex;"><span>    right <span style="color:#f92672">=</span> Counter(s)
</span></span><span style="display:flex;"><span>    left <span style="color:#f92672">=</span> defaultdict(int)
</span></span><span style="display:flex;"><span>    ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i, c <span style="color:#f92672">in</span> enumerate(s[:<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]):
</span></span><span style="display:flex;"><span>        right[c] <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>        left[c] <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        left_bra_diff <span style="color:#f92672">=</span> abs(left[<span style="color:#e6db74">&#39;[&#39;</span>] <span style="color:#f92672">-</span> left[<span style="color:#e6db74">&#39;]&#39;</span>])
</span></span><span style="display:flex;"><span>        left_par_diff <span style="color:#f92672">=</span> abs(left[<span style="color:#e6db74">&#39;(&#39;</span>] <span style="color:#f92672">-</span> left[<span style="color:#e6db74">&#39;)&#39;</span>])
</span></span><span style="display:flex;"><span>        left_diff <span style="color:#f92672">=</span> left_bra_diff <span style="color:#f92672">+</span> left_par_diff
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        right_bra_diff <span style="color:#f92672">=</span> abs(right[<span style="color:#e6db74">&#39;[&#39;</span>] <span style="color:#f92672">-</span> right[<span style="color:#e6db74">&#39;]&#39;</span>])
</span></span><span style="display:flex;"><span>        right_par_diff <span style="color:#f92672">=</span> abs(right[<span style="color:#e6db74">&#39;(&#39;</span>] <span style="color:#f92672">-</span> right[<span style="color:#e6db74">&#39;)&#39;</span>])
</span></span><span style="display:flex;"><span>        right_diff <span style="color:#f92672">=</span> right_bra_diff <span style="color:#f92672">+</span> right_par_diff
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (left_diff <span style="color:#f92672">&lt;=</span> left[<span style="color:#e6db74">&#39;?&#39;</span>] <span style="color:#f92672">and</span> (left[<span style="color:#e6db74">&#39;?&#39;</span>] <span style="color:#f92672">-</span> left_diff) <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#f92672">and</span> (right_diff <span style="color:#f92672">&lt;=</span> right[<span style="color:#e6db74">&#39;?&#39;</span>] <span style="color:#f92672">and</span> (right[<span style="color:#e6db74">&#39;?&#39;</span>] <span style="color:#f92672">-</span> right_diff) <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>):
</span></span><span style="display:flex;"><span>            ans <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> ans
</span></span></code></pre></div><h2 id="9-dna-sequencing">9. DNA sequencing<a hidden class="anchor" aria-hidden="true" href="#9-dna-sequencing">#</a></h2>
<p>Trie 的应用，主要在于通过倒序插入字符来匹配 Stream 中出现的相似 Pattern。</p>
<p>参考 Leetcode <a href="https://leetcode.cn/problems/stream-of-characters/">字符流</a>。</p>
<h2 id="10-insert--view">10. Insert &amp; View<a hidden class="anchor" aria-hidden="true" href="#10-insert--view">#</a></h2>
<blockquote>
<p>自定义一个堆，实现 Insert 和 View 两个接口。每次 View 的时候都会查找下一个最小值，比如第一次查找最小值，第二次查找倒数第二小值，依次类推。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> heapq
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MaxHeapObj</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __init__(self, val, name):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>val <span style="color:#f92672">=</span> val
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>name <span style="color:#f92672">=</span> name
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __lt__(self, other):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> self<span style="color:#f92672">.</span>val <span style="color:#f92672">==</span> other<span style="color:#f92672">.</span>val:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>name <span style="color:#f92672">&gt;</span> other<span style="color:#f92672">.</span>name
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>val <span style="color:#f92672">&gt;</span> other<span style="color:#f92672">.</span>val
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __eq__(self, other):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>val <span style="color:#f92672">==</span> other<span style="color:#f92672">.</span>val <span style="color:#f92672">and</span> self<span style="color:#f92672">.</span>name <span style="color:#f92672">==</span> other<span style="color:#f92672">.</span>name
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __str__(self):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> str(self<span style="color:#f92672">.</span>val)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CustomHeap</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __init__(self):
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># 主要思路还是保证 max heap 中有 view_count 个最小的元素，</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># 这样 min heap 顶端的元素就是第 k 小的，view 的时候直接返回即可</span>
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>min_heap <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>max_heap <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>view_count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">addToHeap</span>(self, name, value):
</span></span><span style="display:flex;"><span>        heapq<span style="color:#f92672">.</span>heappush(self<span style="color:#f92672">.</span>min_heap, (value, name))
</span></span><span style="display:flex;"><span>        val, name <span style="color:#f92672">=</span> heapq<span style="color:#f92672">.</span>heappop(self<span style="color:#f92672">.</span>min_heap)
</span></span><span style="display:flex;"><span>        heapq<span style="color:#f92672">.</span>heappush(self<span style="color:#f92672">.</span>max_heap, MaxHeapObj(val, name))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># maintain the size property</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> len(self<span style="color:#f92672">.</span>max_heap) <span style="color:#f92672">&gt;</span> self<span style="color:#f92672">.</span>view_count:
</span></span><span style="display:flex;"><span>            max_heap_obj <span style="color:#f92672">=</span> heapq<span style="color:#f92672">.</span>heappop(self<span style="color:#f92672">.</span>max_heap)
</span></span><span style="display:flex;"><span>            val, name <span style="color:#f92672">=</span> max_heap_obj<span style="color:#f92672">.</span>val, max_heap_obj<span style="color:#f92672">.</span>name
</span></span><span style="display:flex;"><span>            heapq<span style="color:#f92672">.</span>heappush(self<span style="color:#f92672">.</span>min_heap, (val, name))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">view</span>(self):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>view_count <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># 这种情况出现在连续多次 view 的时候；</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># 应该不用考虑 view 次数超过 item 数量的情况，那样的话 min_heap 空了会报错</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> len(self<span style="color:#f92672">.</span>max_heap) <span style="color:#f92672">&lt;</span> self<span style="color:#f92672">.</span>view_count <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>:
</span></span><span style="display:flex;"><span>            val, name <span style="color:#f92672">=</span> heapq<span style="color:#f92672">.</span>heappop(self<span style="color:#f92672">.</span>min_heap)
</span></span><span style="display:flex;"><span>            heapq<span style="color:#f92672">.</span>heappush(self<span style="color:#f92672">.</span>max_heap, MaxHeapObj(val, name))
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>min_heap[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">1</span>]
</span></span></code></pre></div><h2 id="11-province-connected">11. Province connected<a hidden class="anchor" aria-hidden="true" href="#11-province-connected">#</a></h2>
<p>参考 Leetcode <a href="https://leetcode.cn/problems/number-of-provinces/">省份数量</a>。</p>
<h2 id="12-best-combo-inventory">12. Best combo inventory<a hidden class="anchor" aria-hidden="true" href="#12-best-combo-inventory">#</a></h2>
<blockquote>
<p>Amazon Shopping has n items in inventory. Each item has a rating that may be negative. The team wants to work on an algorithm that will suggest combinations of these items that customers might buy, or, combos for short.</p>
<p>Example:</p>
<p>n = 3, popularity = [3, 5, -2], k = 3</p>
<p>Output [8, 6, 5]</p>
<p>大意应该是找出最贵的前 k 个组合。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">find_max_subsets</span>(array: List[int], k: int):
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;&#34;&#34;基本思路是最大堆配合回溯。&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">import</span> heapq
</span></span><span style="display:flex;"><span>    res <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>    heap <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">bt</span>(index, val):
</span></span><span style="display:flex;"><span>        heapq<span style="color:#f92672">.</span>heappush(heap, <span style="color:#f92672">-</span>val)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(index, len(array)):
</span></span><span style="display:flex;"><span>            val <span style="color:#f92672">+=</span> array[i]
</span></span><span style="display:flex;"><span>            bt(i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, val)
</span></span><span style="display:flex;"><span>            val <span style="color:#f92672">-=</span> array[i]
</span></span><span style="display:flex;"><span>    bt(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(k):
</span></span><span style="display:flex;"><span>        res<span style="color:#f92672">.</span>append(<span style="color:#f92672">-</span>heapq<span style="color:#f92672">.</span>heappop(heap))
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> res
</span></span></code></pre></div><h1 id="hard">Hard<a hidden class="anchor" aria-hidden="true" href="#hard">#</a></h1>
<h2 id="1-maximum-password-strength">1. Maximum password strength<a hidden class="anchor" aria-hidden="true" href="#1-maximum-password-strength">#</a></h2>
<blockquote>
<p>大意是给一个字符串，对每一个子串计算不同字符的个数，最后求所有子串计算结果的总和。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">solution</span>(s: str):
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    对于重复 letter 也计算，但只算一次。
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    对于 i 字母结尾的子串，做出的贡献是到前面重复字母之间的长度。
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    res <span style="color:#f92672">=</span> count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    last <span style="color:#f92672">=</span> {}
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i, char <span style="color:#f92672">in</span> enumerate(s):
</span></span><span style="display:flex;"><span>        count <span style="color:#f92672">+=</span> i <span style="color:#f92672">-</span> last<span style="color:#f92672">.</span>get(char, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        res <span style="color:#f92672">+=</span> count
</span></span><span style="display:flex;"><span>        last[char] <span style="color:#f92672">=</span> i
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> res
</span></span></code></pre></div><p>参考 Leetcode <a href="https://leetcode.cn/problems/total-appeal-of-a-string/">字符串的总引力</a>。</p>
<p>另外还有一道题很类似，但是计算时只考虑出现一次的字符，重复的则忽略：<a href="https://leetcode.cn/problems/count-unique-characters-of-all-substrings-of-a-given-string/">计算子串中的唯一字符</a>。</p>
<h2 id="2-shipment-imbalance">2. Shipment imbalance<a hidden class="anchor" aria-hidden="true" href="#2-shipment-imbalance">#</a></h2>
<blockquote>
<p>给一个数组，对于所有的子数组计算其中最大元素与最小元素的差值，返回所有的差值的和。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">solution</span>(nums: List[int]) <span style="color:#f92672">-&gt;</span> int:
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    主要是单调栈的应用。
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    下面的代码还可以进一步简化，比如求两个最小栈可以通过一次循环得到。
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    length <span style="color:#f92672">=</span> len(nums)
</span></span><span style="display:flex;"><span>    min_left, max_left <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> length, [<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> length
</span></span><span style="display:flex;"><span>    min_stack, max_stack <span style="color:#f92672">=</span> [], []
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(length):
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># min_left 和下面的 min_right 要保证一开一闭，不然会遗漏或重复计算</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> min_stack <span style="color:#f92672">and</span> nums[min_stack[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]] <span style="color:#f92672">&gt;</span> nums[i]:
</span></span><span style="display:flex;"><span>            min_stack<span style="color:#f92672">.</span>pop()
</span></span><span style="display:flex;"><span>        min_left[i] <span style="color:#f92672">=</span> min_stack[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#66d9ef">if</span> min_stack <span style="color:#66d9ef">else</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>        min_stack<span style="color:#f92672">.</span>append(i)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># max_left 和 max_right 同理</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> max_stack <span style="color:#f92672">and</span> nums[max_stack[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]] <span style="color:#f92672">&lt;=</span> nums[i]:
</span></span><span style="display:flex;"><span>            max_stack<span style="color:#f92672">.</span>pop()
</span></span><span style="display:flex;"><span>        max_left[i] <span style="color:#f92672">=</span> max_stack[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#66d9ef">if</span> max_stack <span style="color:#66d9ef">else</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>        max_stack<span style="color:#f92672">.</span>append(i)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    min_right, max_right <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> length, [<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> length
</span></span><span style="display:flex;"><span>    min_stack, max_stack <span style="color:#f92672">=</span> [], []
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(length <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> min_stack <span style="color:#f92672">and</span> nums[min_stack[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]] <span style="color:#f92672">&gt;=</span> nums[i]:
</span></span><span style="display:flex;"><span>            min_stack<span style="color:#f92672">.</span>pop()
</span></span><span style="display:flex;"><span>        min_right[i] <span style="color:#f92672">=</span> min_stack[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#66d9ef">if</span> min_stack <span style="color:#66d9ef">else</span> length
</span></span><span style="display:flex;"><span>        min_stack<span style="color:#f92672">.</span>append(i)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> max_stack <span style="color:#f92672">and</span> nums[max_stack[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]] <span style="color:#f92672">&lt;</span> nums[i]:
</span></span><span style="display:flex;"><span>            max_stack<span style="color:#f92672">.</span>pop()
</span></span><span style="display:flex;"><span>        max_right[i] <span style="color:#f92672">=</span> max_stack[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#66d9ef">if</span> max_stack <span style="color:#66d9ef">else</span> length
</span></span><span style="display:flex;"><span>        max_stack<span style="color:#f92672">.</span>append(i)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    res <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(length):
</span></span><span style="display:flex;"><span>        res <span style="color:#f92672">+=</span> (i <span style="color:#f92672">-</span> max_left[i]) <span style="color:#f92672">*</span> (max_right[i] <span style="color:#f92672">-</span> i) <span style="color:#f92672">*</span> nums[i]
</span></span><span style="display:flex;"><span>        res <span style="color:#f92672">-=</span> (i <span style="color:#f92672">-</span> min_left[i]) <span style="color:#f92672">*</span> (min_right[i] <span style="color:#f92672">-</span> i) <span style="color:#f92672">*</span> nums[i]
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> res
</span></span></code></pre></div><p>参考 Leetcode <a href="https://leetcode.cn/problems/sum-of-subarray-ranges/">子数组范围和</a>。</p>
<h2 id="3-minimum-swaps-to-sort-an-array">3. Minimum swaps to sort an array<a hidden class="anchor" aria-hidden="true" href="#3-minimum-swaps-to-sort-an-array">#</a></h2>
<p>基于归并排序计算数组中的逆序对，参考 Leetcode <a href="https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">剑指 Offer 51</a>，官方视频讲解非常好，一定要看。</p>
<h2 id="4-package-shipping-minimum-cost">4. Package shipping minimum cost<a hidden class="anchor" aria-hidden="true" href="#4-package-shipping-minimum-cost">#</a></h2>
<p>一道 DP 题目，大致参考 Leetcode <a href="https://leetcode.cn/problems/solving-questions-with-brainpower/">解决智力问题</a>。</p>
<h2 id="5-piles-of-products">5. Piles of products<a hidden class="anchor" aria-hidden="true" href="#5-piles-of-products">#</a></h2>
<p><img loading="lazy" src="https://static.iamgodot.com/content/images/20220813112825.png" alt=""  />
</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">solution</span>(piles: List[int]):
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#39;&#39;&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    dp[i] 表示以 i 位置元素结尾的最大 products 数，则 dp[i] = 等差数列求和[j..i] + dp[j]。
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    利用单调栈寻找 j 的位置，即 last smaller element，条件为横坐标的差值。
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    等差数列求和公式：n * (a1 + an) / 2。
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#39;&#39;&#39;</span>
</span></span><span style="display:flex;"><span>    res <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    stack <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>    length <span style="color:#f92672">=</span> len(piles)
</span></span><span style="display:flex;"><span>    dp <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> length
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(length):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> stack <span style="color:#f92672">and</span> piles[stack[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]] <span style="color:#f92672">&gt;=</span> piles[i] <span style="color:#f92672">-</span> (i <span style="color:#f92672">-</span> stack[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]):
</span></span><span style="display:flex;"><span>            stack<span style="color:#f92672">.</span>pop()
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># 注意这里要对 i+1 和 piles[i] 取更小值，因为即使 products 够多，横向可能也不够长</span>
</span></span><span style="display:flex;"><span>        len <span style="color:#f92672">=</span> min(i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, piles[i]) <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> stack <span style="color:#66d9ef">else</span> i <span style="color:#f92672">-</span> stack[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>        dp[i] <span style="color:#f92672">=</span> (piles[i] <span style="color:#f92672">+</span> piles[i] <span style="color:#f92672">-</span> len <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">*</span> len <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">+</span> (<span style="color:#ae81ff">0</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> stack <span style="color:#66d9ef">else</span> dp[stack[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]])
</span></span><span style="display:flex;"><span>        res <span style="color:#f92672">=</span> max(res, dp[i])
</span></span><span style="display:flex;"><span>        stack<span style="color:#f92672">.</span>append(i)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> res
</span></span></code></pre></div><h2 id="6-power-subset-sums">6. Power subset sums<a hidden class="anchor" aria-hidden="true" href="#6-power-subset-sums">#</a></h2>
<p>第二题碰到的便是这个，算是很有难度的一道了。可惜准备不足，当场没有写出理想的解法，后来还专门写了一篇做记录：<a href="/posts/sum-of-total-strength-of-wizards.md">Sum of Total Strength of Wizards</a>（Leetcode 有原题）。真的碰到不会的话最好写个暴力解法，至少还可以过一些 Simple cases，应该不至于影响最终结果。</p>
<h2 id="7-max-deviation-of-all-strings">7. Max deviation of all strings<a hidden class="anchor" aria-hidden="true" href="#7-max-deviation-of-all-strings">#</a></h2>
<p>一道 DP 题目，参考 Leetcode <a href="https://leetcode.cn/problems/substring-with-largest-variance/">最大波动的子字符串</a>。</p>
<p>准备的时候尝试看了看，没有特别理解，于是便放弃了，好在也没碰到。</p>
<hr>
<p>希望能帮助到有需要的人，Good luck！</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://iamgodot.com/tags/dsa/">dsa</a></li>
    </ul>
<nav class="paginav">
  <a class="next" href="https://iamgodot.com/posts/sum-of-total-strength-of-wizards/">
    <span class="title">Next Page »</span>
    <br>
    <span>Sum of Total Strength of Wizards</span>
  </a>
</nav>

  </footer>
<script src="https://giscus.app/client.js"
        data-repo="iamgodot/godot-blog-comments"
        data-repo-id="MDEwOlJlcG9zaXRvcnkzOTk0Nzk0MTY="
        data-category="Announcements"
        data-category-id="DIC_kwDOF8-SeM4CO3OX"
        data-mapping="pathname"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="top"
        data-theme="dark_dimmed"
        data-lang="zh-CN"
        data-loading="lazy"
        crossorigin="anonymous"
        async>
</script>


</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2020-2022 <a href="https://iamgodot.com">Godot&#39;s Blog</a></span>
    <span>
        | <a href="http://beian.miit.gov.cn/" target="_blank">京ICP备20005558号-2</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = 'copy';

        function copyingDone() {
            copybutton.innerText = 'copied!';
            setTimeout(() => {
                copybutton.innerText = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
