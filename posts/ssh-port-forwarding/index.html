<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>关于 SSH 端口转发 | Godot's Blog</title><meta name=keywords content="SSH 端口转发,SSH 隧道,SSH 内网穿透"><meta name=description content="SSH 的端口转发很实用，但我总觉得难以理解和记忆，直到最近才有所好转。
因为又派上用场了。以前基本只做做内网穿透，现在更多地拿来绕过防火墙。自己的服务器，大多数端口虽然都是被禁用的（至少禁止入网，这也是正常的安全措施），但是想要连接的话直接本地端口转发就可以了。
TL;DR 本地端口转发在当前机器上设置，然后从本机出发，通过另一台机器，连接其他的机器。适用于防火墙的绕过、多重 SSH 登录等。
远程端口转发在当前机器上设置，然后从另外一台机器出发，通过当前机器，连接本机或者其他的机器。适用于 NAT 网络穿透、暴露内部网络服务等。
本质上都是先建立 SSH 会话，形成隧道，然后在上面进行正向或反向的数据传输。
Local Port Forwarding 为什么叫做本地呢，我想有两个原因：
转发的端口在当前（执行 SSH 命令这台）机器上 请求是从当前机器发出的 当前机器就是我的笔记本，另外一台是服务器。比如，在服务器上部署一个应用，开放给 8000 端口，但是被墙掉了，没办法在本地调试，怎么办？防火墙肯定开放了 SSH 登录的端口，比如 22，那么就让请求从本地的端口发送到服务器的 22 端口，再转发到 8000 端口，最后原路返回。我可以设置本地的端口也是 8000，这样直接用 localhost:8000 来访问应用就好了。
转发的重点在于本地的 8000 端口和服务器的 22 端口之间，因为请求到了服务器之后可以给应用的 8000，也可以给其他的机器，只要服务器能连接到：
# ssh -L local_port:dest_addr:dest_port server # Local 8000 < -- > Server 22 < -- > Server 8000 # -fNT 让 ssh 不要打开服务器 shell，并且转为后台运行 # server 隐含了使用 22 端口登录，当然也可以在 ssh config 中设置任意登录端口 ssh -fNT -L 8000:localhost:8000 server 注意这里的 dest 对应的 src 是 server，也就是说 localhost 及后面的 8000 都是 server 的 IP 和端口。可以理解为 server 是中介，整条通路是 local -> server -> dest."><meta name=author content><link rel=canonical href=https://iamgodot.com/posts/ssh-port-forwarding/><link crossorigin=anonymous href=/assets/css/stylesheet.min.7cb1aaa4414c482febc7034a427761d087a2cf358f1be8f7beba5afc947b57d0.css integrity="sha256-fLGqpEFMSC/rxwNKQndh0IeizzWPG+j3vrpa/JR7V9A=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js integrity="sha256-uVus3DnjejMqn4g7Hni+Srwf3KK8HyZB9V4809q9TWE=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://iamgodot.com/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://iamgodot.com/icons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://iamgodot.com/icons/favicon-32x32.png><link rel=apple-touch-icon href=https://iamgodot.com/icons/apple-touch-icon.png><link rel=mask-icon href=https://iamgodot.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=preload as=style href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;700&family=Source+Code+Pro:wght@400;700&display=swap"><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;700&family=Source+Code+Pro:wght@400;700&display=swap" media=print onload='this.media="all"'><link rel=preconnect href=https://plausible.iamgodot.com><script defer data-domain=iamgodot.com src=https://plausible.iamgodot.com/js/plausible.js></script>
<script>window.plausible=window.plausible||function(){(window.plausible.q=window.plausible.q||[]).push(arguments)}</script><script></script><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-157042624-1","auto"),ga("send","pageview"))</script><meta property="og:title" content="关于 SSH 端口转发"><meta property="og:description" content="SSH 的端口转发很实用，但我总觉得难以理解和记忆，直到最近才有所好转。
因为又派上用场了。以前基本只做做内网穿透，现在更多地拿来绕过防火墙。自己的服务器，大多数端口虽然都是被禁用的（至少禁止入网，这也是正常的安全措施），但是想要连接的话直接本地端口转发就可以了。
TL;DR 本地端口转发在当前机器上设置，然后从本机出发，通过另一台机器，连接其他的机器。适用于防火墙的绕过、多重 SSH 登录等。
远程端口转发在当前机器上设置，然后从另外一台机器出发，通过当前机器，连接本机或者其他的机器。适用于 NAT 网络穿透、暴露内部网络服务等。
本质上都是先建立 SSH 会话，形成隧道，然后在上面进行正向或反向的数据传输。
Local Port Forwarding 为什么叫做本地呢，我想有两个原因：
转发的端口在当前（执行 SSH 命令这台）机器上 请求是从当前机器发出的 当前机器就是我的笔记本，另外一台是服务器。比如，在服务器上部署一个应用，开放给 8000 端口，但是被墙掉了，没办法在本地调试，怎么办？防火墙肯定开放了 SSH 登录的端口，比如 22，那么就让请求从本地的端口发送到服务器的 22 端口，再转发到 8000 端口，最后原路返回。我可以设置本地的端口也是 8000，这样直接用 localhost:8000 来访问应用就好了。
转发的重点在于本地的 8000 端口和服务器的 22 端口之间，因为请求到了服务器之后可以给应用的 8000，也可以给其他的机器，只要服务器能连接到：
# ssh -L local_port:dest_addr:dest_port server # Local 8000 < -- > Server 22 < -- > Server 8000 # -fNT 让 ssh 不要打开服务器 shell，并且转为后台运行 # server 隐含了使用 22 端口登录，当然也可以在 ssh config 中设置任意登录端口 ssh -fNT -L 8000:localhost:8000 server 注意这里的 dest 对应的 src 是 server，也就是说 localhost 及后面的 8000 都是 server 的 IP 和端口。可以理解为 server 是中介，整条通路是 local -> server -> dest."><meta property="og:type" content="article"><meta property="og:url" content="https://iamgodot.com/posts/ssh-port-forwarding/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-12-22T11:36:49+08:00"><meta property="article:modified_time" content="2021-12-22T11:36:49+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="关于 SSH 端口转发"><meta name=twitter:description content="SSH 的端口转发很实用，但我总觉得难以理解和记忆，直到最近才有所好转。
因为又派上用场了。以前基本只做做内网穿透，现在更多地拿来绕过防火墙。自己的服务器，大多数端口虽然都是被禁用的（至少禁止入网，这也是正常的安全措施），但是想要连接的话直接本地端口转发就可以了。
TL;DR 本地端口转发在当前机器上设置，然后从本机出发，通过另一台机器，连接其他的机器。适用于防火墙的绕过、多重 SSH 登录等。
远程端口转发在当前机器上设置，然后从另外一台机器出发，通过当前机器，连接本机或者其他的机器。适用于 NAT 网络穿透、暴露内部网络服务等。
本质上都是先建立 SSH 会话，形成隧道，然后在上面进行正向或反向的数据传输。
Local Port Forwarding 为什么叫做本地呢，我想有两个原因：
转发的端口在当前（执行 SSH 命令这台）机器上 请求是从当前机器发出的 当前机器就是我的笔记本，另外一台是服务器。比如，在服务器上部署一个应用，开放给 8000 端口，但是被墙掉了，没办法在本地调试，怎么办？防火墙肯定开放了 SSH 登录的端口，比如 22，那么就让请求从本地的端口发送到服务器的 22 端口，再转发到 8000 端口，最后原路返回。我可以设置本地的端口也是 8000，这样直接用 localhost:8000 来访问应用就好了。
转发的重点在于本地的 8000 端口和服务器的 22 端口之间，因为请求到了服务器之后可以给应用的 8000，也可以给其他的机器，只要服务器能连接到：
# ssh -L local_port:dest_addr:dest_port server # Local 8000 < -- > Server 22 < -- > Server 8000 # -fNT 让 ssh 不要打开服务器 shell，并且转为后台运行 # server 隐含了使用 22 端口登录，当然也可以在 ssh config 中设置任意登录端口 ssh -fNT -L 8000:localhost:8000 server 注意这里的 dest 对应的 src 是 server，也就是说 localhost 及后面的 8000 都是 server 的 IP 和端口。可以理解为 server 是中介，整条通路是 local -> server -> dest."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://iamgodot.com/posts/"},{"@type":"ListItem","position":3,"name":"关于 SSH 端口转发","item":"https://iamgodot.com/posts/ssh-port-forwarding/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"关于 SSH 端口转发","name":"关于 SSH 端口转发","description":"SSH 的端口转发很实用，但我总觉得难以理解和记忆，直到最近才有所好转。\n因为又派上用场了。以前基本只做做内网穿透，现在更多地拿来绕过防火墙。自己的服务器，大多数端口虽然都是被禁用的（至少禁止入网，这也是正常的安全措施），但是想要连接的话直接本地端口转发就可以了。\nTL;DR 本地端口转发在当前机器上设置，然后从本机出发，通过另一台机器，连接其他的机器。适用于防火墙的绕过、多重 SSH 登录等。\n远程端口转发在当前机器上设置，然后从另外一台机器出发，通过当前机器，连接本机或者其他的机器。适用于 NAT 网络穿透、暴露内部网络服务等。\n本质上都是先建立 SSH 会话，形成隧道，然后在上面进行正向或反向的数据传输。\nLocal Port Forwarding 为什么叫做本地呢，我想有两个原因：\n转发的端口在当前（执行 SSH 命令这台）机器上 请求是从当前机器发出的 当前机器就是我的笔记本，另外一台是服务器。比如，在服务器上部署一个应用，开放给 8000 端口，但是被墙掉了，没办法在本地调试，怎么办？防火墙肯定开放了 SSH 登录的端口，比如 22，那么就让请求从本地的端口发送到服务器的 22 端口，再转发到 8000 端口，最后原路返回。我可以设置本地的端口也是 8000，这样直接用 localhost:8000 来访问应用就好了。\n转发的重点在于本地的 8000 端口和服务器的 22 端口之间，因为请求到了服务器之后可以给应用的 8000，也可以给其他的机器，只要服务器能连接到：\n# ssh -L local_port:dest_addr:dest_port server # Local 8000 \u0026lt; -- \u0026gt; Server 22 \u0026lt; -- \u0026gt; Server 8000 # -fNT 让 ssh 不要打开服务器 shell，并且转为后台运行 # server 隐含了使用 22 端口登录，当然也可以在 ssh config 中设置任意登录端口 ssh -fNT -L 8000:localhost:8000 server 注意这里的 dest 对应的 src 是 server，也就是说 localhost 及后面的 8000 都是 server 的 IP 和端口。可以理解为 server 是中介，整条通路是 local -\u0026gt; server -\u0026gt; dest.","keywords":["SSH 端口转发","SSH 隧道","SSH 内网穿透"],"articleBody":"SSH 的端口转发很实用，但我总觉得难以理解和记忆，直到最近才有所好转。\n因为又派上用场了。以前基本只做做内网穿透，现在更多地拿来绕过防火墙。自己的服务器，大多数端口虽然都是被禁用的（至少禁止入网，这也是正常的安全措施），但是想要连接的话直接本地端口转发就可以了。\nTL;DR 本地端口转发在当前机器上设置，然后从本机出发，通过另一台机器，连接其他的机器。适用于防火墙的绕过、多重 SSH 登录等。\n远程端口转发在当前机器上设置，然后从另外一台机器出发，通过当前机器，连接本机或者其他的机器。适用于 NAT 网络穿透、暴露内部网络服务等。\n本质上都是先建立 SSH 会话，形成隧道，然后在上面进行正向或反向的数据传输。\nLocal Port Forwarding 为什么叫做本地呢，我想有两个原因：\n转发的端口在当前（执行 SSH 命令这台）机器上 请求是从当前机器发出的 当前机器就是我的笔记本，另外一台是服务器。比如，在服务器上部署一个应用，开放给 8000 端口，但是被墙掉了，没办法在本地调试，怎么办？防火墙肯定开放了 SSH 登录的端口，比如 22，那么就让请求从本地的端口发送到服务器的 22 端口，再转发到 8000 端口，最后原路返回。我可以设置本地的端口也是 8000，这样直接用 localhost:8000 来访问应用就好了。\n转发的重点在于本地的 8000 端口和服务器的 22 端口之间，因为请求到了服务器之后可以给应用的 8000，也可以给其他的机器，只要服务器能连接到：\n# ssh -L local_port:dest_addr:dest_port server # Local 8000 \u003c -- \u003e Server 22 \u003c -- \u003e Server 8000 # -fNT 让 ssh 不要打开服务器 shell，并且转为后台运行 # server 隐含了使用 22 端口登录，当然也可以在 ssh config 中设置任意登录端口 ssh -fNT -L 8000:localhost:8000 server 注意这里的 dest 对应的 src 是 server，也就是说 localhost 及后面的 8000 都是 server 的 IP 和端口。可以理解为 server 是中介，整条通路是 local -\u003e server -\u003e dest.\n除了调试应用，还可以做各种各样的事情，比如浏览文件（在服务器上开个 python -m http.server 8080），用 netcat 测试连接，甚至实现流媒体播放。最重要的是，这解放了封闭在防火墙背后的一系列端口。\n不光如此，如果服务器还连接到其他的机器，就可以将三台机器联系到一起。跳板机跨越是一个常见的例子，即本地先 SSH 登录到跳板机，再登录到服务器。利用端口转发的话只需要将 dest 设置为跳板机的地址和端口（当然，直接使用 SSH 的 ProxyJump 更加直截了当，这里有些大材小用了）。\n本地端口转发很好，但不是万能的。如果服务器没有公网 IP，或者隐藏在 NAT 背后呢？这时候就需要远程端口转发。\nRemote Port Forwarding 先解释一下我对远程两个字的理解：\n转发的端口在另外一台机器上 请求是从另外一台机器发出的 接着刚才的例子，如果服务器躲在 NAT 后面不出来，但是我的笔记本可以通过 SSH 连接，那就可以在服务器上设置远程端口转发：\n# ssh -qngfNT -R [bind_addr]:remote_port:dest_addr:dest_port host ssh -qngfNT -R 8000:localhost:8000 host 这里的 host 指的就是我的笔记本，所以服务器要可以 SSH 到我的笔记本才行？是的，这些转发的可能性都在于，必须能建立起双方之间的 SSH 会话，这也是为什么端口转发又被称为 SSH 隧道，有了通路，才可以换方向。\n和本地转发不同的是，dest 的 src 是 local，也就是当前机器（服务器），通路是 local -\u003e host -\u003e dest.\n其实远程端口转发最常见的用法是实现内网穿透，也是解决 NAT 的问题。比如公司的电脑在 NAT 后，通过公网服务器，我可以从家里登录到公司。\n在这个场景中，首先要保证几个前提：公司电脑和服务器都要开启了 SSH 的服务，即都能够登录上去；其次，如果想要用家里的电脑，即第三台机器，实现公司登录的话，要设置服务器 SSH 服务的 GatewayPorts 选项为 yes. 如果这些都满足，那么直接在公司电脑执行：\n# -qngfNT 一堆不是很重要但最好加上的选项 ssh -qngfNT -R 8000:localhost:22 server 8000 就是（公司电脑远程转发给）服务器的端口，在家里用这个端口登录服务器即可开始办公：\nssh user-company@ip-server -p 8000 注意上面示例中的 bind_addr，如果想只让某个固定 IP 才能登录，那么在这里加上就可以了。当然这要求家里的电脑有公网地址，而且服务器上的 GatewayPorts 设置为 clientspecified.\nOK，现在我们可以进入公司网络了，但如果公司电脑（或者办公网络）中有个需要调试的应用怎么办？那就再加一个本地端口转发：\nssh -fNT -L 8000:localhost:8000 server 现在就能用 localhost:8000 访问公司的应用了，那么如果有多个应用呢？不管是 -L 还是 -R 都支持多个参数，所以分别用不同的端口指定即可。\nReferences\nSSH port forwarding\n远程操作与端口转发 - 阮一峰\n一个很好的内网穿透的例子\n","wordCount":"215","inLanguage":"en","datePublished":"2021-12-22T11:36:49+08:00","dateModified":"2021-12-22T11:36:49+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://iamgodot.com/posts/ssh-port-forwarding/"},"publisher":{"@type":"Organization","name":"Godot's Blog","logo":{"@type":"ImageObject","url":"https://iamgodot.com/icons/favicon.ico"}}}</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=https://iamgodot.com accesskey=h title="Godot's Blog (Alt + H)">Godot's Blog</a>
<span class=logo-switches></span></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>关于 SSH 端口转发</h1><div class=post-meta><span title='2021-12-22 11:36:49 +0800 +0800'>12-22</span>&nbsp;·&nbsp;2 min</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#tldr aria-label=TL;DR>TL;DR</a></li><li><a href=#local-port-forwarding aria-label="Local Port Forwarding">Local Port Forwarding</a></li><li><a href=#remote-port-forwarding aria-label="Remote Port Forwarding">Remote Port Forwarding</a></li></ul></div></details></div><div class=post-content><p>SSH 的端口转发很实用，但我总觉得难以理解和记忆，直到最近才有所好转。</p><p>因为又派上用场了。以前基本只做做内网穿透，现在更多地拿来绕过防火墙。自己的服务器，大多数端口虽然都是被禁用的（至少禁止入网，这也是正常的安全措施），但是想要连接的话直接本地端口转发就可以了。</p><h1 id=tldr>TL;DR<a hidden class=anchor aria-hidden=true href=#tldr>#</a></h1><p>本地端口转发在当前机器上设置，然后从本机出发，通过另一台机器，连接其他的机器。适用于防火墙的绕过、多重 SSH 登录等。</p><p>远程端口转发在当前机器上设置，然后从另外一台机器出发，通过当前机器，连接本机或者其他的机器。适用于 NAT 网络穿透、暴露内部网络服务等。</p><p>本质上都是先建立 SSH 会话，形成隧道，然后在上面进行正向或反向的数据传输。</p><h1 id=local-port-forwarding>Local Port Forwarding<a hidden class=anchor aria-hidden=true href=#local-port-forwarding>#</a></h1><p>为什么叫做本地呢，我想有两个原因：</p><ul><li>转发的端口在当前（执行 SSH 命令这台）机器上</li><li>请求是从当前机器发出的</li></ul><p>当前机器就是我的笔记本，另外一台是服务器。比如，在服务器上部署一个应用，开放给 8000 端口，但是被墙掉了，没办法在本地调试，怎么办？防火墙肯定开放了 SSH 登录的端口，比如 22，那么就让请求从本地的端口发送到服务器的 22 端口，再转发到 8000 端口，最后原路返回。我可以设置本地的端口也是 8000，这样直接用 localhost:8000 来访问应用就好了。</p><p>转发的重点在于本地的 8000 端口和服务器的 22 端口之间，因为请求到了服务器之后可以给应用的 8000，也可以给其他的机器，只要服务器能连接到：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># ssh -L local_port:dest_addr:dest_port server</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Local 8000 &lt; -- &gt; Server 22 &lt; -- &gt; Server 8000</span>
</span></span><span style=display:flex><span><span style=color:#75715e># -fNT 让 ssh 不要打开服务器 shell，并且转为后台运行</span>
</span></span><span style=display:flex><span><span style=color:#75715e># server 隐含了使用 22 端口登录，当然也可以在 ssh config 中设置任意登录端口</span>
</span></span><span style=display:flex><span>ssh -fNT -L 8000:localhost:8000 server
</span></span></code></pre></div><p>注意这里的 dest 对应的 src 是 server，也就是说 localhost 及后面的 8000 都是 server 的 IP 和端口。可以理解为 server 是中介，整条通路是 local -> server -> dest.</p><p>除了调试应用，还可以做各种各样的事情，比如浏览文件（在服务器上开个 <code>python -m http.server 8080</code>），用 netcat 测试连接，甚至实现流媒体播放。最重要的是，这解放了封闭在防火墙背后的一系列端口。</p><p>不光如此，如果服务器还连接到其他的机器，就可以将三台机器联系到一起。跳板机跨越是一个常见的例子，即本地先 SSH 登录到跳板机，再登录到服务器。利用端口转发的话只需要将 dest 设置为跳板机的地址和端口（当然，直接使用 SSH 的 ProxyJump 更加直截了当，这里有些大材小用了）。</p><p>本地端口转发很好，但不是万能的。如果服务器没有公网 IP，或者隐藏在 NAT 背后呢？这时候就需要远程端口转发。</p><h1 id=remote-port-forwarding>Remote Port Forwarding<a hidden class=anchor aria-hidden=true href=#remote-port-forwarding>#</a></h1><p>先解释一下我对远程两个字的理解：</p><ul><li>转发的端口在另外一台机器上</li><li>请求是从另外一台机器发出的</li></ul><p>接着刚才的例子，如果服务器躲在 NAT 后面不出来，但是我的笔记本可以通过 SSH 连接，那就可以在服务器上设置远程端口转发：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># ssh -qngfNT -R [bind_addr]:remote_port:dest_addr:dest_port host</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>ssh -qngfNT -R 8000:localhost:8000 host
</span></span></code></pre></div><p>这里的 host 指的就是我的笔记本，所以服务器要可以 SSH 到我的笔记本才行？是的，这些转发的可能性都在于，必须能建立起双方之间的 SSH 会话，这也是为什么端口转发又被称为 SSH 隧道，有了通路，才可以换方向。</p><p>和本地转发不同的是，dest 的 src 是 local，也就是当前机器（服务器），通路是 local -> host -> dest.</p><p>其实远程端口转发最常见的用法是实现内网穿透，也是解决 NAT 的问题。比如公司的电脑在 NAT 后，通过公网服务器，我可以从家里登录到公司。</p><p>在这个场景中，首先要保证几个前提：公司电脑和服务器都要开启了 SSH 的服务，即都能够登录上去；其次，如果想要用家里的电脑，即第三台机器，实现公司登录的话，要设置服务器 SSH 服务的 GatewayPorts 选项为 yes. 如果这些都满足，那么直接在公司电脑执行：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># -qngfNT 一堆不是很重要但最好加上的选项</span>
</span></span><span style=display:flex><span>ssh -qngfNT -R 8000:localhost:22 server
</span></span></code></pre></div><p>8000 就是（公司电脑远程转发给）服务器的端口，在家里用这个端口登录服务器即可开始办公：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ssh user-company@ip-server -p <span style=color:#ae81ff>8000</span>
</span></span></code></pre></div><p>注意上面示例中的 <code>bind_addr</code>，如果想只让某个固定 IP 才能登录，那么在这里加上就可以了。当然这要求家里的电脑有公网地址，而且服务器上的 GatewayPorts 设置为 clientspecified.</p><p>OK，现在我们可以进入公司网络了，但如果公司电脑（或者办公网络）中有个需要调试的应用怎么办？那就再加一个本地端口转发：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ssh -fNT -L 8000:localhost:8000 server
</span></span></code></pre></div><p>现在就能用 localhost:8000 访问公司的应用了，那么如果有多个应用呢？不管是 -L 还是 -R 都支持多个参数，所以分别用不同的端口指定即可。</p><hr><p><em>References</em></p><ul><li><p><a href=https://www.ssh.com/academy/ssh/tunneling/example>SSH port forwarding</a></p></li><li><p><a href=http://www.ruanyifeng.com/blog/2011/12/ssh_port_forwarding.html>远程操作与端口转发 - 阮一峰</a></p></li><li><p><a href=http://arondight.me/2016/02/17/%E4%BD%BF%E7%94%A8SSH%E5%8F%8D%E5%90%91%E9%9A%A7%E9%81%93%E8%BF%9B%E8%A1%8C%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/>一个很好的内网穿透的例子</a></p></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://iamgodot.com/tags/network/>network</a></li></ul><nav class=paginav><a class=prev href=https://iamgodot.com/posts/all-men-are-brothers/><span class=title>« Prev Page</span><br><span>水浒传之英雄本色</span></a>
<a class=next href=https://iamgodot.com/posts/from-bittorrent-to-firewall/><span class=title>Next Page »</span><br><span>From BitTorrent to Firewall</span></a></nav></footer><script src=https://giscus.app/client.js data-repo=iamgodot/godot-blog-comments data-repo-id="MDEwOlJlcG9zaXRvcnkzOTk0Nzk0MTY=" data-category=Announcements data-category-id=DIC_kwDOF8-SeM4CO3OX data-mapping=pathname data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=dark_dimmed data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2020-2022 <a href=https://iamgodot.com>Godot's Blog</a></span>
<span>| <a href=http://beian.miit.gov.cn/ target=_blank>京ICP备20005558号-2</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>