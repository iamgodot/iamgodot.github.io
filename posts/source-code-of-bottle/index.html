<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Bottle 框架源码阅读 | Godot's Blog</title><meta name=keywords content="Bottle 源码阅读,Python bottle 框架,Python bottle framework"><meta name=description content="写这篇文章最开心的一点是终于可以用这张截图了：
相比名声在外的 Django/Flask/FastAPI，Bottle 可以说是非常不起眼了，甚至很多人并不知道它的存在。其实在很多方面，这个框架都极其优秀：
速度：截止到 2022-04-13，Bottle 在一众 Python Web 框架的测评中名列第二，要知道这可是十年以上的老前辈了。 易用性：Bottle 早在 Flask 之前就使用了装饰器来定义路由，此外还有全局可用的 Request/Response 对象。 文档：不仅将框架本身的使用讲得很清楚，还总结了很多 Web 场景下的解决方案。 代码质量：虽然为了 Python 2 做了不少兼容，但是代码很精炼，而且 Pythonic。 其他：Bottle 坚持单模块以及无第三方库依赖；仓库仍然在积极维护中。 换作几年前，我会一开始就使用并将 Bottle 研究透彻，而不是让自己淹没在 Django 浩瀚如烟的文档中。下面开始梳理 Bottle 源码的阅读理解。因为代码量不大，所以就直接看最新的版本了：0.11.1 - 5a6c620。
Web 框架的基本元素 参考 The Hitchhiker&rsquo;s Guide to Python 的说法，一个 Web 框架要满足的基本功能：
URL Routing Request and Response Objects Template Engine Development Web Server 从后端的角度来讲更重要的是 1、2、4 三项，其中 1 负责转发请求到对应的视图函数，2 是对 HTTP 协议元素的解析处理，而 4 决定了服务的部署方式和基础性能。
Bottle 在这几方面都做了很好的实现：路由上提供了通配符匹配和装饰器接口；请求和响应对象作为全局对象存在并保证了线程安全；Server 部署除了 Python 自带的 wsgiref 还支持绝大多数的 WSGI Server。"><meta name=author content><link rel=canonical href=https://iamgodot.com/posts/source-code-of-bottle/><link crossorigin=anonymous href=/assets/css/stylesheet.min.7cb1aaa4414c482febc7034a427761d087a2cf358f1be8f7beba5afc947b57d0.css integrity="sha256-fLGqpEFMSC/rxwNKQndh0IeizzWPG+j3vrpa/JR7V9A=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.e85ad0406048e8176e1c7661b25d5c69297ddfe41dc4124cf75ecb99a4f7b3d1.js integrity="sha256-6FrQQGBI6BduHHZhsl1caSl93+QdxBJM917LmaT3s9E=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://iamgodot.com/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://iamgodot.com/icons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://iamgodot.com/icons/favicon-32x32.png><link rel=apple-touch-icon href=https://iamgodot.com/icons/apple-touch-icon.png><link rel=mask-icon href=https://iamgodot.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=preload as=style href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;700&family=Source+Code+Pro:wght@400;700&display=swap"><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;700&family=Source+Code+Pro:wght@400;700&display=swap" media=print onload='this.media="all"'><link rel=preconnect href=https://plausible.iamgodot.com><script defer data-domain=iamgodot.com src=https://plausible.iamgodot.com/js/plausible.js></script>
<script>window.plausible=window.plausible||function(){(window.plausible.q=window.plausible.q||[]).push(arguments)}</script><script></script><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-157042624-1","auto"),ga("send","pageview"))</script><meta property="og:title" content="Bottle 框架源码阅读"><meta property="og:description" content="写这篇文章最开心的一点是终于可以用这张截图了：
相比名声在外的 Django/Flask/FastAPI，Bottle 可以说是非常不起眼了，甚至很多人并不知道它的存在。其实在很多方面，这个框架都极其优秀：
速度：截止到 2022-04-13，Bottle 在一众 Python Web 框架的测评中名列第二，要知道这可是十年以上的老前辈了。 易用性：Bottle 早在 Flask 之前就使用了装饰器来定义路由，此外还有全局可用的 Request/Response 对象。 文档：不仅将框架本身的使用讲得很清楚，还总结了很多 Web 场景下的解决方案。 代码质量：虽然为了 Python 2 做了不少兼容，但是代码很精炼，而且 Pythonic。 其他：Bottle 坚持单模块以及无第三方库依赖；仓库仍然在积极维护中。 换作几年前，我会一开始就使用并将 Bottle 研究透彻，而不是让自己淹没在 Django 浩瀚如烟的文档中。下面开始梳理 Bottle 源码的阅读理解。因为代码量不大，所以就直接看最新的版本了：0.11.1 - 5a6c620。
Web 框架的基本元素 参考 The Hitchhiker&rsquo;s Guide to Python 的说法，一个 Web 框架要满足的基本功能：
URL Routing Request and Response Objects Template Engine Development Web Server 从后端的角度来讲更重要的是 1、2、4 三项，其中 1 负责转发请求到对应的视图函数，2 是对 HTTP 协议元素的解析处理，而 4 决定了服务的部署方式和基础性能。
Bottle 在这几方面都做了很好的实现：路由上提供了通配符匹配和装饰器接口；请求和响应对象作为全局对象存在并保证了线程安全；Server 部署除了 Python 自带的 wsgiref 还支持绝大多数的 WSGI Server。"><meta property="og:type" content="article"><meta property="og:url" content="https://iamgodot.com/posts/source-code-of-bottle/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-04-22T21:53:29+08:00"><meta property="article:modified_time" content="2022-04-22T21:53:29+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Bottle 框架源码阅读"><meta name=twitter:description content="写这篇文章最开心的一点是终于可以用这张截图了：
相比名声在外的 Django/Flask/FastAPI，Bottle 可以说是非常不起眼了，甚至很多人并不知道它的存在。其实在很多方面，这个框架都极其优秀：
速度：截止到 2022-04-13，Bottle 在一众 Python Web 框架的测评中名列第二，要知道这可是十年以上的老前辈了。 易用性：Bottle 早在 Flask 之前就使用了装饰器来定义路由，此外还有全局可用的 Request/Response 对象。 文档：不仅将框架本身的使用讲得很清楚，还总结了很多 Web 场景下的解决方案。 代码质量：虽然为了 Python 2 做了不少兼容，但是代码很精炼，而且 Pythonic。 其他：Bottle 坚持单模块以及无第三方库依赖；仓库仍然在积极维护中。 换作几年前，我会一开始就使用并将 Bottle 研究透彻，而不是让自己淹没在 Django 浩瀚如烟的文档中。下面开始梳理 Bottle 源码的阅读理解。因为代码量不大，所以就直接看最新的版本了：0.11.1 - 5a6c620。
Web 框架的基本元素 参考 The Hitchhiker&rsquo;s Guide to Python 的说法，一个 Web 框架要满足的基本功能：
URL Routing Request and Response Objects Template Engine Development Web Server 从后端的角度来讲更重要的是 1、2、4 三项，其中 1 负责转发请求到对应的视图函数，2 是对 HTTP 协议元素的解析处理，而 4 决定了服务的部署方式和基础性能。
Bottle 在这几方面都做了很好的实现：路由上提供了通配符匹配和装饰器接口；请求和响应对象作为全局对象存在并保证了线程安全；Server 部署除了 Python 自带的 wsgiref 还支持绝大多数的 WSGI Server。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://iamgodot.com/posts/"},{"@type":"ListItem","position":3,"name":"Bottle 框架源码阅读","item":"https://iamgodot.com/posts/source-code-of-bottle/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Bottle 框架源码阅读","name":"Bottle 框架源码阅读","description":"写这篇文章最开心的一点是终于可以用这张截图了：\n相比名声在外的 Django/Flask/FastAPI，Bottle 可以说是非常不起眼了，甚至很多人并不知道它的存在。其实在很多方面，这个框架都极其优秀：\n速度：截止到 2022-04-13，Bottle 在一众 Python Web 框架的测评中名列第二，要知道这可是十年以上的老前辈了。 易用性：Bottle 早在 Flask 之前就使用了装饰器来定义路由，此外还有全局可用的 Request/Response 对象。 文档：不仅将框架本身的使用讲得很清楚，还总结了很多 Web 场景下的解决方案。 代码质量：虽然为了 Python 2 做了不少兼容，但是代码很精炼，而且 Pythonic。 其他：Bottle 坚持单模块以及无第三方库依赖；仓库仍然在积极维护中。 换作几年前，我会一开始就使用并将 Bottle 研究透彻，而不是让自己淹没在 Django 浩瀚如烟的文档中。下面开始梳理 Bottle 源码的阅读理解。因为代码量不大，所以就直接看最新的版本了：0.11.1 - 5a6c620。\nWeb 框架的基本元素 参考 The Hitchhiker\u0026rsquo;s Guide to Python 的说法，一个 Web 框架要满足的基本功能：\nURL Routing Request and Response Objects Template Engine Development Web Server 从后端的角度来讲更重要的是 1、2、4 三项，其中 1 负责转发请求到对应的视图函数，2 是对 HTTP 协议元素的解析处理，而 4 决定了服务的部署方式和基础性能。\nBottle 在这几方面都做了很好的实现：路由上提供了通配符匹配和装饰器接口；请求和响应对象作为全局对象存在并保证了线程安全；Server 部署除了 Python 自带的 wsgiref 还支持绝大多数的 WSGI Server。","keywords":["Bottle 源码阅读","Python bottle 框架","Python bottle framework"],"articleBody":"写这篇文章最开心的一点是终于可以用这张截图了：\n相比名声在外的 Django/Flask/FastAPI，Bottle 可以说是非常不起眼了，甚至很多人并不知道它的存在。其实在很多方面，这个框架都极其优秀：\n速度：截止到 2022-04-13，Bottle 在一众 Python Web 框架的测评中名列第二，要知道这可是十年以上的老前辈了。 易用性：Bottle 早在 Flask 之前就使用了装饰器来定义路由，此外还有全局可用的 Request/Response 对象。 文档：不仅将框架本身的使用讲得很清楚，还总结了很多 Web 场景下的解决方案。 代码质量：虽然为了 Python 2 做了不少兼容，但是代码很精炼，而且 Pythonic。 其他：Bottle 坚持单模块以及无第三方库依赖；仓库仍然在积极维护中。 换作几年前，我会一开始就使用并将 Bottle 研究透彻，而不是让自己淹没在 Django 浩瀚如烟的文档中。下面开始梳理 Bottle 源码的阅读理解。因为代码量不大，所以就直接看最新的版本了：0.11.1 - 5a6c620。\nWeb 框架的基本元素 参考 The Hitchhiker’s Guide to Python 的说法，一个 Web 框架要满足的基本功能：\nURL Routing Request and Response Objects Template Engine Development Web Server 从后端的角度来讲更重要的是 1、2、4 三项，其中 1 负责转发请求到对应的视图函数，2 是对 HTTP 协议元素的解析处理，而 4 决定了服务的部署方式和基础性能。\nBottle 在这几方面都做了很好的实现：路由上提供了通配符匹配和装饰器接口；请求和响应对象作为全局对象存在并保证了线程安全；Server 部署除了 Python 自带的 wsgiref 还支持绝大多数的 WSGI Server。\n之外 Bottle 服务还会自动检测代码变更并重启，扩展方面有 Hook 和 Plugin 机制等等。\n一切从 WSGI 开始 WSGI 定义了 Python Web 框架的统一接口规范，因此也是了解 Bottle 最好的突破口。一个 Web 服务可以简单看成 Server 和 Handler 两部分，前者负责监听端口并建立连接，而后者处理请求然后返回响应内容。Handler 在 WSGI 中称为 app，是一个可调用对象，比如：\ndef application(environ, start_response): response_body = [ '%s: %s' % (key, value) for key, value in sorted(environ.items()) ] response_body = '\\n'.join(response_body) status = '200 OK' response_headers = [ ('Content-Type', 'text/plain'), ('Content-Length', str(len(response_body))) ] start_response(status, response_headers) return [response_body.encode()] 在 Bottle 中 app 被包装成了一个 Bottle 对象，实际的调用过程在它的 wsgi 方法里：\nclass Bottle(object): ... def wsgi(self, environ, start_response): try: # 获取响应内容并做适当转化 out = self._cast(self._handle(environ)) ... exc_info = environ.get(\"bottle.exc_info\") if exc_info is not None: del environ[\"bottle.exc_info\"] start_response(response._wsgi_status_line(), response.headerlist, exc_info) return out except (KeyboardInterrupt, SystemExit, MemoryError): ... def _handle(self, environ): ... try: while True: out = None try: self.trigger_hook(\"before_request\") # 通过路由找到视图函数 route, args = self.router.match(environ) environ[\"route.handle\"] = route environ[\"bottle.route\"] = route environ[\"route.url_args\"] = args # 调用视图函数获取结果 out = route.call(**args) break except HTTPResponse as E: .... 可以看到，_handle 方法负责路由到对应的视图函数并调用获取响应，而 _cast 会对响应内容进行 WSGI 兼容的处理。\n接下来根据 self.router.match(environ) 来看路由部分的具体实现。\n路由 Router 是抽象出来的负责路由转发的对象，实质上是一系列 Routes 的集合，而每个 Route 代表方法和路径到视图函数的对应关系。因此，当一个 HTTP 请求到来，Router 就可以从 Routes 中找到匹配的视图函数。思路很简单，关键是如何实现高效的查找过程。下面看 Router 的代码：\nclass Router(object): ... def match(self, environ): ... for method in methods: if method in self.static and path in self.static[method]: target, getargs = self.static[method][path] return target, getargs(path) if getargs else {} elif method in self.dyna_regexes: for combined, rules in self.dyna_regexes[method]: match = combined(path) if match: target, getargs = rules[match.lastindex - 1] return target, getargs(path) if getargs else {} ... 核心逻辑有两部分：首先是静态匹配，在 self.static 中保存了从方法到路径再到视图函数（target）的映射，这里会直接用哈希表实现快速查找；其次是通配符匹配，self.dyna_regexes 里每个方法都包含多个 (combined, rules) 元组，而 combined 由多个正则表达式组合到一起（每个正则代表一个动态路径），对应到 rules 中的多个视图函数。之所以会有多个元组，是因为 CPython 中正则的分组匹配最多只支持 99 个，所以一个 combined 的容量是有限的，如果动态路由过多，就需要增加新的元组。\n这里体现了 Bottle 路由查找的基本原则：\n静态路由匹配的优先级高于动态路由。 动态路由匹配有先后顺序，注意不要造成短路。 还有添加路由的时候 一个视图函数可以定义多个路径。 重复定义会覆盖原有路由，当然这也是允许的。 请求 \u0026 响应 接下来是对 HTTP 请求和响应的抽象，Bottle 定义了全局的 Request \u0026 Response 对象。看起来和 Flask 很像，其实要比后者更早。\n关键在于保证线程安全，这部分已经在 Python 中的 TLS 是如何实现的 中说得很详细了，下面看看 Bottle 是怎么实现的：\ndef _local_property(): ls = threading.local() def fget(_): try: return ls.var except AttributeError: raise RuntimeError(\"Request context not initialized.\") def fset(_, value): ls.var = value def fdel(_): del ls.var return property(fget, fset, fdel, \"Thread-local property\") class LocalRequest(BaseRequest): bind = BaseRequest.__init__ environ = _local_property() class LocalResponse(BaseResponse): bind = BaseResponse.__init__ _status_line = _local_property() _status_code = _local_property() _cookies = _local_property() _headers = _local_property() body = _local_property() ... request = LocalRequest() response = LocalResponse() 基于 threading.local，Bottle 使用修饰符来定义 LocalRequest 和 LocalResponse 中的 HTTP 属性，这样的实现很灵活，也可以轻松地应用到其他的对象。\n需要注意的是，在 greenlet 和 coroutine 大行其道的今天，threading.local 已经完全不够用了。Bottle 与 ASGI 水土不服，但是一定要部署成 Async 服务的话，也是有方法的：比如保证 threading.local 提前被 monkeypatch（针对 gevent），或者在代码中使用 request.copy() 拷贝出新的请求对象。作者在文档和 Issue 中都做了详细的解释。\n服务 Bottle 默认使用了 wsgiref 模块中的 WSGI Server 来启动服务，这种服务是单线程的，所以也只适用于本地开发。\n此外 Bottle 支持许多 Web Server 部署，在官网有详细列举：\n为了兼容这么多的 Server，Bottle 在内部实现了各种各样的适配器，比如 wsgiref：\nclass ServerAdapter(object): quiet = False def __init__(self, host=\"127.0.0.1\", port=8080, **options): self.options = options self.host = host self.port = int(port) def run(self, handler): pass def __repr__(self): args = \", \".join(\"%s=%s\" % (k, repr(v)) for k, v in self.options.items()) return \"%s(%s)\" % (self.__class__.__name__, args) class WSGIRefServer(ServerAdapter): def run(self, app): import socket from wsgiref.simple_server import (WSGIRequestHandler, WSGIServer, make_server) ... handler_cls = self.options.get(\"handler_class\", FixedHandler) server_cls = self.options.get(\"server_class\", WSGIServer) ... self.srv = make_server(self.host, self.port, app, server_cls, handler_cls) self.port = self.srv.server_port try: self.srv.serve_forever() except KeyboardInterrupt: self.srv.server_close() raise 通过适配器模式，可以很方便地修改原有适配或者添加新的 Server 支持。这里不详述了。\n模板系统 Bottle 实现了自己的模板生成功能，同时也支持主流的 Mako 和 Jinja2。无论使用哪一种，都可以直接调用 template 这个简单的接口：\ndef template(*args, **kwargs): tpl = args[0] if args else None for dictarg in args[1:]: kwargs.update(dictarg) adapter = kwargs.pop(\"template_adapter\", SimpleTemplate) lookup = kwargs.pop(\"template_lookup\", TEMPLATE_PATH) tplid = (id(lookup), tpl) if tplid not in TEMPLATES or DEBUG: settings = kwargs.pop(\"template_settings\", {}) if isinstance(tpl, adapter): TEMPLATES[tplid] = tpl if settings: TEMPLATES[tplid].prepare(**settings) elif \"\\n\" in tpl or \"{\" in tpl or \"%\" in tpl or \"$\" in tpl: TEMPLATES[tplid] = adapter(source=tpl, lookup=lookup, **settings) else: TEMPLATES[tplid] = adapter(name=tpl, lookup=lookup, **settings) if not TEMPLATES[tplid]: abort(500, \"Template (%s) not found\" % tpl) return TEMPLATES[tplid].render(kwargs) 通过指定 template_adapter 使用不同的模板系统，这是很典型的策略模式。另外，这里也同样出现了适配器模式，基于 BaseTemplate 来适配各个模板库：\nclass MakoTemplate(BaseTemplate): ... class Jinja2Template(BaseTemplate): ... class SimpleTemplate(BaseTemplate): ... 自动重启 Bottle 还提供了检测 Python 文件改动并自动重启服务的功能，实现思路也很巧妙：\ndef run( app=None, server=\"wsgiref\", host=\"127.0.0.1\", port=8080, interval=1, reloader=False, quiet=False, plugins=None, debug=None, config=None, **kargs ): if NORUN: return if reloader and not os.environ.get(\"BOTTLE_CHILD\"): import subprocess fd, lockfile = tempfile.mkstemp(prefix=\"bottle.\", suffix=\".lock\") environ = os.environ.copy() environ[\"BOTTLE_CHILD\"] = \"true\" environ[\"BOTTLE_LOCKFILE\"] = lockfile args = [sys.executable] + sys.argv if getattr(sys.modules.get(\"__main__\"), \"__package__\", None): args[1:1] = [\"-m\", sys.modules[\"__main__\"].__package__] # 如果设置了 Reload 那么主进程会执行下面的 try block， # 启动子进程并且 Polling 在 while 循环中 try: os.close(fd) # We never write to this file while os.path.exists(lockfile): p = subprocess.Popen(args, env=environ) while p.poll() is None: os.utime(lockfile, None) # Tell child we are still alive time.sleep(interval) if p.returncode == 3: # Child wants to be restarted continue sys.exit(p.returncode) except KeyboardInterrupt: pass finally: if os.path.exists(lockfile): os.unlink(lockfile) return # 如果没有设置 Reload 或者是子进程，则会执行下面的 try block # 这时才会真正启动 Server，而且如果是子进程的话还会启动额外的检测线程 try: if debug is not None: _debug(debug) app = app or default_app() if isinstance(app, basestring): app = load_app(app) if not callable(app): raise ValueError(\"Application is not callable: %r\" % app) for plugin in plugins or []: if isinstance(plugin, basestring): plugin = load(plugin) app.install(plugin) if config: app.config.update(config) if server in server_names: server = server_names.get(server) if isinstance(server, basestring): server = load(server) if isinstance(server, type): server = server(host=host, port=port, **kargs) if not isinstance(server, ServerAdapter): raise ValueError(\"Unknown or unsupported server: %r\" % server) server.quiet = server.quiet or quiet if not server.quiet: _stderr( \"Bottle v%s server starting up (using %s)...\" % (__version__, repr(server)) ) if server.host.startswith(\"unix:\"): _stderr(\"Listening on %s\" % server.host) else: _stderr(\"Listening on http://%s:%d/\" % (server.host, server.port)) _stderr(\"Hit Ctrl-C to quit.\\n\") # 这里判断 Reload 成功就会启动 Daemon thread 检测文件改动 if reloader: lockfile = os.environ.get(\"BOTTLE_LOCKFILE\") bgcheck = FileCheckerThread(lockfile, interval) with bgcheck: server.run(app) # 如果文件出现改动则退出子进程 # 如果是 lockfile 有问题这里的 status 会是 error # 子进程也会退出，但 Exit status 不是 3 所以不会重启 if bgcheck.status == \"reload\": sys.exit(3) else: server.run(app) except KeyboardInterrupt: pass except (SystemExit, MemoryError): raise except: if not reloader: raise # 如果是其他的异常，非 quiet 情况下会打印错误栈 # sleep 之后退出子进程并重启 if not getattr(server, \"quiet\", quiet): print_exc() time.sleep(interval) sys.exit(3) class FileCheckerThread(threading.Thread): def __init__(self, lockfile, interval): threading.Thread.__init__(self) self.daemon = True self.lockfile, self.interval = lockfile, interval #: Is one of 'reload', 'error' or 'exit' self.status = None def run(self): exists = os.path.exists mtime = lambda p: os.stat(p).st_mtime files = dict() for module in list(sys.modules.values()): path = getattr(module, \"__file__\", \"\") or \"\" if path[-4:] in (\".pyo\", \".pyc\"): path = path[:-1] if path and exists(path): files[path] = mtime(path) while not self.status: # 如果 lockfile 不存在或者过于陈旧则通知子进程退出 # 这里的 interrupt_main 默认会发送给主线程（即子进程） # SIGINT 信号，触发 KeyboardInterrupt 异常 if ( not exists(self.lockfile) or mtime(self.lockfile) \u003c time.time() - self.interval - 5): self.status = \"error\" thread.interrupt_main() for path, lmtime in list(files.items()): if not exists(path) or mtime(path) \u003e lmtime: self.status = \"reload\" thread.interrupt_main() break time.sleep(self.interval) def __enter__(self): self.start() def __exit__(self, exc_type, *_): if not self.status: self.status = \"exit\" # silent exit self.join() # 这里通过判断类型来 Suppress interrupt_main() # 造成的 KeyboardInterrupt 异常，如果 __exit__ 返回 True # 则上下文管理器不会抛出异常 return exc_type is not None and issubclass(exc_type, KeyboardInterrupt) 大致的流程图如下：\nflowchart TD start([\"Start\"]) --\u003e reload_or_subproc{\"Is reloader set to True\\n or is this a child process?\"} reload_or_subproc --\u003e |Yes| subprocess[\"Spawn a subprocess\"] reload_or_subproc --\u003e |No| reload[\"Is reloader set to True?\"] subprocess --\u003e reload reload --\u003e |No| serve[\"Start serving\"] serve --\u003e if_restart{\"Need to restart?\"} if_restart --\u003e |Yes| subprocess if_restart --\u003e |No| stop([\"Stop\"]) reload --\u003e |Yes| filechecker[\"Spawn a file checker thread\"] filechecker --\u003e changes{\"Is there any changes\\n or broken lockfile?\"} changes --\u003e |Yes| if_restart changes --\u003e |No| changes 其中以 3 作为 Exit status 来标识重启的子进程，其实并不是一种标准用法（也没有固定的标准），可能算作 Python 程序的某种传统吧。\n扩展性 虽然 Bottle 已经自带了很多常用的工具，比如 Cookie 支持和文件上传，但并不妨碍在其基础上开发扩展，因为有 Hook 和 Plugin。\nHook 类似 Django 的 Middleware，可以在几个固定时机执行特定的功能，比如 before_request 和 after_request。\nPlugin 更灵活一些，也是添加 ORM 等复杂的定制化功能的最好方式。Plugin 基于视图函数执行，既可以全局生效，也能单独进行设置。对此 Bottle 定义了一整套抽象接口，这让 Plugin 不只是函数，也可以定义成复杂的对象，具体参考官方的开发文档。\n现状 虽然优点众多，但 Bottle 的没落也不是没有理由的。由于作者坚持单文件模块并且不增加额外依赖，同时又要兼容 Python 2，很大程度上限制框架的发展。不像 Flask，虽然出现得晚，这么多年来也早已发展壮大了。不过我倒是很佩服作者，让 Bottle 保持一直以来的定位：A fast, simple and lightweight WSGI micro web-framework for Python。\n即使不再流行，Bottle 背后现在仍然有一拨坚定的开发者，这离不开框架本身的实用性和过硬的代码质量。作为源代码学习的项目，Bottle 再合适不过了。而且，如果能够基于一个熟悉程度超高的 Web 框架做开发，体验也会是完全不一样的。\n向 Bottle 致敬。\nReferences\nBottle - GitHub\nBottle: Python Web Framework\nWeb Frameworks Benchmark\n","wordCount":"1264","inLanguage":"en","datePublished":"2022-04-22T21:53:29+08:00","dateModified":"2022-04-22T21:53:29+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://iamgodot.com/posts/source-code-of-bottle/"},"publisher":{"@type":"Organization","name":"Godot's Blog","logo":{"@type":"ImageObject","url":"https://iamgodot.com/icons/favicon.ico"}}}</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=https://iamgodot.com accesskey=h title="Godot's Blog (Alt + H)">Godot's Blog</a>
<span class=logo-switches></span></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Bottle 框架源码阅读</h1><div class=post-meta><span title='2022-04-22 21:53:29 +0800 +0800'>04-22</span>&nbsp;·&nbsp;6 min</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#web-%e6%a1%86%e6%9e%b6%e7%9a%84%e5%9f%ba%e6%9c%ac%e5%85%83%e7%b4%a0 aria-label="Web 框架的基本元素">Web 框架的基本元素</a></li><li><a href=#%e4%b8%80%e5%88%87%e4%bb%8e-wsgi-%e5%bc%80%e5%a7%8b aria-label="一切从 WSGI 开始">一切从 WSGI 开始</a></li><li><a href=#%e8%b7%af%e7%94%b1 aria-label=路由>路由</a></li><li><a href=#%e8%af%b7%e6%b1%82--%e5%93%8d%e5%ba%94 aria-label="请求 &amp;amp; 响应">请求 & 响应</a></li><li><a href=#%e6%9c%8d%e5%8a%a1 aria-label=服务>服务</a></li><li><a href=#%e6%a8%a1%e6%9d%bf%e7%b3%bb%e7%bb%9f aria-label=模板系统>模板系统</a></li><li><a href=#%e8%87%aa%e5%8a%a8%e9%87%8d%e5%90%af aria-label=自动重启>自动重启</a></li><li><a href=#%e6%89%a9%e5%b1%95%e6%80%a7 aria-label=扩展性>扩展性</a></li><li><a href=#%e7%8e%b0%e7%8a%b6 aria-label=现状>现状</a></li></ul></div></details></div><div class=post-content><p>写这篇文章最开心的一点是终于可以用这张截图了：</p><p><img loading=lazy src=https://static.iamgodot.com/content/images/20220423155637.png alt></p><p>相比名声在外的 Django/Flask/FastAPI，Bottle 可以说是非常不起眼了，甚至很多人并不知道它的存在。其实在很多方面，这个框架都极其优秀：</p><ul><li>速度：截止到 2022-04-13，Bottle 在一众 Python Web 框架的<a href="https://web-frameworks-benchmark.netlify.app/result?l=python">测评</a>中名列第二，要知道这可是十年以上的老前辈了。</li><li>易用性：Bottle 早在 Flask 之前就使用了装饰器来定义路由，此外还有全局可用的 Request/Response 对象。</li><li>文档：不仅将框架本身的使用讲得很清楚，还总结了很多 Web 场景下的解决方案。</li><li>代码质量：虽然为了 Python 2 做了不少兼容，但是代码很精炼，而且 Pythonic。</li><li>其他：Bottle 坚持单模块以及无第三方库依赖；仓库仍然在积极维护中。</li></ul><p>换作几年前，我会一开始就使用并将 Bottle 研究透彻，而不是让自己淹没在 Django 浩瀚如烟的文档中。下面开始梳理 Bottle 源码的阅读理解。因为代码量不大，所以就直接看最新的版本了：<code>0.11.1 - 5a6c620</code>。</p><h1 id=web-框架的基本元素>Web 框架的基本元素<a hidden class=anchor aria-hidden=true href=#web-框架的基本元素>#</a></h1><p>参考 <a href=https://docs.python-guide.org/scenarios/web/>The Hitchhiker&rsquo;s Guide to Python</a> 的说法，一个 Web 框架要满足的基本功能：</p><ol><li>URL Routing</li><li>Request and Response Objects</li><li><del>Template Engine</del></li><li>Development Web Server</li></ol><p>从后端的角度来讲更重要的是 1、2、4 三项，其中 1 负责转发请求到对应的视图函数，2 是对 HTTP 协议元素的解析处理，而 4 决定了服务的部署方式和基础性能。</p><p>Bottle 在这几方面都做了很好的实现：路由上提供了通配符匹配和装饰器接口；请求和响应对象作为全局对象存在并保证了线程安全；Server 部署除了 Python 自带的 <code>wsgiref</code> 还支持<a href=https://bottlepy.org/docs/dev/deployment.html#switching-the-server-backend>绝大多数的 WSGI Server</a>。</p><p>之外 Bottle 服务还会自动检测代码变更并重启，扩展方面有 Hook 和 Plugin 机制等等。</p><h1 id=一切从-wsgi-开始>一切从 WSGI 开始<a hidden class=anchor aria-hidden=true href=#一切从-wsgi-开始>#</a></h1><p>WSGI 定义了 Python Web 框架的统一接口规范，因此也是了解 Bottle 最好的突破口。一个 Web 服务可以简单看成 Server 和 Handler 两部分，前者负责监听端口并建立连接，而后者处理请求然后返回响应内容。Handler 在 WSGI 中称为 app，是一个可调用对象，比如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>application</span>(environ, start_response):
</span></span><span style=display:flex><span>    response_body <span style=color:#f92672>=</span> [
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#39;</span><span style=color:#e6db74>%s</span><span style=color:#e6db74>: </span><span style=color:#e6db74>%s</span><span style=color:#e6db74>&#39;</span> <span style=color:#f92672>%</span> (key, value) <span style=color:#66d9ef>for</span> key, value <span style=color:#f92672>in</span> sorted(environ<span style=color:#f92672>.</span>items())
</span></span><span style=display:flex><span>    ]
</span></span><span style=display:flex><span>    response_body <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#39;</span><span style=color:#f92672>.</span>join(response_body)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    status <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;200 OK&#39;</span>
</span></span><span style=display:flex><span>    response_headers <span style=color:#f92672>=</span> [
</span></span><span style=display:flex><span>        (<span style=color:#e6db74>&#39;Content-Type&#39;</span>, <span style=color:#e6db74>&#39;text/plain&#39;</span>),
</span></span><span style=display:flex><span>        (<span style=color:#e6db74>&#39;Content-Length&#39;</span>, str(len(response_body)))
</span></span><span style=display:flex><span>    ]
</span></span><span style=display:flex><span>    start_response(status, response_headers)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> [response_body<span style=color:#f92672>.</span>encode()]
</span></span></code></pre></div><p>在 Bottle 中 app 被包装成了一个 <code>Bottle</code> 对象，实际的调用过程在它的 <code>wsgi</code> 方法里：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Bottle</span>(object):
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>wsgi</span>(self, environ, start_response):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>            <span style=color:#75715e># 获取响应内容并做适当转化</span>
</span></span><span style=display:flex><span>            out <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>_cast(self<span style=color:#f92672>.</span>_handle(environ))
</span></span><span style=display:flex><span>            <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>            exc_info <span style=color:#f92672>=</span> environ<span style=color:#f92672>.</span>get(<span style=color:#e6db74>&#34;bottle.exc_info&#34;</span>)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> exc_info <span style=color:#f92672>is</span> <span style=color:#f92672>not</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>del</span> environ[<span style=color:#e6db74>&#34;bottle.exc_info&#34;</span>]
</span></span><span style=display:flex><span>            start_response(response<span style=color:#f92672>.</span>_wsgi_status_line(), response<span style=color:#f92672>.</span>headerlist, exc_info)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> out
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>except</span> (<span style=color:#a6e22e>KeyboardInterrupt</span>, <span style=color:#a6e22e>SystemExit</span>, <span style=color:#a6e22e>MemoryError</span>):
</span></span><span style=display:flex><span>            <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>_handle</span>(self, environ):
</span></span><span style=display:flex><span>        <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> <span style=color:#66d9ef>True</span>:
</span></span><span style=display:flex><span>                out <span style=color:#f92672>=</span> <span style=color:#66d9ef>None</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>                    self<span style=color:#f92672>.</span>trigger_hook(<span style=color:#e6db74>&#34;before_request&#34;</span>)
</span></span><span style=display:flex><span>                    <span style=color:#75715e># 通过路由找到视图函数</span>
</span></span><span style=display:flex><span>                    route, args <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>router<span style=color:#f92672>.</span>match(environ)
</span></span><span style=display:flex><span>                    environ[<span style=color:#e6db74>&#34;route.handle&#34;</span>] <span style=color:#f92672>=</span> route
</span></span><span style=display:flex><span>                    environ[<span style=color:#e6db74>&#34;bottle.route&#34;</span>] <span style=color:#f92672>=</span> route
</span></span><span style=display:flex><span>                    environ[<span style=color:#e6db74>&#34;route.url_args&#34;</span>] <span style=color:#f92672>=</span> args
</span></span><span style=display:flex><span>                    <span style=color:#75715e># 调用视图函数获取结果</span>
</span></span><span style=display:flex><span>                    out <span style=color:#f92672>=</span> route<span style=color:#f92672>.</span>call(<span style=color:#f92672>**</span>args)
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>except</span> HTTPResponse <span style=color:#66d9ef>as</span> E:
</span></span><span style=display:flex><span>                    <span style=color:#f92672>....</span>
</span></span></code></pre></div><p>可以看到，<code>_handle</code> 方法负责路由到对应的视图函数并调用获取响应，而 <code>_cast</code> 会对响应内容进行 WSGI 兼容的处理。</p><p>接下来根据 <code>self.router.match(environ)</code> 来看路由部分的具体实现。</p><h1 id=路由>路由<a hidden class=anchor aria-hidden=true href=#路由>#</a></h1><p><code>Router</code> 是抽象出来的负责路由转发的对象，实质上是一系列 Routes 的集合，而每个 <code>Route</code> 代表方法和路径到视图函数的对应关系。因此，当一个 HTTP 请求到来，Router 就可以从 Routes 中找到匹配的视图函数。思路很简单，关键是如何实现高效的查找过程。下面看 <code>Router</code> 的代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Router</span>(object):
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>match</span>(self, environ):
</span></span><span style=display:flex><span>        <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> method <span style=color:#f92672>in</span> methods:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> method <span style=color:#f92672>in</span> self<span style=color:#f92672>.</span>static <span style=color:#f92672>and</span> path <span style=color:#f92672>in</span> self<span style=color:#f92672>.</span>static[method]:
</span></span><span style=display:flex><span>                target, getargs <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>static[method][path]
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> target, getargs(path) <span style=color:#66d9ef>if</span> getargs <span style=color:#66d9ef>else</span> {}
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>elif</span> method <span style=color:#f92672>in</span> self<span style=color:#f92672>.</span>dyna_regexes:
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span> combined, rules <span style=color:#f92672>in</span> self<span style=color:#f92672>.</span>dyna_regexes[method]:
</span></span><span style=display:flex><span>                    match <span style=color:#f92672>=</span> combined(path)
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> match:
</span></span><span style=display:flex><span>                        target, getargs <span style=color:#f92672>=</span> rules[match<span style=color:#f92672>.</span>lastindex <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>return</span> target, getargs(path) <span style=color:#66d9ef>if</span> getargs <span style=color:#66d9ef>else</span> {}
</span></span><span style=display:flex><span>        <span style=color:#f92672>...</span>
</span></span></code></pre></div><p>核心逻辑有两部分：首先是静态匹配，在 <code>self.static</code> 中保存了从方法到路径再到视图函数（<code>target</code>）的映射，这里会直接用哈希表实现快速查找；其次是通配符匹配，<code>self.dyna_regexes</code> 里每个方法都包含多个 <code>(combined, rules)</code> 元组，而 <code>combined</code> 由多个正则表达式组合到一起（每个正则代表一个动态路径），对应到 <code>rules</code> 中的多个视图函数。之所以会有多个元组，是因为 CPython 中正则的分组匹配最多只支持 99 个，所以一个 <code>combined</code> 的容量是有限的，如果动态路由过多，就需要增加新的元组。</p><p>这里体现了 Bottle 路由查找的基本原则：</p><ul><li>静态路由匹配的优先级高于动态路由。</li><li>动态路由匹配有先后顺序，注意不要造成短路。</li><li>还有添加路由的时候<ul><li>一个视图函数可以定义多个路径。</li><li>重复定义会覆盖原有路由，当然这也是允许的。</li></ul></li></ul><h1 id=请求--响应>请求 & 响应<a hidden class=anchor aria-hidden=true href=#请求--响应>#</a></h1><p>接下来是对 HTTP 请求和响应的抽象，Bottle 定义了全局的 Request & Response 对象。看起来和 Flask 很像，其实要比后者更早。</p><p>关键在于保证线程安全，这部分已经在 <a href=/posts/sourcecode-of-python-threadlocal>Python 中的 TLS 是如何实现的</a> 中说得很详细了，下面看看 Bottle 是怎么实现的：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>_local_property</span>():
</span></span><span style=display:flex><span>    ls <span style=color:#f92672>=</span> threading<span style=color:#f92672>.</span>local()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>fget</span>(_):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> ls<span style=color:#f92672>.</span>var
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>except</span> <span style=color:#a6e22e>AttributeError</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>raise</span> <span style=color:#a6e22e>RuntimeError</span>(<span style=color:#e6db74>&#34;Request context not initialized.&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>fset</span>(_, value):
</span></span><span style=display:flex><span>        ls<span style=color:#f92672>.</span>var <span style=color:#f92672>=</span> value
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>fdel</span>(_):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>del</span> ls<span style=color:#f92672>.</span>var
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> property(fget, fset, fdel, <span style=color:#e6db74>&#34;Thread-local property&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>LocalRequest</span>(BaseRequest):
</span></span><span style=display:flex><span>    bind <span style=color:#f92672>=</span> BaseRequest<span style=color:#f92672>.</span>__init__
</span></span><span style=display:flex><span>    environ <span style=color:#f92672>=</span> _local_property()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>LocalResponse</span>(BaseResponse):
</span></span><span style=display:flex><span>    bind <span style=color:#f92672>=</span> BaseResponse<span style=color:#f92672>.</span>__init__
</span></span><span style=display:flex><span>    _status_line <span style=color:#f92672>=</span> _local_property()
</span></span><span style=display:flex><span>    _status_code <span style=color:#f92672>=</span> _local_property()
</span></span><span style=display:flex><span>    _cookies <span style=color:#f92672>=</span> _local_property()
</span></span><span style=display:flex><span>    _headers <span style=color:#f92672>=</span> _local_property()
</span></span><span style=display:flex><span>    body <span style=color:#f92672>=</span> _local_property()
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>request <span style=color:#f92672>=</span> LocalRequest()
</span></span><span style=display:flex><span>response <span style=color:#f92672>=</span> LocalResponse()
</span></span></code></pre></div><p>基于 <code>threading.local</code>，Bottle 使用修饰符来定义 <code>LocalRequest</code> 和 <code>LocalResponse</code> 中的 HTTP 属性，这样的实现很灵活，也可以轻松地应用到其他的对象。</p><p>需要注意的是，在 greenlet 和 coroutine 大行其道的今天，<code>threading.local</code> 已经完全不够用了。Bottle 与 ASGI 水土不服，但是一定要部署成 Async 服务的话，也是有方法的：比如保证 <code>threading.local</code> 提前被 monkeypatch（针对 gevent），或者在代码中使用 <code>request.copy()</code> 拷贝出新的请求对象。作者在文档和 <a href="https://github.com/bottlepy/bottle/issues?q=async">Issue</a> 中都做了详细的解释。</p><h1 id=服务>服务<a hidden class=anchor aria-hidden=true href=#服务>#</a></h1><p>Bottle 默认使用了 <code>wsgiref</code> 模块中的 WSGI Server 来启动服务，这种服务是单线程的，所以也只适用于本地开发。</p><p>此外 Bottle 支持许多 Web Server 部署，在官网有详细列举：</p><p><img loading=lazy src=https://static.iamgodot.com/content/images/20220423123506.png alt></p><p>为了兼容这么多的 Server，Bottle 在内部实现了各种各样的适配器，比如 <code>wsgiref</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ServerAdapter</span>(object):
</span></span><span style=display:flex><span>    quiet <span style=color:#f92672>=</span> <span style=color:#66d9ef>False</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(self, host<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;127.0.0.1&#34;</span>, port<span style=color:#f92672>=</span><span style=color:#ae81ff>8080</span>, <span style=color:#f92672>**</span>options):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>options <span style=color:#f92672>=</span> options
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>host <span style=color:#f92672>=</span> host
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>port <span style=color:#f92672>=</span> int(port)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>run</span>(self, handler):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>pass</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __repr__(self):
</span></span><span style=display:flex><span>        args <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;, &#34;</span><span style=color:#f92672>.</span>join(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>%s</span><span style=color:#e6db74>=</span><span style=color:#e6db74>%s</span><span style=color:#e6db74>&#34;</span> <span style=color:#f92672>%</span> (k, repr(v)) <span style=color:#66d9ef>for</span> k, v <span style=color:#f92672>in</span> self<span style=color:#f92672>.</span>options<span style=color:#f92672>.</span>items())
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>%s</span><span style=color:#e6db74>(</span><span style=color:#e6db74>%s</span><span style=color:#e6db74>)&#34;</span> <span style=color:#f92672>%</span> (self<span style=color:#f92672>.</span>__class__<span style=color:#f92672>.</span>__name__, args)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>WSGIRefServer</span>(ServerAdapter):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>run</span>(self, app):
</span></span><span style=display:flex><span>        <span style=color:#f92672>import</span> socket
</span></span><span style=display:flex><span>        <span style=color:#f92672>from</span> wsgiref.simple_server <span style=color:#f92672>import</span> (WSGIRequestHandler, WSGIServer,
</span></span><span style=display:flex><span>                                           make_server)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        handler_cls <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>options<span style=color:#f92672>.</span>get(<span style=color:#e6db74>&#34;handler_class&#34;</span>, FixedHandler)
</span></span><span style=display:flex><span>        server_cls <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>options<span style=color:#f92672>.</span>get(<span style=color:#e6db74>&#34;server_class&#34;</span>, WSGIServer)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>srv <span style=color:#f92672>=</span> make_server(self<span style=color:#f92672>.</span>host, self<span style=color:#f92672>.</span>port, app, server_cls, handler_cls)
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>port <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>srv<span style=color:#f92672>.</span>server_port
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>srv<span style=color:#f92672>.</span>serve_forever()
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>except</span> <span style=color:#a6e22e>KeyboardInterrupt</span>:
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>srv<span style=color:#f92672>.</span>server_close()
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>raise</span>
</span></span></code></pre></div><p>通过适配器模式，可以很方便地修改原有适配或者添加新的 Server 支持。这里不详述了。</p><h1 id=模板系统>模板系统<a hidden class=anchor aria-hidden=true href=#模板系统>#</a></h1><p>Bottle 实现了自己的模板生成功能，同时也支持主流的 Mako 和 Jinja2。无论使用哪一种，都可以直接调用 <code>template</code> 这个简单的接口：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>template</span>(<span style=color:#f92672>*</span>args, <span style=color:#f92672>**</span>kwargs):
</span></span><span style=display:flex><span>    tpl <span style=color:#f92672>=</span> args[<span style=color:#ae81ff>0</span>] <span style=color:#66d9ef>if</span> args <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>None</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> dictarg <span style=color:#f92672>in</span> args[<span style=color:#ae81ff>1</span>:]:
</span></span><span style=display:flex><span>        kwargs<span style=color:#f92672>.</span>update(dictarg)
</span></span><span style=display:flex><span>    adapter <span style=color:#f92672>=</span> kwargs<span style=color:#f92672>.</span>pop(<span style=color:#e6db74>&#34;template_adapter&#34;</span>, SimpleTemplate)
</span></span><span style=display:flex><span>    lookup <span style=color:#f92672>=</span> kwargs<span style=color:#f92672>.</span>pop(<span style=color:#e6db74>&#34;template_lookup&#34;</span>, TEMPLATE_PATH)
</span></span><span style=display:flex><span>    tplid <span style=color:#f92672>=</span> (id(lookup), tpl)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> tplid <span style=color:#f92672>not</span> <span style=color:#f92672>in</span> TEMPLATES <span style=color:#f92672>or</span> DEBUG:
</span></span><span style=display:flex><span>        settings <span style=color:#f92672>=</span> kwargs<span style=color:#f92672>.</span>pop(<span style=color:#e6db74>&#34;template_settings&#34;</span>, {})
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> isinstance(tpl, adapter):
</span></span><span style=display:flex><span>            TEMPLATES[tplid] <span style=color:#f92672>=</span> tpl
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> settings:
</span></span><span style=display:flex><span>                TEMPLATES[tplid]<span style=color:#f92672>.</span>prepare(<span style=color:#f92672>**</span>settings)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>elif</span> <span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span> <span style=color:#f92672>in</span> tpl <span style=color:#f92672>or</span> <span style=color:#e6db74>&#34;{&#34;</span> <span style=color:#f92672>in</span> tpl <span style=color:#f92672>or</span> <span style=color:#e6db74>&#34;%&#34;</span> <span style=color:#f92672>in</span> tpl <span style=color:#f92672>or</span> <span style=color:#e6db74>&#34;$&#34;</span> <span style=color:#f92672>in</span> tpl:
</span></span><span style=display:flex><span>            TEMPLATES[tplid] <span style=color:#f92672>=</span> adapter(source<span style=color:#f92672>=</span>tpl, lookup<span style=color:#f92672>=</span>lookup, <span style=color:#f92672>**</span>settings)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>            TEMPLATES[tplid] <span style=color:#f92672>=</span> adapter(name<span style=color:#f92672>=</span>tpl, lookup<span style=color:#f92672>=</span>lookup, <span style=color:#f92672>**</span>settings)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> TEMPLATES[tplid]:
</span></span><span style=display:flex><span>        abort(<span style=color:#ae81ff>500</span>, <span style=color:#e6db74>&#34;Template (</span><span style=color:#e6db74>%s</span><span style=color:#e6db74>) not found&#34;</span> <span style=color:#f92672>%</span> tpl)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> TEMPLATES[tplid]<span style=color:#f92672>.</span>render(kwargs)
</span></span></code></pre></div><p>通过指定 <code>template_adapter</code> 使用不同的模板系统，这是很典型的策略模式。另外，这里也同样出现了适配器模式，基于 <code>BaseTemplate</code> 来适配各个模板库：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MakoTemplate</span>(BaseTemplate):
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Jinja2Template</span>(BaseTemplate):
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SimpleTemplate</span>(BaseTemplate):
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>
</span></span></code></pre></div><h1 id=自动重启>自动重启<a hidden class=anchor aria-hidden=true href=#自动重启>#</a></h1><p>Bottle 还提供了检测 Python 文件改动并自动重启服务的功能，实现思路也很巧妙：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>run</span>(
</span></span><span style=display:flex><span>    app<span style=color:#f92672>=</span><span style=color:#66d9ef>None</span>,
</span></span><span style=display:flex><span>    server<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;wsgiref&#34;</span>,
</span></span><span style=display:flex><span>    host<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;127.0.0.1&#34;</span>,
</span></span><span style=display:flex><span>    port<span style=color:#f92672>=</span><span style=color:#ae81ff>8080</span>,
</span></span><span style=display:flex><span>    interval<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>    reloader<span style=color:#f92672>=</span><span style=color:#66d9ef>False</span>,
</span></span><span style=display:flex><span>    quiet<span style=color:#f92672>=</span><span style=color:#66d9ef>False</span>,
</span></span><span style=display:flex><span>    plugins<span style=color:#f92672>=</span><span style=color:#66d9ef>None</span>,
</span></span><span style=display:flex><span>    debug<span style=color:#f92672>=</span><span style=color:#66d9ef>None</span>,
</span></span><span style=display:flex><span>    config<span style=color:#f92672>=</span><span style=color:#66d9ef>None</span>,
</span></span><span style=display:flex><span>    <span style=color:#f92672>**</span>kargs
</span></span><span style=display:flex><span>):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> NORUN:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> reloader <span style=color:#f92672>and</span> <span style=color:#f92672>not</span> os<span style=color:#f92672>.</span>environ<span style=color:#f92672>.</span>get(<span style=color:#e6db74>&#34;BOTTLE_CHILD&#34;</span>):
</span></span><span style=display:flex><span>        <span style=color:#f92672>import</span> subprocess
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        fd, lockfile <span style=color:#f92672>=</span> tempfile<span style=color:#f92672>.</span>mkstemp(prefix<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;bottle.&#34;</span>, suffix<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;.lock&#34;</span>)
</span></span><span style=display:flex><span>        environ <span style=color:#f92672>=</span> os<span style=color:#f92672>.</span>environ<span style=color:#f92672>.</span>copy()
</span></span><span style=display:flex><span>        environ[<span style=color:#e6db74>&#34;BOTTLE_CHILD&#34;</span>] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;true&#34;</span>
</span></span><span style=display:flex><span>        environ[<span style=color:#e6db74>&#34;BOTTLE_LOCKFILE&#34;</span>] <span style=color:#f92672>=</span> lockfile
</span></span><span style=display:flex><span>        args <span style=color:#f92672>=</span> [sys<span style=color:#f92672>.</span>executable] <span style=color:#f92672>+</span> sys<span style=color:#f92672>.</span>argv
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> getattr(sys<span style=color:#f92672>.</span>modules<span style=color:#f92672>.</span>get(<span style=color:#e6db74>&#34;__main__&#34;</span>), <span style=color:#e6db74>&#34;__package__&#34;</span>, <span style=color:#66d9ef>None</span>):
</span></span><span style=display:flex><span>            args[<span style=color:#ae81ff>1</span>:<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> [<span style=color:#e6db74>&#34;-m&#34;</span>, sys<span style=color:#f92672>.</span>modules[<span style=color:#e6db74>&#34;__main__&#34;</span>]<span style=color:#f92672>.</span>__package__]
</span></span><span style=display:flex><span>        <span style=color:#75715e># 如果设置了 Reload 那么主进程会执行下面的 try block，</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># 启动子进程并且 Polling 在 while 循环中</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>            os<span style=color:#f92672>.</span>close(fd)  <span style=color:#75715e># We never write to this file</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> os<span style=color:#f92672>.</span>path<span style=color:#f92672>.</span>exists(lockfile):
</span></span><span style=display:flex><span>                p <span style=color:#f92672>=</span> subprocess<span style=color:#f92672>.</span>Popen(args, env<span style=color:#f92672>=</span>environ)
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>while</span> p<span style=color:#f92672>.</span>poll() <span style=color:#f92672>is</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>                    os<span style=color:#f92672>.</span>utime(lockfile, <span style=color:#66d9ef>None</span>)  <span style=color:#75715e># Tell child we are still alive</span>
</span></span><span style=display:flex><span>                    time<span style=color:#f92672>.</span>sleep(interval)
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> p<span style=color:#f92672>.</span>returncode <span style=color:#f92672>==</span> <span style=color:#ae81ff>3</span>:  <span style=color:#75715e># Child wants to be restarted</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>                sys<span style=color:#f92672>.</span>exit(p<span style=color:#f92672>.</span>returncode)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>except</span> <span style=color:#a6e22e>KeyboardInterrupt</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>pass</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>finally</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> os<span style=color:#f92672>.</span>path<span style=color:#f92672>.</span>exists(lockfile):
</span></span><span style=display:flex><span>                os<span style=color:#f92672>.</span>unlink(lockfile)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 如果没有设置 Reload 或者是子进程，则会执行下面的 try block</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 这时才会真正启动 Server，而且如果是子进程的话还会启动额外的检测线程</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> debug <span style=color:#f92672>is</span> <span style=color:#f92672>not</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>            _debug(debug)
</span></span><span style=display:flex><span>        app <span style=color:#f92672>=</span> app <span style=color:#f92672>or</span> default_app()
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> isinstance(app, basestring):
</span></span><span style=display:flex><span>            app <span style=color:#f92672>=</span> load_app(app)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> callable(app):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>raise</span> <span style=color:#a6e22e>ValueError</span>(<span style=color:#e6db74>&#34;Application is not callable: </span><span style=color:#e6db74>%r</span><span style=color:#e6db74>&#34;</span> <span style=color:#f92672>%</span> app)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> plugin <span style=color:#f92672>in</span> plugins <span style=color:#f92672>or</span> []:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> isinstance(plugin, basestring):
</span></span><span style=display:flex><span>                plugin <span style=color:#f92672>=</span> load(plugin)
</span></span><span style=display:flex><span>            app<span style=color:#f92672>.</span>install(plugin)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> config:
</span></span><span style=display:flex><span>            app<span style=color:#f92672>.</span>config<span style=color:#f92672>.</span>update(config)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> server <span style=color:#f92672>in</span> server_names:
</span></span><span style=display:flex><span>            server <span style=color:#f92672>=</span> server_names<span style=color:#f92672>.</span>get(server)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> isinstance(server, basestring):
</span></span><span style=display:flex><span>            server <span style=color:#f92672>=</span> load(server)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> isinstance(server, type):
</span></span><span style=display:flex><span>            server <span style=color:#f92672>=</span> server(host<span style=color:#f92672>=</span>host, port<span style=color:#f92672>=</span>port, <span style=color:#f92672>**</span>kargs)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> isinstance(server, ServerAdapter):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>raise</span> <span style=color:#a6e22e>ValueError</span>(<span style=color:#e6db74>&#34;Unknown or unsupported server: </span><span style=color:#e6db74>%r</span><span style=color:#e6db74>&#34;</span> <span style=color:#f92672>%</span> server)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        server<span style=color:#f92672>.</span>quiet <span style=color:#f92672>=</span> server<span style=color:#f92672>.</span>quiet <span style=color:#f92672>or</span> quiet
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> server<span style=color:#f92672>.</span>quiet:
</span></span><span style=display:flex><span>            _stderr(
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#34;Bottle v</span><span style=color:#e6db74>%s</span><span style=color:#e6db74> server starting up (using </span><span style=color:#e6db74>%s</span><span style=color:#e6db74>)...&#34;</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>%</span> (__version__, repr(server))
</span></span><span style=display:flex><span>            )
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> server<span style=color:#f92672>.</span>host<span style=color:#f92672>.</span>startswith(<span style=color:#e6db74>&#34;unix:&#34;</span>):
</span></span><span style=display:flex><span>                _stderr(<span style=color:#e6db74>&#34;Listening on </span><span style=color:#e6db74>%s</span><span style=color:#e6db74>&#34;</span> <span style=color:#f92672>%</span> server<span style=color:#f92672>.</span>host)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>                _stderr(<span style=color:#e6db74>&#34;Listening on http://</span><span style=color:#e6db74>%s</span><span style=color:#e6db74>:</span><span style=color:#e6db74>%d</span><span style=color:#e6db74>/&#34;</span> <span style=color:#f92672>%</span> (server<span style=color:#f92672>.</span>host, server<span style=color:#f92672>.</span>port))
</span></span><span style=display:flex><span>            _stderr(<span style=color:#e6db74>&#34;Hit Ctrl-C to quit.</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>        <span style=color:#75715e># 这里判断 Reload 成功就会启动 Daemon thread 检测文件改动</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> reloader:
</span></span><span style=display:flex><span>            lockfile <span style=color:#f92672>=</span> os<span style=color:#f92672>.</span>environ<span style=color:#f92672>.</span>get(<span style=color:#e6db74>&#34;BOTTLE_LOCKFILE&#34;</span>)
</span></span><span style=display:flex><span>            bgcheck <span style=color:#f92672>=</span> FileCheckerThread(lockfile, interval)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>with</span> bgcheck:
</span></span><span style=display:flex><span>                server<span style=color:#f92672>.</span>run(app)
</span></span><span style=display:flex><span>            <span style=color:#75715e># 如果文件出现改动则退出子进程</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e># 如果是 lockfile 有问题这里的 status 会是 error</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e># 子进程也会退出，但 Exit status 不是 3 所以不会重启</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> bgcheck<span style=color:#f92672>.</span>status <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;reload&#34;</span>:
</span></span><span style=display:flex><span>                sys<span style=color:#f92672>.</span>exit(<span style=color:#ae81ff>3</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>            server<span style=color:#f92672>.</span>run(app)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>except</span> <span style=color:#a6e22e>KeyboardInterrupt</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>pass</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>except</span> (<span style=color:#a6e22e>SystemExit</span>, <span style=color:#a6e22e>MemoryError</span>):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>raise</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>except</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> reloader:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>raise</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># 如果是其他的异常，非 quiet 情况下会打印错误栈</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># sleep 之后退出子进程并重启</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> getattr(server, <span style=color:#e6db74>&#34;quiet&#34;</span>, quiet):
</span></span><span style=display:flex><span>            print_exc()
</span></span><span style=display:flex><span>        time<span style=color:#f92672>.</span>sleep(interval)
</span></span><span style=display:flex><span>        sys<span style=color:#f92672>.</span>exit(<span style=color:#ae81ff>3</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>FileCheckerThread</span>(threading<span style=color:#f92672>.</span>Thread):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(self, lockfile, interval):
</span></span><span style=display:flex><span>        threading<span style=color:#f92672>.</span>Thread<span style=color:#f92672>.</span>__init__(self)
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>daemon <span style=color:#f92672>=</span> <span style=color:#66d9ef>True</span>
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>lockfile, self<span style=color:#f92672>.</span>interval <span style=color:#f92672>=</span> lockfile, interval
</span></span><span style=display:flex><span>        <span style=color:#75715e>#: Is one of &#39;reload&#39;, &#39;error&#39; or &#39;exit&#39;</span>
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>status <span style=color:#f92672>=</span> <span style=color:#66d9ef>None</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>run</span>(self):
</span></span><span style=display:flex><span>        exists <span style=color:#f92672>=</span> os<span style=color:#f92672>.</span>path<span style=color:#f92672>.</span>exists
</span></span><span style=display:flex><span>        mtime <span style=color:#f92672>=</span> <span style=color:#66d9ef>lambda</span> p: os<span style=color:#f92672>.</span>stat(p)<span style=color:#f92672>.</span>st_mtime
</span></span><span style=display:flex><span>        files <span style=color:#f92672>=</span> dict()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> module <span style=color:#f92672>in</span> list(sys<span style=color:#f92672>.</span>modules<span style=color:#f92672>.</span>values()):
</span></span><span style=display:flex><span>            path <span style=color:#f92672>=</span> getattr(module, <span style=color:#e6db74>&#34;__file__&#34;</span>, <span style=color:#e6db74>&#34;&#34;</span>) <span style=color:#f92672>or</span> <span style=color:#e6db74>&#34;&#34;</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> path[<span style=color:#f92672>-</span><span style=color:#ae81ff>4</span>:] <span style=color:#f92672>in</span> (<span style=color:#e6db74>&#34;.pyo&#34;</span>, <span style=color:#e6db74>&#34;.pyc&#34;</span>):
</span></span><span style=display:flex><span>                path <span style=color:#f92672>=</span> path[:<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> path <span style=color:#f92672>and</span> exists(path):
</span></span><span style=display:flex><span>                files[path] <span style=color:#f92672>=</span> mtime(path)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> <span style=color:#f92672>not</span> self<span style=color:#f92672>.</span>status:
</span></span><span style=display:flex><span>            <span style=color:#75715e># 如果 lockfile 不存在或者过于陈旧则通知子进程退出</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e># 这里的 interrupt_main 默认会发送给主线程（即子进程）</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e># SIGINT 信号，触发 KeyboardInterrupt 异常</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (
</span></span><span style=display:flex><span>                <span style=color:#f92672>not</span> exists(self<span style=color:#f92672>.</span>lockfile)
</span></span><span style=display:flex><span>                <span style=color:#f92672>or</span> mtime(self<span style=color:#f92672>.</span>lockfile) <span style=color:#f92672>&lt;</span> time<span style=color:#f92672>.</span>time() <span style=color:#f92672>-</span> self<span style=color:#f92672>.</span>interval <span style=color:#f92672>-</span> <span style=color:#ae81ff>5</span>):
</span></span><span style=display:flex><span>                self<span style=color:#f92672>.</span>status <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;error&#34;</span>
</span></span><span style=display:flex><span>                thread<span style=color:#f92672>.</span>interrupt_main()
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> path, lmtime <span style=color:#f92672>in</span> list(files<span style=color:#f92672>.</span>items()):
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> exists(path) <span style=color:#f92672>or</span> mtime(path) <span style=color:#f92672>&gt;</span> lmtime:
</span></span><span style=display:flex><span>                    self<span style=color:#f92672>.</span>status <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;reload&#34;</span>
</span></span><span style=display:flex><span>                    thread<span style=color:#f92672>.</span>interrupt_main()
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>            time<span style=color:#f92672>.</span>sleep(self<span style=color:#f92672>.</span>interval)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __enter__(self):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>start()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __exit__(self, exc_type, <span style=color:#f92672>*</span>_):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> self<span style=color:#f92672>.</span>status:
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>status <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;exit&#34;</span>  <span style=color:#75715e># silent exit</span>
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>join()
</span></span><span style=display:flex><span>        <span style=color:#75715e># 这里通过判断类型来 Suppress interrupt_main()</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># 造成的 KeyboardInterrupt 异常，如果 __exit__ 返回 True</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># 则上下文管理器不会抛出异常</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> exc_type <span style=color:#f92672>is</span> <span style=color:#f92672>not</span> <span style=color:#66d9ef>None</span> <span style=color:#f92672>and</span> issubclass(exc_type, <span style=color:#a6e22e>KeyboardInterrupt</span>)
</span></span></code></pre></div><p>大致的流程图如下：</p><script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script>
<script>mermaid.initialize({startOnLoad:!0,theme:"dark"})</script><div class=mermaid>flowchart TD
start(["Start"]) --> reload_or_subproc{"Is reloader set to True\n or is this a child process?"}
reload_or_subproc --> |Yes| subprocess["Spawn a subprocess"]
reload_or_subproc --> |No| reload["Is reloader set to True?"]
subprocess --> reload
reload --> |No| serve["Start serving"]
serve --> if_restart{"Need to restart?"}
if_restart --> |Yes| subprocess
if_restart --> |No| stop(["Stop"])
reload --> |Yes| filechecker["Spawn a file checker thread"]
filechecker --> changes{"Is there any changes\n or broken lockfile?"}
changes --> |Yes| if_restart
changes --> |No| changes</div><p>其中以 3 作为 Exit status 来标识重启的子进程，其实并不是一种标准用法（也没有固定的标准），可能算作 Python 程序的某种传统吧。</p><h1 id=扩展性>扩展性<a hidden class=anchor aria-hidden=true href=#扩展性>#</a></h1><p>虽然 Bottle 已经自带了很多常用的工具，比如 Cookie 支持和文件上传，但并不妨碍在其基础上开发扩展，因为有 Hook 和 Plugin。</p><p>Hook 类似 Django 的 Middleware，可以在几个固定时机执行特定的功能，比如 <code>before_request</code> 和 <code>after_request</code>。</p><p>Plugin 更灵活一些，也是添加 ORM 等复杂的定制化功能的最好方式。Plugin 基于视图函数执行，既可以全局生效，也能单独进行设置。对此 Bottle 定义了一整套抽象接口，这让 Plugin 不只是函数，也可以定义成复杂的对象，具体参考<a href=https://bottlepy.org/docs/dev/plugindev.html>官方的开发文档</a>。</p><h1 id=现状>现状<a hidden class=anchor aria-hidden=true href=#现状>#</a></h1><p>虽然优点众多，但 Bottle 的没落也不是没有理由的。由于作者坚持单文件模块并且不增加额外依赖，同时又要兼容 Python 2，很大程度上限制框架的发展。不像 Flask，虽然出现得晚，这么多年来也早已发展壮大了。不过我倒是很佩服作者，让 Bottle 保持一直以来的定位：<strong>A fast, simple and lightweight WSGI micro web-framework for Python</strong>。</p><p>即使不再流行，Bottle 背后现在仍然有一拨坚定的开发者，这离不开框架本身的实用性和过硬的代码质量。作为源代码学习的项目，Bottle 再合适不过了。而且，如果能够基于一个熟悉程度超高的 Web 框架做开发，体验也会是完全不一样的。</p><p>向 Bottle 致敬。</p><hr><p><em>References</em></p><ul><li><p><a href=https://github.com/bottlepy/bottle/>Bottle - GitHub</a></p></li><li><p><a href=https://bottlepy.org/docs/dev/index.html>Bottle: Python Web Framework</a></p></li><li><p><a href=https://web-frameworks-benchmark.netlify.app/>Web Frameworks Benchmark</a></p></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://iamgodot.com/tags/python/>python</a></li></ul><nav class=paginav><a class=prev href=https://iamgodot.com/posts/on-solitude/><span class=title>« Prev Page</span><br><span>论独处</span></a>
<a class=next href=https://iamgodot.com/posts/sourcecode-of-python-threadlocal/><span class=title>Next Page »</span><br><span>Python 中的 TLS 是如何实现的</span></a></nav></footer><script src=https://giscus.app/client.js data-repo=iamgodot/godot-blog-comments data-repo-id="MDEwOlJlcG9zaXRvcnkzOTk0Nzk0MTY=" data-category=Announcements data-category-id=DIC_kwDOF8-SeM4CO3OX data-mapping=pathname data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=dark_dimmed data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2020-2022 <a href=https://iamgodot.com>Godot's Blog</a></span>
<span>| <a href=http://beian.miit.gov.cn/ target=_blank>京ICP备20005558号-2</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>