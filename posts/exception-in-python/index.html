<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Python 中的异常 | Godot's Blog - 个人生活分享</title><meta name=keywords content="Python 捕获异常,Python 自定义异常,Python 抛出异常"><meta name=description content="在 Python 中，EAFP 的风格很受青睐，这种写法能让代码更加简洁，还可以避免一些重复判断和多线程竞争的问题。为此，了解并熟练使用异常是很重要的。
异常类 首先来看一下 Python 内置的异常类（有省略）：
BaseException +-- SystemExit +-- KeyboardInterrupt +-- GeneratorExit +-- Exception +-- StopIteration +-- StopAsyncIteration +-- ArithmeticError +-- AssertionError +-- AttributeError +-- BufferError +-- EOFError +-- ImportError +-- LookupError +-- MemoryError +-- NameError +-- OSError +-- ReferenceError +-- RuntimeError +-- SyntaxError +-- SystemError +-- TypeError +-- ValueError +-- Warning BaseException 是所有异常的老祖宗，但很少会用到，通常我们只需要 Exception，比如自定义一个错误类型：
# 命名习惯一般以 Error 结尾 class CustomError(Exception): def __init__(self, message, status): # 这里最好把参数都放进去，之后会统一存在 e."><meta name=author content><link rel=canonical href=https://iamgodot.com/posts/exception-in-python/><link crossorigin=anonymous href=/assets/css/stylesheet.min.7cb1aaa4414c482febc7034a427761d087a2cf358f1be8f7beba5afc947b57d0.css integrity="sha256-fLGqpEFMSC/rxwNKQndh0IeizzWPG+j3vrpa/JR7V9A=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js integrity="sha256-uVus3DnjejMqn4g7Hni+Srwf3KK8HyZB9V4809q9TWE=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://iamgodot.com/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://iamgodot.com/icons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://iamgodot.com/icons/favicon-32x32.png><link rel=apple-touch-icon href=https://iamgodot.com/icons/apple-touch-icon.png><link rel=mask-icon href=https://iamgodot.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=preload as=style href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;700&family=Source+Code+Pro:wght@400;700&display=swap"><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;700&family=Source+Code+Pro:wght@400;700&display=swap" media=print onload='this.media="all"'><link rel=preconnect href=https://plausible.iamgodot.com><script defer data-domain=iamgodot.com src=https://plausible.iamgodot.com/js/plausible.js></script>
<script>window.plausible=window.plausible||function(){(window.plausible.q=window.plausible.q||[]).push(arguments)}</script><script></script><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-157042624-1","auto"),ga("send","pageview"))</script><meta property="og:title" content="Python 中的异常"><meta property="og:description" content="在 Python 中，EAFP 的风格很受青睐，这种写法能让代码更加简洁，还可以避免一些重复判断和多线程竞争的问题。为此，了解并熟练使用异常是很重要的。
异常类 首先来看一下 Python 内置的异常类（有省略）：
BaseException +-- SystemExit +-- KeyboardInterrupt +-- GeneratorExit +-- Exception +-- StopIteration +-- StopAsyncIteration +-- ArithmeticError +-- AssertionError +-- AttributeError +-- BufferError +-- EOFError +-- ImportError +-- LookupError +-- MemoryError +-- NameError +-- OSError +-- ReferenceError +-- RuntimeError +-- SyntaxError +-- SystemError +-- TypeError +-- ValueError +-- Warning BaseException 是所有异常的老祖宗，但很少会用到，通常我们只需要 Exception，比如自定义一个错误类型：
# 命名习惯一般以 Error 结尾 class CustomError(Exception): def __init__(self, message, status): # 这里最好把参数都放进去，之后会统一存在 e."><meta property="og:type" content="article"><meta property="og:url" content="https://iamgodot.com/posts/exception-in-python/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-09-15T18:02:18+08:00"><meta property="article:modified_time" content="2022-09-15T18:02:18+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Python 中的异常"><meta name=twitter:description content="在 Python 中，EAFP 的风格很受青睐，这种写法能让代码更加简洁，还可以避免一些重复判断和多线程竞争的问题。为此，了解并熟练使用异常是很重要的。
异常类 首先来看一下 Python 内置的异常类（有省略）：
BaseException +-- SystemExit +-- KeyboardInterrupt +-- GeneratorExit +-- Exception +-- StopIteration +-- StopAsyncIteration +-- ArithmeticError +-- AssertionError +-- AttributeError +-- BufferError +-- EOFError +-- ImportError +-- LookupError +-- MemoryError +-- NameError +-- OSError +-- ReferenceError +-- RuntimeError +-- SyntaxError +-- SystemError +-- TypeError +-- ValueError +-- Warning BaseException 是所有异常的老祖宗，但很少会用到，通常我们只需要 Exception，比如自定义一个错误类型：
# 命名习惯一般以 Error 结尾 class CustomError(Exception): def __init__(self, message, status): # 这里最好把参数都放进去，之后会统一存在 e."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://iamgodot.com/posts/"},{"@type":"ListItem","position":3,"name":"Python 中的异常","item":"https://iamgodot.com/posts/exception-in-python/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Python 中的异常","name":"Python 中的异常","description":"在 Python 中，EAFP 的风格很受青睐，这种写法能让代码更加简洁，还可以避免一些重复判断和多线程竞争的问题。为此，了解并熟练使用异常是很重要的。\n异常类 首先来看一下 Python 内置的异常类（有省略）：\nBaseException +-- SystemExit +-- KeyboardInterrupt +-- GeneratorExit +-- Exception +-- StopIteration +-- StopAsyncIteration +-- ArithmeticError +-- AssertionError +-- AttributeError +-- BufferError +-- EOFError +-- ImportError +-- LookupError +-- MemoryError +-- NameError +-- OSError +-- ReferenceError +-- RuntimeError +-- SyntaxError +-- SystemError +-- TypeError +-- ValueError +-- Warning BaseException 是所有异常的老祖宗，但很少会用到，通常我们只需要 Exception，比如自定义一个错误类型：\n# 命名习惯一般以 Error 结尾 class CustomError(Exception): def __init__(self, message, status): # 这里最好把参数都放进去，之后会统一存在 e.","keywords":["Python 捕获异常","Python 自定义异常","Python 抛出异常"],"articleBody":"在 Python 中，EAFP 的风格很受青睐，这种写法能让代码更加简洁，还可以避免一些重复判断和多线程竞争的问题。为此，了解并熟练使用异常是很重要的。\n异常类 首先来看一下 Python 内置的异常类（有省略）：\nBaseException +-- SystemExit +-- KeyboardInterrupt +-- GeneratorExit +-- Exception +-- StopIteration +-- StopAsyncIteration +-- ArithmeticError +-- AssertionError +-- AttributeError +-- BufferError +-- EOFError +-- ImportError +-- LookupError +-- MemoryError +-- NameError +-- OSError +-- ReferenceError +-- RuntimeError +-- SyntaxError +-- SystemError +-- TypeError +-- ValueError +-- Warning BaseException 是所有异常的老祖宗，但很少会用到，通常我们只需要 Exception，比如自定义一个错误类型：\n# 命名习惯一般以 Error 结尾 class CustomError(Exception): def __init__(self, message, status): # 这里最好把参数都放进去，之后会统一存在 e.args 中 super().__init__(message, status) self.message = message self.status = status 除此之外，有两种与 Exception 平级的异常需要我们注意，就是 SystemExit 和 KeyboardInterrupt。\nSystemExit 可以通过 sys.exit() 来触发，会让程序以特定的 Exit code 退出；而 KeyboardInterrupt 一般由 Ctrl-C 导致，正常情况下也会让 Interpreter 结束工作。\n这两种异常都会直接影响程序的执行退出，继承自 BaseException 可能也是为了和 Exception 做区分。比如 KeyboardInterrupt，因为过于不可控（任意发出的打断操作），即使通过异常处理可能也无法正常完成资源回收等操作，所以用注册 Signal handler 的方式来实现 Graceful shutdown 更加合适。\n另外，要避免用单独的 except 语句，因为默认针对的是 BaseException，会把上面两种异常都包含进去。\n抛出异常 抛出异常是很简单的，基本上只需要记住 raise 关键字，后面加上异常对象就好了。\n这里有个知识点是 raise 的时候也可以直接使用异常类型：\nIf it is a class, the exception instance will be obtained when needed by instantiating the class with no arguments.\n当然，初始化异常对象并且加入一些上下文信息会更有利于 Debug。\n在异常处理中，如果想重新抛出异常，只需要这样做：\ndef test_exception_chaining(): try: 1 / 0 except ZeroDivisionError as e: print('Trying to divide 1 by 0') raise e # 或者直接 raise 即可 最后要提的是 Exception chaining，可以理解为一个异常打印消息的优化，在文本中会显示更加清晰的异常链关系：\ndef test_exception_chaining(): try: 1 / 0 except ZeroDivisionError as e: raise ValueError from e 此时执行函数打印的错误栈会显示：\nTraceback (most recent call last): File \"/tmp/test.py\", line 3, in test_exception_chaining 1 / 0 ZeroDivisionError: division by zero The above exception was the direct cause of the following exception: Traceback (most recent call last): File \"/tmp/test.py\", line 37, in foo() File \"/tmp/test.py\", line 5, in test_exception_chaining raise ValueError from e ValueError 可以看到，消息中指明了 ZeroDivisionError 是导致 ValueError 的直接原因。\n在这种情况下，ValueError 的 __cause__ 属性会被设置为前面的 ZeroDivisionError 对象，而 __suppress_context__ 为 True。\n而如果我们不加 raise ValueError 后面的 from e，则 __supress_context__ 为 False，另一个属性 __context__ 会被设置为 ZeroDivisionError 对象。这是出现连环异常的默认处理，此时错误栈会显示：\nDuring handling of the above exception, another exception occurred:\n看上去就没有 Exception chaining 那么直观了。\n异常处理 Python 异常处理语句的完全体如下：\ndef test_var(var): try: assert isinstance(var, str) except AssertionError: print(f'{var} is not a string') finally: print('End test') else: print(f'{var} is a string') 只有存在至少一个 except，才可以使用 else 语句。如果不出现任何异常情况，在 try 中的代码执行完成之后，会继续执行 else。\n而 finally 很好理解，简单来说就是一定会执行：\nthe finally clause is executed in any event.\n具体可以分为下面几种情况：\n出现 Unhandle 的异常。 不论是 except 没有覆盖还是异常处理过程中又出现了新的异常，都会先完成 finally 的逻辑再抛出。 但是如果 finally 中直接 return/break/continue 了，则异常会被忽略掉。 未出现异常或者异常被成功 Handle。 不论是 try 还是 except 中的 return/break/continue，执行之前还是要先处理 finally 的逻辑。 同样，如果 finally 中直接退出了，那么也不会再继续之前的 try 或者 except。 总结一下就是 finally 最后一定会执行，而且优先级更高。\n虽然这套四连很好用，但是代码中写多了比较麻烦，也影响可读性。所幸还有一种更简洁的语法，就是 with。\n使用 with 在上下文管理器协议中，从 __exit__ 方法的参数中可以得到 with 块中执行语句可能抛出的 Exception，所以这里很适合做异常处理。\nclass ExceptionManager: def __init__(self, exception, handler): self.exception = exception self.handler = handler def __enter__(self): return self def __exit__(self, exc_type, exc_val, exc_tb): if exc_type == self.exception: self.handler(exc_val) return True return False 这里要注意 __exit__ 的返回值，如果布尔结果为 True，则异常不会继续抛出。\n利用内置的 contextlib 还可以这样实现：\nfrom contextlib import contextmanager @contextmanager def manage_exception(exception, handler): try: yield except exception as e: handler(e) 如果想忽略一些特定的异常：\nfrom contextlib import suppress with suppress(KeyError): d = {} print(d['foo']) 一些结论 在使用异常机制时，可以参考下面几点：\n提前考虑可能发生的异常，比如非法输入、网络或 I/O 错误等。 对于不合理的情况应当直接抛出异常，交给上层处理。 如果是底层函数，那么可以直接使用内置异常类型。 或者自定义内部异常，但是要注意和模块的层级匹配。 异常处理。 重试。推荐 Tenacity 这个库。 记录日志，还可以配合 Sentry 发出告警。 资源回收与回滚操作。比如关闭打开的文件、回滚数据库等。 返回值。 直接抛出异常。 使用默认值，如 False 或 -1。 根据异常返回对应的 HTTP Response，这在服务器应用中很常见。 兜底。总会发生意想不到的错误，为了保险起见最好多加一层处理。 离线任务：做好适当的回滚，不要 Block 其他任务，修复之后再手动触发。 在线应用：做好记录并返回错误响应，最重要的是不打断程序的正常运行。 References\nErrors and Exceptions - Python Docs Built-in Exceptions - Python Docs LBYL vs EAFP - RealPython Python 工匠： 异常处理的三个好习惯 ","wordCount":"475","inLanguage":"en","datePublished":"2022-09-15T18:02:18+08:00","dateModified":"2022-09-15T18:02:18+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://iamgodot.com/posts/exception-in-python/"},"publisher":{"@type":"Organization","name":"Godot's Blog - 个人生活分享","logo":{"@type":"ImageObject","url":"https://iamgodot.com/icons/favicon.ico"}}}</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=https://iamgodot.com accesskey=h title="Godot's Blog - 个人生活分享 (Alt + H)">Godot's Blog - 个人生活分享</a>
<span class=logo-switches></span></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Python 中的异常</h1><div class=post-meta><span title='2022-09-15 18:02:18 +0800 +0800'>09-15</span>&nbsp;·&nbsp;3 min</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%bc%82%e5%b8%b8%e7%b1%bb aria-label=异常类>异常类</a></li><li><a href=#%e6%8a%9b%e5%87%ba%e5%bc%82%e5%b8%b8 aria-label=抛出异常>抛出异常</a></li><li><a href=#%e5%bc%82%e5%b8%b8%e5%a4%84%e7%90%86 aria-label=异常处理>异常处理</a></li><li><a href=#%e4%bd%bf%e7%94%a8-with aria-label="使用 with">使用 with</a></li><li><a href=#%e4%b8%80%e4%ba%9b%e7%bb%93%e8%ae%ba aria-label=一些结论>一些结论</a></li></ul></div></details></div><div class=post-content><p>在 Python 中，<a href=https://docs.python.org/3/glossary.html#term-EAFP>EAFP</a> 的风格很受青睐，这种写法能让代码更加简洁，还可以避免一些重复判断和多线程竞争的问题。为此，了解并熟练使用异常是很重要的。</p><h1 id=异常类>异常类<a hidden class=anchor aria-hidden=true href=#异常类>#</a></h1><p>首先来看一下 Python 内置的<a href=https://docs.python.org/3/library/exceptions.html#exception-hierarchy>异常类</a>（有省略）：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-tex data-lang=tex><span style=display:flex><span>BaseException
</span></span><span style=display:flex><span> +-- SystemExit
</span></span><span style=display:flex><span> +-- KeyboardInterrupt
</span></span><span style=display:flex><span> +-- GeneratorExit
</span></span><span style=display:flex><span> +-- Exception
</span></span><span style=display:flex><span>      +-- StopIteration
</span></span><span style=display:flex><span>      +-- StopAsyncIteration
</span></span><span style=display:flex><span>      +-- ArithmeticError
</span></span><span style=display:flex><span>      +-- AssertionError
</span></span><span style=display:flex><span>      +-- AttributeError
</span></span><span style=display:flex><span>      +-- BufferError
</span></span><span style=display:flex><span>      +-- EOFError
</span></span><span style=display:flex><span>      +-- ImportError
</span></span><span style=display:flex><span>      +-- LookupError
</span></span><span style=display:flex><span>      +-- MemoryError
</span></span><span style=display:flex><span>      +-- NameError
</span></span><span style=display:flex><span>      +-- OSError
</span></span><span style=display:flex><span>      +-- ReferenceError
</span></span><span style=display:flex><span>      +-- RuntimeError
</span></span><span style=display:flex><span>      +-- SyntaxError
</span></span><span style=display:flex><span>      +-- SystemError
</span></span><span style=display:flex><span>      +-- TypeError
</span></span><span style=display:flex><span>      +-- ValueError
</span></span><span style=display:flex><span>      +-- Warning
</span></span></code></pre></div><p><code>BaseException</code> 是所有异常的老祖宗，但很少会用到，通常我们只需要 <code>Exception</code>，比如自定义一个错误类型：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># 命名习惯一般以 Error 结尾</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CustomError</span>(<span style=color:#a6e22e>Exception</span>):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(self, message, status):
</span></span><span style=display:flex><span>        <span style=color:#75715e># 这里最好把参数都放进去，之后会统一存在 e.args 中</span>
</span></span><span style=display:flex><span>        super()<span style=color:#f92672>.</span>__init__(message, status)
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>message <span style=color:#f92672>=</span> message
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>status <span style=color:#f92672>=</span> status
</span></span></code></pre></div><p>除此之外，有两种与 <code>Exception</code> 平级的异常需要我们注意，就是 <code>SystemExit</code> 和 <code>KeyboardInterrupt</code>。</p><p><code>SystemExit</code> 可以通过 <code>sys.exit()</code> 来触发，会让程序以特定的 Exit code 退出；而 <code>KeyboardInterrupt</code> 一般由 <code>Ctrl-C</code> 导致，正常情况下也会让 Interpreter 结束工作。</p><p>这两种异常都会直接影响程序的执行退出，继承自 <code>BaseException</code> 可能也是为了和 <code>Exception</code> 做区分。比如 <code>KeyboardInterrupt</code>，因为过于不可控（任意发出的打断操作），即使通过异常处理可能也无法正常完成资源回收等操作，所以用注册 Signal handler 的方式来实现 Graceful shutdown 更加合适。</p><p>另外，要避免用单独的 <code>except</code> 语句，因为默认针对的是 <code>BaseException</code>，会把上面两种异常都包含进去。</p><h1 id=抛出异常>抛出异常<a hidden class=anchor aria-hidden=true href=#抛出异常>#</a></h1><p>抛出异常是很简单的，基本上只需要记住 <code>raise</code> 关键字，后面加上异常对象就好了。</p><p>这里有个知识点是 <code>raise</code> 的时候也可以直接使用异常类型：</p><blockquote><p>If it is a class, the exception instance will be obtained when needed by instantiating the class with no arguments.</p></blockquote><p>当然，初始化异常对象并且加入一些上下文信息会更有利于 Debug。</p><p>在异常处理中，如果想重新抛出异常，只需要这样做：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>test_exception_chaining</span>():
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>        <span style=color:#ae81ff>1</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>except</span> <span style=color:#a6e22e>ZeroDivisionError</span> <span style=color:#66d9ef>as</span> e:
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#39;Trying to divide 1 by 0&#39;</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>raise</span> e  <span style=color:#75715e># 或者直接 raise 即可</span>
</span></span></code></pre></div><p>最后要提的是 <a href=https://docs.python.org/3/tutorial/errors.html#exception-chaining>Exception chaining</a>，可以理解为一个异常打印消息的优化，在文本中会显示更加清晰的异常链关系：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>test_exception_chaining</span>():
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>        <span style=color:#ae81ff>1</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>except</span> <span style=color:#a6e22e>ZeroDivisionError</span> <span style=color:#66d9ef>as</span> e:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>raise</span> <span style=color:#a6e22e>ValueError</span> <span style=color:#f92672>from</span> e
</span></span></code></pre></div><p>此时执行函数打印的错误栈会显示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-tex data-lang=tex><span style=display:flex><span>Traceback (most recent call last):
</span></span><span style=display:flex><span>  File &#34;/tmp/test.py&#34;, line 3, in test_exception_chaining
</span></span><span style=display:flex><span>    1 / 0
</span></span><span style=display:flex><span>ZeroDivisionError: division by zero
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>The above exception was the direct cause of the following exception:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Traceback (most recent call last):
</span></span><span style=display:flex><span>  File &#34;/tmp/test.py&#34;, line 37, in &lt;module&gt;
</span></span><span style=display:flex><span>    foo()
</span></span><span style=display:flex><span>  File &#34;/tmp/test.py&#34;, line 5, in test_exception_chaining
</span></span><span style=display:flex><span>    raise ValueError from e
</span></span><span style=display:flex><span>ValueError
</span></span></code></pre></div><p>可以看到，消息中指明了 <code>ZeroDivisionError</code> 是导致 <code>ValueError</code> 的直接原因。</p><p>在这种情况下，<code>ValueError</code> 的 <code>__cause__</code> 属性会被设置为前面的 <code>ZeroDivisionError</code> 对象，而 <code>__suppress_context__</code> 为 <code>True</code>。</p><p>而如果我们不加 <code>raise ValueError</code> 后面的 <code>from e</code>，则 <code>__supress_context__</code> 为 <code>False</code>，另一个属性 <code>__context__</code> 会被设置为 <code>ZeroDivisionError</code> 对象。这是出现连环异常的默认处理，此时错误栈会显示：</p><p><code>During handling of the above exception, another exception occurred:</code></p><p>看上去就没有 Exception chaining 那么直观了。</p><h1 id=异常处理>异常处理<a hidden class=anchor aria-hidden=true href=#异常处理>#</a></h1><p>Python 异常处理语句的完全体如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>test_var</span>(var):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>assert</span> isinstance(var, str)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>except</span> <span style=color:#a6e22e>AssertionError</span>:
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;</span><span style=color:#e6db74>{</span>var<span style=color:#e6db74>}</span><span style=color:#e6db74> is not a string&#39;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>finally</span>:
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#39;End test&#39;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;</span><span style=color:#e6db74>{</span>var<span style=color:#e6db74>}</span><span style=color:#e6db74> is a string&#39;</span>)
</span></span></code></pre></div><p>只有存在至少一个 <code>except</code>，才可以使用 <code>else</code> 语句。如果不出现任何异常情况，在 <code>try</code> 中的代码执行完成之后，会继续执行 <code>else</code>。</p><p>而 <code>finally</code> 很好理解，简单来说就是一定会执行：</p><blockquote><p>the <code>finally</code> clause is executed in any event.</p></blockquote><p>具体可以分为下面几种情况：</p><ul><li>出现 Unhandle 的异常。<ul><li>不论是 <code>except</code> 没有覆盖还是异常处理过程中又出现了新的异常，都会先完成 <code>finally</code> 的逻辑再抛出。</li><li>但是如果 <code>finally</code> 中直接 <code>return/break/continue</code> 了，则异常会被忽略掉。</li></ul></li><li>未出现异常或者异常被成功 Handle。<ul><li>不论是 <code>try</code> 还是 <code>except</code> 中的 <code>return/break/continue</code>，执行之前还是要先处理 <code>finally</code> 的逻辑。</li><li>同样，如果 <code>finally</code> 中直接退出了，那么也不会再继续之前的 <code>try</code> 或者 <code>except</code>。</li></ul></li></ul><p>总结一下就是 <code>finally</code> 最后一定会执行，而且优先级更高。</p><p>虽然这套四连很好用，但是代码中写多了比较麻烦，也影响可读性。所幸还有一种更简洁的语法，就是 <code>with</code>。</p><h1 id=使用-with>使用 with<a hidden class=anchor aria-hidden=true href=#使用-with>#</a></h1><p>在上下文管理器协议中，从 <code>__exit__</code> 方法的参数中可以得到 <code>with</code> 块中执行语句可能抛出的 Exception，所以这里很适合做异常处理。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ExceptionManager</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(self, exception, handler):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>exception <span style=color:#f92672>=</span> exception
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>handler <span style=color:#f92672>=</span> handler
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __enter__(self):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> self
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __exit__(self, exc_type, exc_val, exc_tb):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> exc_type <span style=color:#f92672>==</span> self<span style=color:#f92672>.</span>exception:
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>handler(exc_val)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>True</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>False</span>
</span></span></code></pre></div><p>这里要注意 <code>__exit__</code> 的返回值，如果布尔结果为 <code>True</code>，则异常不会继续抛出。</p><p>利用内置的 <code>contextlib</code> 还可以这样实现：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> contextlib <span style=color:#f92672>import</span> contextmanager
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@contextmanager</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>manage_exception</span>(exception, handler):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>yield</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>except</span> exception <span style=color:#66d9ef>as</span> e:
</span></span><span style=display:flex><span>        handler(e)
</span></span></code></pre></div><p>如果想忽略一些特定的异常：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> contextlib <span style=color:#f92672>import</span> suppress
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>with</span> suppress(<span style=color:#a6e22e>KeyError</span>):
</span></span><span style=display:flex><span>    d <span style=color:#f92672>=</span> {}
</span></span><span style=display:flex><span>    print(d[<span style=color:#e6db74>&#39;foo&#39;</span>])
</span></span></code></pre></div><h1 id=一些结论>一些结论<a hidden class=anchor aria-hidden=true href=#一些结论>#</a></h1><p>在使用异常机制时，可以参考下面几点：</p><ol><li>提前考虑可能发生的异常，比如非法输入、网络或 I/O 错误等。</li><li>对于不合理的情况应当直接抛出异常，交给上层处理。<ol><li>如果是底层函数，那么可以直接使用内置异常类型。</li><li>或者自定义内部异常，但是要注意和模块的层级匹配。</li></ol></li><li>异常处理。<ol><li>重试。推荐 <a href=https://github.com/jd/tenacity>Tenacity</a> 这个库。</li><li>记录日志，还可以配合 Sentry 发出告警。</li><li>资源回收与回滚操作。比如关闭打开的文件、回滚数据库等。</li></ol></li><li>返回值。<ol><li>直接抛出异常。</li><li>使用默认值，如 <code>False</code> 或 <code>-1</code>。</li><li>根据异常返回对应的 HTTP Response，这在服务器应用中很常见。</li></ol></li><li>兜底。总会发生意想不到的错误，为了保险起见最好多加一层处理。<ol><li>离线任务：做好适当的回滚，不要 Block 其他任务，修复之后再手动触发。</li><li>在线应用：做好记录并返回错误响应，最重要的是不打断程序的正常运行。</li></ol></li></ol><hr><p><em>References</em></p><ul><li><a href=https://docs.python.org/3/tutorial/errors.html>Errors and Exceptions - Python Docs</a></li><li><a href=https://docs.python.org/3/library/exceptions.html>Built-in Exceptions - Python Docs</a></li><li><a href=https://realpython.com/python-lbyl-vs-eafp/>LBYL vs EAFP - RealPython</a></li><li><a href=https://www.zlovezl.cn/articles/three-rituals-of-exceptions-handling/>Python 工匠： 异常处理的三个好习惯</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://iamgodot.com/tags/python/>python</a></li></ul><nav class=paginav><a class=prev href=https://iamgodot.com/posts/why-i-use-logseq/><span class=title>« Prev Page</span><br><span>我为什么开始用 Logseq</span></a>
<a class=next href=https://iamgodot.com/posts/source-code-of-python-import/><span class=title>Next Page »</span><br><span>Python Import 源码阅读</span></a></nav></footer><script src=https://giscus.app/client.js data-repo=iamgodot/godot-blog-comments data-repo-id="MDEwOlJlcG9zaXRvcnkzOTk0Nzk0MTY=" data-category=Announcements data-category-id=DIC_kwDOF8-SeM4CO3OX data-mapping=pathname data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=dark_dimmed data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2020-2023 <a href=https://iamgodot.com>Godot's Blog - 个人生活分享</a></span>
<span>| <a href=http://beian.miit.gov.cn/ target=_blank>京ICP备20005558号-2</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>