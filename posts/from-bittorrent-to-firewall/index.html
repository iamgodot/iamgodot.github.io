<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>From BitTorrent to Firewall | Godot&#39;s Blog</title>
<meta name="keywords" content="network">
<meta name="description" content="服务器能做什么？在 Awesome-Selfhosted 里可以找到上百种答案。如果带宽不算太小的话，那么 BT 下载是个不错的尝试。借着 No Time to Die 的上映我开始重温 007 系列，从皇家赌场到幽灵党，在服务器上的下载体验是很好的。
BitTorrent 在此之前，我基本上把 BT、种子、磁力、迅雷下载当成同一种东西。下载电影？先找种子或者磁力链接，打开迅雷下载，然后视速度决定要不要开个会员。
实际上这完全曲解了 BT 下载。
首先 BitTorrent 是一种网络协议。还记得计算机网络一开始就提到过除了 C/S 架构之外，还有 P2P(Peer-to-peer)，也就是网络中的各个节点都扮演了同等的角色，既是客户端也是服务器。BT 基于 P2P 实现了去中心化的文件分享，让网络数据的传输不再仅限于服务器的能力，而是共享带宽，每个人下载的同时也在上传，所以越多人参与速度就越快。
类似于 HTTP 和 FTP，BT 也是基于 TCP/IP 的一种应用层协议。基本上它是这么运作的：
我有一部电影，想把资源分享到网络，要先提供一个种子文件
种子文件实际上就是个文本文件，里面主要记录两部分信息
Trackers: 就是 Tracker 服务器的地址，这个服务器不是用来下载资源的，而是用于获取其他 Peers 的联系方式 Files: 一个视频文件会被（逻辑）划分为很多个虚拟分块，每块的索引和验证码都包含在这里 接下来我把种子文件发布出去，等待别人下载
这时候有人获取到种子了，于是开启了 BT 客户端下载
客户端先解析种子文件中的信息，找到 Tracker，然后询问有哪些 Peers
因为是第一个下载者，所以 Tracker 告知 Peer 目前只有我，也就是发布者
之后对方会尝试与我互连，然后根据 Files 信息交换数据，这里基本就是我上传给对方
下载的过程会以分块为单位进行，每块完成下载后会根据验证码再做校验
如果这时又有一个人开始下载，那么我和这第一个下载者都会贡献上传
随着更多用户的参与，（上传）下载的速度就会越来越快
可以发现，整个过程中 Tracker 是很关键的一步，如果没有有效的 Tracker 提供 Peers，后面的下载都无法开始。所以如果你的 BT 下载没有速度，首先要尝试多添加一些 Tracker 服务器，比如 TrackersList.">
<meta name="author" content="">
<link rel="canonical" href="https://iamgodot.com/posts/from-bittorrent-to-firewall/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.7cb1aaa4414c482febc7034a427761d087a2cf358f1be8f7beba5afc947b57d0.css" integrity="sha256-fLGqpEFMSC/rxwNKQndh0IeizzWPG&#43;j3vrpa/JR7V9A=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.e85ad0406048e8176e1c7661b25d5c69297ddfe41dc4124cf75ecb99a4f7b3d1.js" integrity="sha256-6FrQQGBI6BduHHZhsl1caSl93&#43;QdxBJM917LmaT3s9E="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://iamgodot.com/icons/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://iamgodot.com/icons/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://iamgodot.com/icons/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://iamgodot.com/icons/apple-touch-icon.png">
<link rel="mask-icon" href="https://iamgodot.com/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link rel="preload" as="style" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;700&family=Source+Code+Pro:wght@400;700&display=swap" />
<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;700&family=Source+Code+Pro:wght@400;700&display=swap" media="print" onload="this.media='all'">














    
        <link rel="preconnect" href="https://plausible.iamgodot.com">
    
        
        <script defer data-domain="iamgodot.com" src="https://plausible.iamgodot.com/js/plausible.js" ></script>

<!-- If you are using Content-Security-Policy, do not forget to add this code to your CSP : 
  script-src 'unsafe-inline' https://plausible.iamgodot.com
  connect-src 'unsafe-inline' https://plausible.iamgodot.com
  or just add the partial 'plausible_csp.html' to those 2 csp directives in your 'index.headers' file
-->



    
    <script>window.plausible = window.plausible || function() { (window.plausible.q = window.plausible.q || []).push(arguments) }</script>
    <script>
         
         
         
    </script>

    


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-157042624-1', 'auto');
	
	ga('send', 'pageview');
}
</script><meta property="og:title" content="From BitTorrent to Firewall" />
<meta property="og:description" content="服务器能做什么？在 Awesome-Selfhosted 里可以找到上百种答案。如果带宽不算太小的话，那么 BT 下载是个不错的尝试。借着 No Time to Die 的上映我开始重温 007 系列，从皇家赌场到幽灵党，在服务器上的下载体验是很好的。
BitTorrent 在此之前，我基本上把 BT、种子、磁力、迅雷下载当成同一种东西。下载电影？先找种子或者磁力链接，打开迅雷下载，然后视速度决定要不要开个会员。
实际上这完全曲解了 BT 下载。
首先 BitTorrent 是一种网络协议。还记得计算机网络一开始就提到过除了 C/S 架构之外，还有 P2P(Peer-to-peer)，也就是网络中的各个节点都扮演了同等的角色，既是客户端也是服务器。BT 基于 P2P 实现了去中心化的文件分享，让网络数据的传输不再仅限于服务器的能力，而是共享带宽，每个人下载的同时也在上传，所以越多人参与速度就越快。
类似于 HTTP 和 FTP，BT 也是基于 TCP/IP 的一种应用层协议。基本上它是这么运作的：
我有一部电影，想把资源分享到网络，要先提供一个种子文件
种子文件实际上就是个文本文件，里面主要记录两部分信息
Trackers: 就是 Tracker 服务器的地址，这个服务器不是用来下载资源的，而是用于获取其他 Peers 的联系方式 Files: 一个视频文件会被（逻辑）划分为很多个虚拟分块，每块的索引和验证码都包含在这里 接下来我把种子文件发布出去，等待别人下载
这时候有人获取到种子了，于是开启了 BT 客户端下载
客户端先解析种子文件中的信息，找到 Tracker，然后询问有哪些 Peers
因为是第一个下载者，所以 Tracker 告知 Peer 目前只有我，也就是发布者
之后对方会尝试与我互连，然后根据 Files 信息交换数据，这里基本就是我上传给对方
下载的过程会以分块为单位进行，每块完成下载后会根据验证码再做校验
如果这时又有一个人开始下载，那么我和这第一个下载者都会贡献上传
随着更多用户的参与，（上传）下载的速度就会越来越快
可以发现，整个过程中 Tracker 是很关键的一步，如果没有有效的 Tracker 提供 Peers，后面的下载都无法开始。所以如果你的 BT 下载没有速度，首先要尝试多添加一些 Tracker 服务器，比如 TrackersList." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://iamgodot.com/posts/from-bittorrent-to-firewall/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-12-20T17:00:00&#43;08:00" />
<meta property="article:modified_time" content="2021-12-20T17:00:00&#43;08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="From BitTorrent to Firewall"/>
<meta name="twitter:description" content="服务器能做什么？在 Awesome-Selfhosted 里可以找到上百种答案。如果带宽不算太小的话，那么 BT 下载是个不错的尝试。借着 No Time to Die 的上映我开始重温 007 系列，从皇家赌场到幽灵党，在服务器上的下载体验是很好的。
BitTorrent 在此之前，我基本上把 BT、种子、磁力、迅雷下载当成同一种东西。下载电影？先找种子或者磁力链接，打开迅雷下载，然后视速度决定要不要开个会员。
实际上这完全曲解了 BT 下载。
首先 BitTorrent 是一种网络协议。还记得计算机网络一开始就提到过除了 C/S 架构之外，还有 P2P(Peer-to-peer)，也就是网络中的各个节点都扮演了同等的角色，既是客户端也是服务器。BT 基于 P2P 实现了去中心化的文件分享，让网络数据的传输不再仅限于服务器的能力，而是共享带宽，每个人下载的同时也在上传，所以越多人参与速度就越快。
类似于 HTTP 和 FTP，BT 也是基于 TCP/IP 的一种应用层协议。基本上它是这么运作的：
我有一部电影，想把资源分享到网络，要先提供一个种子文件
种子文件实际上就是个文本文件，里面主要记录两部分信息
Trackers: 就是 Tracker 服务器的地址，这个服务器不是用来下载资源的，而是用于获取其他 Peers 的联系方式 Files: 一个视频文件会被（逻辑）划分为很多个虚拟分块，每块的索引和验证码都包含在这里 接下来我把种子文件发布出去，等待别人下载
这时候有人获取到种子了，于是开启了 BT 客户端下载
客户端先解析种子文件中的信息，找到 Tracker，然后询问有哪些 Peers
因为是第一个下载者，所以 Tracker 告知 Peer 目前只有我，也就是发布者
之后对方会尝试与我互连，然后根据 Files 信息交换数据，这里基本就是我上传给对方
下载的过程会以分块为单位进行，每块完成下载后会根据验证码再做校验
如果这时又有一个人开始下载，那么我和这第一个下载者都会贡献上传
随着更多用户的参与，（上传）下载的速度就会越来越快
可以发现，整个过程中 Tracker 是很关键的一步，如果没有有效的 Tracker 提供 Peers，后面的下载都无法开始。所以如果你的 BT 下载没有速度，首先要尝试多添加一些 Tracker 服务器，比如 TrackersList."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Posts",
      "item": "https://iamgodot.com/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "From BitTorrent to Firewall",
      "item": "https://iamgodot.com/posts/from-bittorrent-to-firewall/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "From BitTorrent to Firewall",
  "name": "From BitTorrent to Firewall",
  "description": "服务器能做什么？在 Awesome-Selfhosted 里可以找到上百种答案。如果带宽不算太小的话，那么 BT 下载是个不错的尝试。借着 No Time to Die 的上映我开始重温 007 系列，从皇家赌场到幽灵党，在服务器上的下载体验是很好的。\nBitTorrent 在此之前，我基本上把 BT、种子、磁力、迅雷下载当成同一种东西。下载电影？先找种子或者磁力链接，打开迅雷下载，然后视速度决定要不要开个会员。\n实际上这完全曲解了 BT 下载。\n首先 BitTorrent 是一种网络协议。还记得计算机网络一开始就提到过除了 C/S 架构之外，还有 P2P(Peer-to-peer)，也就是网络中的各个节点都扮演了同等的角色，既是客户端也是服务器。BT 基于 P2P 实现了去中心化的文件分享，让网络数据的传输不再仅限于服务器的能力，而是共享带宽，每个人下载的同时也在上传，所以越多人参与速度就越快。\n类似于 HTTP 和 FTP，BT 也是基于 TCP/IP 的一种应用层协议。基本上它是这么运作的：\n我有一部电影，想把资源分享到网络，要先提供一个种子文件\n种子文件实际上就是个文本文件，里面主要记录两部分信息\nTrackers: 就是 Tracker 服务器的地址，这个服务器不是用来下载资源的，而是用于获取其他 Peers 的联系方式 Files: 一个视频文件会被（逻辑）划分为很多个虚拟分块，每块的索引和验证码都包含在这里 接下来我把种子文件发布出去，等待别人下载\n这时候有人获取到种子了，于是开启了 BT 客户端下载\n客户端先解析种子文件中的信息，找到 Tracker，然后询问有哪些 Peers\n因为是第一个下载者，所以 Tracker 告知 Peer 目前只有我，也就是发布者\n之后对方会尝试与我互连，然后根据 Files 信息交换数据，这里基本就是我上传给对方\n下载的过程会以分块为单位进行，每块完成下载后会根据验证码再做校验\n如果这时又有一个人开始下载，那么我和这第一个下载者都会贡献上传\n随着更多用户的参与，（上传）下载的速度就会越来越快\n可以发现，整个过程中 Tracker 是很关键的一步，如果没有有效的 Tracker 提供 Peers，后面的下载都无法开始。所以如果你的 BT 下载没有速度，首先要尝试多添加一些 Tracker 服务器，比如 TrackersList.",
  "keywords": [
    "network"
  ],
  "articleBody": "服务器能做什么？在 Awesome-Selfhosted 里可以找到上百种答案。如果带宽不算太小的话，那么 BT 下载是个不错的尝试。借着 No Time to Die 的上映我开始重温 007 系列，从皇家赌场到幽灵党，在服务器上的下载体验是很好的。\nBitTorrent 在此之前，我基本上把 BT、种子、磁力、迅雷下载当成同一种东西。下载电影？先找种子或者磁力链接，打开迅雷下载，然后视速度决定要不要开个会员。\n实际上这完全曲解了 BT 下载。\n首先 BitTorrent 是一种网络协议。还记得计算机网络一开始就提到过除了 C/S 架构之外，还有 P2P(Peer-to-peer)，也就是网络中的各个节点都扮演了同等的角色，既是客户端也是服务器。BT 基于 P2P 实现了去中心化的文件分享，让网络数据的传输不再仅限于服务器的能力，而是共享带宽，每个人下载的同时也在上传，所以越多人参与速度就越快。\n类似于 HTTP 和 FTP，BT 也是基于 TCP/IP 的一种应用层协议。基本上它是这么运作的：\n我有一部电影，想把资源分享到网络，要先提供一个种子文件\n种子文件实际上就是个文本文件，里面主要记录两部分信息\nTrackers: 就是 Tracker 服务器的地址，这个服务器不是用来下载资源的，而是用于获取其他 Peers 的联系方式 Files: 一个视频文件会被（逻辑）划分为很多个虚拟分块，每块的索引和验证码都包含在这里 接下来我把种子文件发布出去，等待别人下载\n这时候有人获取到种子了，于是开启了 BT 客户端下载\n客户端先解析种子文件中的信息，找到 Tracker，然后询问有哪些 Peers\n因为是第一个下载者，所以 Tracker 告知 Peer 目前只有我，也就是发布者\n之后对方会尝试与我互连，然后根据 Files 信息交换数据，这里基本就是我上传给对方\n下载的过程会以分块为单位进行，每块完成下载后会根据验证码再做校验\n如果这时又有一个人开始下载，那么我和这第一个下载者都会贡献上传\n随着更多用户的参与，（上传）下载的速度就会越来越快\n可以发现，整个过程中 Tracker 是很关键的一步，如果没有有效的 Tracker 提供 Peers，后面的下载都无法开始。所以如果你的 BT 下载没有速度，首先要尝试多添加一些 Tracker 服务器，比如 TrackersList.\n为了避免 Tracker 成为瓶颈，又出现了 DHT(Distributed Hash Table) 来帮助 Peers 的寻找：\n在不需要服务器的情况下，每个客户端负责一个小范围的路由，并负责存储一小部分数据，从而实现整个 DHT 网络的寻址和存储。使用支持该技术的 BT 下载软件，用户无需连上 Tracker 就可以下载，因为软件会在 DHT 网络中寻找下载同一文件的其他用户并与之通讯，开始下载任务。\n这一切看起来都很（过于）理想：人人为我，我为人人。但是事实从来没有如此美好。\nBreaking Rules 首先在国内的网络环境中，BT 的使用就已经打折扣了：\n家庭网络一般都没有公网 IP 上传速度远小于下载速度（对带宽经济，但对于 BT 并不是好事） ISP 的干扰，比如针对 BT 数据包的干扰 其次就是流氓下载软件野蛮地改变了 BT 平等分享的初衷，比如迅雷。那么迅雷是如何打破规则的呢？简单来说，它在下载的时候老老实实享受其他用户的上传，等到分享时却只提供资源给自家用户，俗称吸血。不仅如此，迅雷还会维护单独的服务器，这样下载既 From peer 又 From server，也就是 P2SP，速度自然超过普通 BT 软件，同时还让人感觉很多资源只有迅雷才下得动。至于会员专享什么的，把一开始设的限制（比如连接其他 Peer 的数量）解除掉就好了，剩下的就是大肆捞钱。\n国内类似的吸血下载软件不少，但基本以迅雷为首。这么多年积累下来，就算大家觉得过分可能也无奈了，不用迅雷实在是下载不了啊。话虽如此，该抵制的还是要抵制，至少我已经从（多年前的）迅雷会员变为 BT 共产主义者了。\n最后，很多人使用 BT 也常常不遵守基本原则，比如关闭上传、下载完之后立刻删除种子资源。这也导致了很多软件增加了针对不良使用习惯的用户的限制，还出现了 PT(Private Tracker) 下载，简单讲就是在一个私密的圈子内分享资源下载，保证每个 Peer 的上传贡献。\n一个良好的网络环境既离不开硬性限制，也需要每个人的自我约束。更重要的前提是，打破黑盒，大家了解到事情背后的真相才有可能做出正确的决定。\nQbittorrent 抛弃了迅雷怎么办？其实好的选择有很多，比如 Windows 上的 IDM，或者开源的 Motrix, qbittorrent 等等。\n对于 Linux 来说，本地使用我觉得 Motrix 很不错，支持 AppImage，界面好看，还能自动更新各种 TrackerList，总之就是省心。而服务器部署我选择了 qbittorrent，GitHub 上面的文档很详尽，用 Docker 部署非常简单。\n这里要提一下，一开始使用最好先下个热门资源确认 BT 可以正常工作，比如 Ubuntu 的镜像文件。\n说回 qbittorrent，虽然不像 Motrix 可以自动更新 Trackers，但是它集成了种子的搜索功能（基本是国外资源），还有强大的 RSS 订阅。\n我的服务器是 5M 带宽，但腾讯云的出入网计算方式不太一样，对于入网速度，小于 5M 的带宽都按照 10M 计算。即便如此，下载速度还是超过了应有的限制，也许还有服务器的网络质量加成吧。\nFirewall 下着下着我感到很奇怪，因为 qbt 是用到了几个端口的，比如 UI 和下载，而下载的 6881 端口并没有在安全组开放啊，为什么还能正常使用？\n先用 nmap 测试下：\nnmap -p 6881 server 显示端口 filtered，确实是被防火墙拦住了没错。那是怎么做到的，BT 可以穿越防火墙？\n一番搜索之后我找到了答案，主要还是不太了解防火墙的工作机制：\n首先如果设置了端口禁止入网，那么外网肯定是无法向端口开启连接的 但是如果端口可以出网就不一定了，这时端口可以主动建立连接 之后外面再返回的数据包就可以穿过防火墙了 以上针对的是 Stateful firewall 的情况，也就是防火墙会跟踪并维护所有的网络连接，如果一个连接已经建立，那么即使规则不允许端口入网，数据仍然是可以正常传递的。\n再看下腾讯云的安全组介绍：\n安全组是一种虚拟防火墙，具备有状态的数据包过滤功能，…\n果然是有状态的。\n不如再做个实验好了。因为家里没有公网，所以又临时开了台 vultr 服务器。先在腾讯云上监听端口：\nnc -l -p 6881 然后从 vultr 尝试连接：\nnc tecent_server_ip 6881 显示超时，因为端口被 filtered，没问题。再在 vultr 上监听：\nnc -l -p 8888 从腾讯云主动发起连接：\nnc -p 6881 vultr_server_ip 8888 果然双向可以正常通信。所以 qbittorrent 才能正常下载啊。\nReferences\nBitTorrent - Wikipedia\nPT 下载 - Wikipedia\nP2SP - Wikipedia\nStateful firewall\nMotrix\nQbittorrent - GitHub\n为什么国内 BT 环境如此恶劣？ - 知乎\n",
  "wordCount" : "249",
  "inLanguage": "en",
  "datePublished": "2021-12-20T17:00:00+08:00",
  "dateModified": "2021-12-20T17:00:00+08:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://iamgodot.com/posts/from-bittorrent-to-firewall/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Godot's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://iamgodot.com/icons/favicon.ico"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://iamgodot.com" accesskey="h" title="Godot&#39;s Blog (Alt + H)">Godot&#39;s Blog</a>
            <span class="logo-switches">
            </span>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      From BitTorrent to Firewall
    </h1>
    <div class="post-meta"><span title='2021-12-20 17:00:00 +0800 CST'>12-20</span>&nbsp;·&nbsp;2 min

</div>
  </header> <div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#bittorrent" aria-label="BitTorrent">BitTorrent</a></li>
                <li>
                    <a href="#breaking-rules" aria-label="Breaking Rules">Breaking Rules</a></li>
                <li>
                    <a href="#qbittorrent" aria-label="Qbittorrent">Qbittorrent</a></li>
                <li>
                    <a href="#firewall" aria-label="Firewall">Firewall</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>服务器能做什么？在 <a href="https://github.com/awesome-selfhosted/awesome-selfhosted">Awesome-Selfhosted</a> 里可以找到上百种答案。如果带宽不算太小的话，那么 BT 下载是个不错的尝试。借着 <a href="https://movie.douban.com/subject/20276229/">No Time to Die</a> 的上映我开始重温 007 系列，从皇家赌场到幽灵党，在服务器上的下载体验是很好的。</p>
<h1 id="bittorrent">BitTorrent<a hidden class="anchor" aria-hidden="true" href="#bittorrent">#</a></h1>
<p>在此之前，我基本上把 BT、种子、磁力、迅雷下载当成同一种东西。下载电影？先找种子或者磁力链接，打开迅雷下载，然后视速度决定要不要开个会员。</p>
<p>实际上这完全曲解了 BT 下载。</p>
<p>首先 BitTorrent 是一种网络协议。还记得计算机网络一开始就提到过除了 C/S 架构之外，还有 P2P(Peer-to-peer)，也就是网络中的各个节点都扮演了同等的角色，既是客户端也是服务器。BT 基于 P2P 实现了去中心化的文件分享，让网络数据的传输不再仅限于服务器的能力，而是共享带宽，每个人下载的同时也在上传，所以越多人参与速度就越快。</p>
<p>类似于 HTTP 和 FTP，BT 也是基于 TCP/IP 的一种应用层协议。基本上它是这么运作的：</p>
<ul>
<li>
<p>我有一部电影，想把资源分享到网络，要先提供一个种子文件</p>
</li>
<li>
<p>种子文件实际上就是个文本文件，里面主要记录两部分信息</p>
<ul>
<li>Trackers: 就是 Tracker 服务器的地址，这个服务器不是用来下载资源的，而是用于获取其他 Peers 的联系方式</li>
<li>Files: 一个视频文件会被（逻辑）划分为很多个虚拟分块，每块的索引和验证码都包含在这里</li>
</ul>
</li>
<li>
<p>接下来我把种子文件发布出去，等待别人下载</p>
</li>
<li>
<p>这时候有人获取到种子了，于是开启了 BT 客户端下载</p>
</li>
<li>
<p>客户端先解析种子文件中的信息，找到 Tracker，然后询问有哪些 Peers</p>
</li>
<li>
<p>因为是第一个下载者，所以 Tracker 告知 Peer 目前只有我，也就是发布者</p>
</li>
<li>
<p>之后对方会尝试与我互连，然后根据 Files 信息交换数据，这里基本就是我上传给对方</p>
</li>
<li>
<p>下载的过程会以分块为单位进行，每块完成下载后会根据验证码再做校验</p>
</li>
<li>
<p>如果这时又有一个人开始下载，那么我和这第一个下载者都会贡献上传</p>
</li>
<li>
<p>随着更多用户的参与，（上传）下载的速度就会越来越快</p>
</li>
</ul>
<p>可以发现，整个过程中 Tracker 是很关键的一步，如果没有有效的 Tracker 提供 Peers，后面的下载都无法开始。所以如果你的 BT 下载没有速度，首先要尝试多添加一些 Tracker 服务器，比如 <a href="https://trackerslist.com/#/zh">TrackersList</a>.</p>
<p>为了避免 Tracker 成为瓶颈，又出现了 DHT(Distributed Hash Table) 来帮助 Peers 的寻找：</p>
<blockquote>
<p>在不需要服务器的情况下，每个客户端负责一个小范围的路由，并负责存储一小部分数据，从而实现整个 DHT 网络的寻址和存储。使用支持该技术的 BT 下载软件，用户无需连上 Tracker 就可以下载，因为软件会在 DHT 网络中寻找下载同一文件的其他用户并与之通讯，开始下载任务。</p>
</blockquote>
<p>这一切看起来都很（过于）理想：人人为我，我为人人。但是事实从来没有如此美好。</p>
<h1 id="breaking-rules">Breaking Rules<a hidden class="anchor" aria-hidden="true" href="#breaking-rules">#</a></h1>
<p>首先在国内的网络环境中，BT 的使用就已经打折扣了：</p>
<ul>
<li>家庭网络一般都没有公网 IP</li>
<li>上传速度远小于下载速度（对带宽经济，但对于 BT 并不是好事）</li>
<li>ISP 的干扰，比如针对 BT 数据包的干扰</li>
</ul>
<p>其次就是流氓下载软件野蛮地改变了 BT 平等分享的初衷，比如迅雷。那么迅雷是如何打破规则的呢？简单来说，它在下载的时候老老实实享受其他用户的上传，等到分享时却只提供资源给自家用户，俗称吸血。不仅如此，迅雷还会维护单独的服务器，这样下载既 From peer 又 From server，也就是 P2SP，速度自然超过普通 BT 软件，同时还让人感觉很多资源只有迅雷才下得动。至于会员专享什么的，把一开始设的限制（比如连接其他 Peer 的数量）解除掉就好了，剩下的就是大肆捞钱。</p>
<p>国内类似的吸血下载软件不少，但基本以迅雷为首。这么多年积累下来，就算大家觉得过分可能也无奈了，不用迅雷实在是下载不了啊。话虽如此，该抵制的还是要抵制，至少我已经从（多年前的）迅雷会员变为 BT 共产主义者了。</p>
<p>最后，很多人使用 BT 也常常不遵守基本原则，比如关闭上传、下载完之后立刻删除种子资源。这也导致了很多软件增加了针对不良使用习惯的用户的限制，还出现了 PT(Private Tracker) 下载，简单讲就是在一个私密的圈子内分享资源下载，保证每个 Peer 的上传贡献。</p>
<p>一个良好的网络环境既离不开硬性限制，也需要每个人的自我约束。更重要的前提是，打破黑盒，大家了解到事情背后的真相才有可能做出正确的决定。</p>
<h1 id="qbittorrent">Qbittorrent<a hidden class="anchor" aria-hidden="true" href="#qbittorrent">#</a></h1>
<p>抛弃了迅雷怎么办？其实好的选择有很多，比如 Windows 上的 <a href="https://www.internetdownloadmanager.com/">IDM</a>，或者开源的 Motrix, qbittorrent 等等。</p>
<p>对于 Linux 来说，本地使用我觉得 Motrix 很不错，支持 AppImage，界面好看，还能自动更新各种 TrackerList，总之就是省心。而服务器部署我选择了 qbittorrent，GitHub 上面的文档很详尽，用 Docker 部署非常简单。</p>
<p>这里要提一下，一开始使用最好先下个热门资源确认 BT 可以正常工作，比如 <a href="https://releases.ubuntu.com/20.10/ubuntu-20.10-desktop-amd64.iso.torrent">Ubuntu 的镜像文件</a>。</p>
<p>说回 qbittorrent，虽然不像 Motrix 可以自动更新 Trackers，但是它集成了种子的搜索功能（基本是国外资源），还有强大的 RSS 订阅。</p>
<p>我的服务器是 5M 带宽，但腾讯云的出入网计算方式不太一样，对于入网速度，小于 5M 的带宽都按照 10M 计算。即便如此，下载速度还是超过了应有的限制，也许还有服务器的网络质量加成吧。</p>
<h1 id="firewall">Firewall<a hidden class="anchor" aria-hidden="true" href="#firewall">#</a></h1>
<p>下着下着我感到很奇怪，因为 qbt 是用到了几个端口的，比如 UI 和下载，而下载的 6881 端口并没有在安全组开放啊，为什么还能正常使用？</p>
<p>先用 nmap 测试下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>nmap -p <span style="color:#ae81ff">6881</span> server
</span></span></code></pre></div><p>显示端口 filtered，确实是被防火墙拦住了没错。那是怎么做到的，BT 可以穿越防火墙？</p>
<p>一番搜索之后我找到了答案，主要还是不太了解防火墙的工作机制：</p>
<ul>
<li>首先如果设置了端口禁止入网，那么外网肯定是无法向端口开启连接的</li>
<li>但是如果端口可以出网就不一定了，这时端口可以主动建立连接</li>
<li>之后外面再返回的数据包就可以穿过防火墙了</li>
</ul>
<p>以上针对的是 Stateful firewall 的情况，也就是防火墙会跟踪并维护所有的网络连接，如果一个连接已经建立，那么即使规则不允许端口入网，数据仍然是可以正常传递的。</p>
<p>再看下<a href="https://cloud.tencent.com/document/product/213/12452">腾讯云的安全组介绍</a>：</p>
<blockquote>
<p>安全组是一种虚拟防火墙，具备有状态的数据包过滤功能，&hellip;</p>
</blockquote>
<p>果然是有状态的。</p>
<p>不如再做个实验好了。因为家里没有公网，所以又临时开了台 vultr 服务器。先在腾讯云上监听端口：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>nc -l -p <span style="color:#ae81ff">6881</span>
</span></span></code></pre></div><p>然后从 vultr 尝试连接：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>nc tecent_server_ip <span style="color:#ae81ff">6881</span>
</span></span></code></pre></div><p>显示超时，因为端口被 filtered，没问题。再在 vultr 上监听：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>nc -l -p <span style="color:#ae81ff">8888</span>
</span></span></code></pre></div><p>从腾讯云主动发起连接：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>nc -p <span style="color:#ae81ff">6881</span> vultr_server_ip <span style="color:#ae81ff">8888</span>
</span></span></code></pre></div><p>果然双向可以正常通信。所以 qbittorrent 才能正常下载啊。</p>
<hr>
<p><em>References</em></p>
<ul>
<li>
<p><a href="https://zh.wikipedia.org/wiki/BitTorrent_(%E5%8D%8F%E8%AE%AE)">BitTorrent - Wikipedia</a></p>
</li>
<li>
<p><a href="https://zh.wikipedia.org/wiki/PT%E4%B8%8B%E8%BC%89">PT 下载 - Wikipedia</a></p>
</li>
<li>
<p><a href="https://zh.wikipedia.org/wiki/P2SP">P2SP - Wikipedia</a></p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Stateful_firewall">Stateful firewall</a></p>
</li>
<li>
<p><a href="https://motrix.app/">Motrix</a></p>
</li>
<li>
<p><a href="https://github.com/qbittorrent/qBittorrent">Qbittorrent - GitHub</a></p>
</li>
<li>
<p><a href="https://zhuanlan.zhihu.com/p/87193566">为什么国内 BT 环境如此恶劣？ - 知乎</a></p>
</li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://iamgodot.com/tags/network/">network</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://iamgodot.com/posts/ssh-port-forwarding/">
    <span class="title">« Prev Page</span>
    <br>
    <span>关于 SSH 端口转发</span>
  </a>
  <a class="next" href="https://iamgodot.com/posts/edyth/">
    <span class="title">Next Page »</span>
    <br>
    <span>Even Dead, You&#39;re The Hero</span>
  </a>
</nav>

  </footer>
<script src="https://giscus.app/client.js"
        data-repo="iamgodot/godot-blog-comments"
        data-repo-id="MDEwOlJlcG9zaXRvcnkzOTk0Nzk0MTY="
        data-category="Announcements"
        data-category-id="DIC_kwDOF8-SeM4CO3OX"
        data-mapping="pathname"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="top"
        data-theme="dark_dimmed"
        data-lang="zh-CN"
        data-loading="lazy"
        crossorigin="anonymous"
        async>
</script>


</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2020-2022 <a href="https://iamgodot.com">Godot&#39;s Blog</a></span>
    <span>
        | <a href="http://beian.miit.gov.cn/" target="_blank">京ICP备20005558号-2</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = 'copy';

        function copyingDone() {
            copybutton.innerText = 'copied!';
            setTimeout(() => {
                copybutton.innerText = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
