<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Record Terminal as GIF | Godot's Blog</title><meta name=keywords content="project,python"><meta name=description content="这几天在做一个 CLI 项目，因为涉及到命令行操作，所以想录制一段 GIF 放在 README 中展示。
印象里这种工具都是 JS 写的，但搜了搜居然发现有个 Python 的实现：asciinema
用法很简单，就是安装好之后在命令行执行 asciinema rec 便会启动一个新的 Shell 并开始录制，录制的时候就像正常使用 Terminal 一样即可，完成之后按 Ctrl-D 或者 Exit 退出，asciinema 会把录制好的 cast 文件保存到本地，也可以选择上传到他们的网站：asciinema.org.
那么 cast 文件是什么，又怎样得到 GIF 呢？其实这是 asciinema 自己定义的一种文件格式：
A CAST file is a record of a terminal session recorded using asciinema, an open source terminal recording program. It contains a JSON-formatted header and a timestamped record of the text typed and printed during a terminal session."><meta name=author content><link rel=canonical href=https://iamgodot.com/posts/record-terminal/><link crossorigin=anonymous href=/assets/css/stylesheet.min.7cb1aaa4414c482febc7034a427761d087a2cf358f1be8f7beba5afc947b57d0.css integrity="sha256-fLGqpEFMSC/rxwNKQndh0IeizzWPG+j3vrpa/JR7V9A=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js integrity="sha256-uVus3DnjejMqn4g7Hni+Srwf3KK8HyZB9V4809q9TWE=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://iamgodot.com/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://iamgodot.com/icons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://iamgodot.com/icons/favicon-32x32.png><link rel=apple-touch-icon href=https://iamgodot.com/icons/apple-touch-icon.png><link rel=mask-icon href=https://iamgodot.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=preload as=style href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;700&family=Source+Code+Pro:wght@400;700&display=swap"><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;700&family=Source+Code+Pro:wght@400;700&display=swap" media=print onload='this.media="all"'><link rel=preconnect href=https://plausible.iamgodot.com><script defer data-domain=iamgodot.com src=https://plausible.iamgodot.com/js/plausible.js></script>
<script>window.plausible=window.plausible||function(){(window.plausible.q=window.plausible.q||[]).push(arguments)}</script><script></script><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-157042624-1","auto"),ga("send","pageview"))</script><meta property="og:title" content="Record Terminal as GIF"><meta property="og:description" content="这几天在做一个 CLI 项目，因为涉及到命令行操作，所以想录制一段 GIF 放在 README 中展示。
印象里这种工具都是 JS 写的，但搜了搜居然发现有个 Python 的实现：asciinema
用法很简单，就是安装好之后在命令行执行 asciinema rec 便会启动一个新的 Shell 并开始录制，录制的时候就像正常使用 Terminal 一样即可，完成之后按 Ctrl-D 或者 Exit 退出，asciinema 会把录制好的 cast 文件保存到本地，也可以选择上传到他们的网站：asciinema.org.
那么 cast 文件是什么，又怎样得到 GIF 呢？其实这是 asciinema 自己定义的一种文件格式：
A CAST file is a record of a terminal session recorded using asciinema, an open source terminal recording program. It contains a JSON-formatted header and a timestamped record of the text typed and printed during a terminal session."><meta property="og:type" content="article"><meta property="og:url" content="https://iamgodot.com/posts/record-terminal/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-11-07T21:35:44+08:00"><meta property="article:modified_time" content="2021-11-07T21:35:44+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Record Terminal as GIF"><meta name=twitter:description content="这几天在做一个 CLI 项目，因为涉及到命令行操作，所以想录制一段 GIF 放在 README 中展示。
印象里这种工具都是 JS 写的，但搜了搜居然发现有个 Python 的实现：asciinema
用法很简单，就是安装好之后在命令行执行 asciinema rec 便会启动一个新的 Shell 并开始录制，录制的时候就像正常使用 Terminal 一样即可，完成之后按 Ctrl-D 或者 Exit 退出，asciinema 会把录制好的 cast 文件保存到本地，也可以选择上传到他们的网站：asciinema.org.
那么 cast 文件是什么，又怎样得到 GIF 呢？其实这是 asciinema 自己定义的一种文件格式：
A CAST file is a record of a terminal session recorded using asciinema, an open source terminal recording program. It contains a JSON-formatted header and a timestamped record of the text typed and printed during a terminal session."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://iamgodot.com/posts/"},{"@type":"ListItem","position":3,"name":"Record Terminal as GIF","item":"https://iamgodot.com/posts/record-terminal/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Record Terminal as GIF","name":"Record Terminal as GIF","description":"这几天在做一个 CLI 项目，因为涉及到命令行操作，所以想录制一段 GIF 放在 README 中展示。\n印象里这种工具都是 JS 写的，但搜了搜居然发现有个 Python 的实现：asciinema\n用法很简单，就是安装好之后在命令行执行 asciinema rec 便会启动一个新的 Shell 并开始录制，录制的时候就像正常使用 Terminal 一样即可，完成之后按 Ctrl-D 或者 Exit 退出，asciinema 会把录制好的 cast 文件保存到本地，也可以选择上传到他们的网站：asciinema.org.\n那么 cast 文件是什么，又怎样得到 GIF 呢？其实这是 asciinema 自己定义的一种文件格式：\nA CAST file is a record of a terminal session recorded using asciinema, an open source terminal recording program. It contains a JSON-formatted header and a timestamped record of the text typed and printed during a terminal session.","keywords":["project","python"],"articleBody":"这几天在做一个 CLI 项目，因为涉及到命令行操作，所以想录制一段 GIF 放在 README 中展示。\n印象里这种工具都是 JS 写的，但搜了搜居然发现有个 Python 的实现：asciinema\n用法很简单，就是安装好之后在命令行执行 asciinema rec 便会启动一个新的 Shell 并开始录制，录制的时候就像正常使用 Terminal 一样即可，完成之后按 Ctrl-D 或者 Exit 退出，asciinema 会把录制好的 cast 文件保存到本地，也可以选择上传到他们的网站：asciinema.org.\n那么 cast 文件是什么，又怎样得到 GIF 呢？其实这是 asciinema 自己定义的一种文件格式：\nA CAST file is a record of a terminal session recorded using asciinema, an open source terminal recording program. It contains a JSON-formatted header and a timestamped record of the text typed and printed during a terminal session.\n文件内容大概是这个样子的：\n{\"version\": 2, \"width\": 124, \"height\": 63, \"timestamp\": 1636292616, \"env\": {\"SHELL\": \"/usr/bin/zsh\", \"TERM\": \"screen-256color\"}} [1.538309, \"o\", \"#\"] [1.915683, \"o\", \"\\b# \"] [2.335422, \"o\", \"l\"] [2.405338, \"o\", \"e\"] [2.524792, \"o\", \"t\"] [3.010565, \"o\", \"'\"] [3.13154, \"o\", \"s\"] 就像描述里说的，第一行是 JSON 格式的 header，里面存放了一些 Terminal 的元信息，比如尺寸和环境变量。下面的每一行数据都包含了时间戳和对应的终端打印信息，也就是在录制的时候键入的命令以及输出。\n对于 cast 文件，还可以直接用 asciinema 在终端回放录制的内容，比如 asciinema play -i 2 demo.cast 可以以两倍速播放。\n从官方 Issue 看，asciinema 本身目前还不支持直接导出 GIF 文件，不过其他的工具应运而生，比如：asciicast2gif.\n这个工具主要是用 JS 来解析 cast 文件并且生成若干张 PNG 图片，再调用 ImageMagick 和 gifsicle 这两个工具合成出最终的 GIF 文件：\nasciicast2gif shell script parses command line arguments and executes Node.js script (main.js). main.js loads asciicast (either from remote URL or local filesystem), generates text representation of the screen for each frame using asciinema-player’s virtual terminal emulator, and sends it to PhantomJS-based renderer script (renderer.js), which saves PNG screenshots to a temporary directory. Finally, main.js calls ImageMagick’s convert on these PNG images to construct GIF animation, also piping it to gifsicle to get the final, optimized GIF file.\n我不想在本地用 NPM 安装，所以选择了他们的 Docker 镜像试用，结果却没有想象中的顺利。原因大概是录制的时间较长（其实也就几分钟），生成的 cast 文件有 27K 左右，尝试渲染之后报错。在 Issue 查到是由于图片数量太多，gifsicle 合成失败。\n不成熟的工具用起来就是不顺手，正在纠结要不要进坑，又发现了一个在线转换 cast 为 gif 的网站：gifcast.\n试了一下异常顺利，而且网页的好处是可以预览各种 Theme 的效果，如下图：\n可能是 GIF 比较大，直接把图床的 Link 放到 README 里面加载得太慢，于是我还是选择把文件放到 REPO 里面并用 Relative Path 的方式引用。\n之后在 GitHub 上面打开展示的效果还是不错的，这里贴一下：\nReferences\nAsciinema - 录制终端工具 Gifcast - 转换 cast 文件为 GIF ","wordCount":"266","inLanguage":"en","datePublished":"2021-11-07T21:35:44+08:00","dateModified":"2021-11-07T21:35:44+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://iamgodot.com/posts/record-terminal/"},"publisher":{"@type":"Organization","name":"Godot's Blog","logo":{"@type":"ImageObject","url":"https://iamgodot.com/icons/favicon.ico"}}}</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=https://iamgodot.com accesskey=h title="Godot's Blog (Alt + H)">Godot's Blog</a>
<span class=logo-switches></span></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Record Terminal as GIF</h1><div class=post-meta><span title='2021-11-07 21:35:44 +0800 +0800'>11-07</span>&nbsp;·&nbsp;2 min</div></header><div class=post-content><p>这几天在做一个 <a href=https://github.com/iamgodot/py-tldr>CLI 项目</a>，因为涉及到命令行操作，所以想录制一段 GIF 放在 README 中展示。</p><p>印象里这种工具都是 JS 写的，但搜了搜居然发现有个 Python 的实现：<a href=https://github.com/asciinema/asciinema>asciinema</a></p><p>用法很简单，就是安装好之后在命令行执行 <code>asciinema rec</code> 便会启动一个新的 Shell 并开始录制，录制的时候就像正常使用 Terminal 一样即可，完成之后按 Ctrl-D 或者 Exit 退出，asciinema 会把录制好的 cast 文件保存到本地，也可以选择上传到他们的网站：asciinema.org.</p><p>那么 cast 文件是什么，又怎样得到 GIF 呢？其实这是 asciinema 自己定义的一种文件格式：</p><blockquote><p>A CAST file is a record of a <a href=https://techterms.com/definition/terminal>terminal</a> session recorded using asciinema, an <a href=https://techterms.com/definition/opensource>open source</a> terminal recording program. It contains a <a href=https://techterms.com/definition/json>JSON-formatted</a> header and a timestamped record of the text typed and printed during a terminal session.</p></blockquote><p>文件内容大概是这个样子的：</p><pre tabindex=0><code>{&#34;version&#34;: 2, &#34;width&#34;: 124, &#34;height&#34;: 63, &#34;timestamp&#34;: 1636292616, &#34;env&#34;: {&#34;SHELL&#34;: &#34;/usr/bin/zsh&#34;, &#34;TERM&#34;: &#34;screen-256color&#34;}}
[1.538309, &#34;o&#34;, &#34;#&#34;]
[1.915683, &#34;o&#34;, &#34;\b# &#34;]
[2.335422, &#34;o&#34;, &#34;l&#34;]
[2.405338, &#34;o&#34;, &#34;e&#34;]
[2.524792, &#34;o&#34;, &#34;t&#34;]
[3.010565, &#34;o&#34;, &#34;&#39;&#34;]
[3.13154, &#34;o&#34;, &#34;s&#34;]
</code></pre><p>就像描述里说的，第一行是 JSON 格式的 header，里面存放了一些 Terminal 的元信息，比如尺寸和环境变量。下面的每一行数据都包含了时间戳和对应的终端打印信息，也就是在录制的时候键入的命令以及输出。</p><p>对于 cast 文件，还可以直接用 asciinema 在终端回放录制的内容，比如 <code>asciinema play -i 2 demo.cast</code> 可以以两倍速播放。</p><p>从官方 Issue 看，asciinema 本身目前还不支持直接导出 GIF 文件，不过其他的工具应运而生，比如：<a href=https://github.com/asciinema/asciicast2gif>asciicast2gif</a>.</p><p>这个工具主要是用 JS 来解析 cast 文件并且生成若干张 PNG 图片，再调用 ImageMagick 和 gifsicle 这两个工具合成出最终的 GIF 文件：</p><blockquote><p><code>asciicast2gif</code> shell script parses command line arguments and executes Node.js script (<code>main.js</code>). <code>main.js</code> loads asciicast (either from remote URL or local filesystem), generates text representation of the screen for each frame using <a href=https://github.com/asciinema/asciinema-player>asciinema-player</a>&rsquo;s virtual terminal emulator, and sends it to PhantomJS-based renderer script (<code>renderer.js</code>), which saves PNG screenshots to a temporary directory. Finally, <code>main.js</code> calls ImageMagick&rsquo;s <code>convert</code> on these PNG images to construct GIF animation, also piping it to <code>gifsicle</code> to get the final, optimized GIF file.</p></blockquote><p>我不想在本地用 NPM 安装，所以选择了他们的 Docker 镜像试用，结果却没有想象中的顺利。原因大概是录制的时间较长（其实也就几分钟），生成的 cast 文件有 27K 左右，尝试渲染之后报错。在 Issue 查到是由于图片数量太多，gifsicle 合成失败。</p><p>不成熟的工具用起来就是不顺手，正在纠结要不要进坑，又发现了一个在线转换 cast 为 gif 的网站：<a href=https://dstein64.github.io/gifcast/>gifcast</a>.</p><p>试了一下异常顺利，而且网页的好处是可以预览各种 Theme 的效果，如下图：</p><p><img loading=lazy src=https://static.iamgodot.com/content/images/2021-11-07_22-13.png alt></p><p>可能是 GIF 比较大，直接把图床的 Link 放到 README 里面加载得太慢，于是我还是选择把文件放到 REPO 里面并用 Relative Path 的方式引用。</p><p>之后在 GitHub 上面打开<a href=https://github.com/iamgodot/py-tldr>展示的效果</a>还是不错的，这里贴一下：</p><p><img loading=lazy src=https://static.iamgodot.com/content/images/tldr.gif alt></p><hr><p><em>References</em></p><ul><li><a href=https://github.com/asciinema/asciinema>Asciinema - 录制终端工具</a></li><li><a href=https://dstein64.github.io/gifcast/>Gifcast - 转换 cast 文件为 GIF</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://iamgodot.com/tags/project/>project</a></li><li><a href=https://iamgodot.com/tags/python/>python</a></li></ul><nav class=paginav><a class=prev href=https://iamgodot.com/posts/understand-recursion-better/><span class=title>« Prev Page</span><br><span>Understand Recursion Better</span></a>
<a class=next href=https://iamgodot.com/posts/look-and-say/><span class=title>Next Page »</span><br><span>Look and Say</span></a></nav></footer><script src=https://giscus.app/client.js data-repo=iamgodot/godot-blog-comments data-repo-id="MDEwOlJlcG9zaXRvcnkzOTk0Nzk0MTY=" data-category=Announcements data-category-id=DIC_kwDOF8-SeM4CO3OX data-mapping=pathname data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=dark_dimmed data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2020-2022 <a href=https://iamgodot.com>Godot's Blog</a></span>
<span>| <a href=http://beian.miit.gov.cn/ target=_blank>京ICP备20005558号-2</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>