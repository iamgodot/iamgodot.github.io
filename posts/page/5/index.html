<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | Godot's Blog</title><meta name=keywords content><meta name=description content="Posts - Godot's Blog"><meta name=author content><link rel=canonical href=https://iamgodot.com/posts/><link crossorigin=anonymous href=/assets/css/stylesheet.min.7cb1aaa4414c482febc7034a427761d087a2cf358f1be8f7beba5afc947b57d0.css integrity="sha256-fLGqpEFMSC/rxwNKQndh0IeizzWPG+j3vrpa/JR7V9A=" rel="preload stylesheet" as=style><link rel=icon href=https://iamgodot.com/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://iamgodot.com/icons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://iamgodot.com/icons/favicon-32x32.png><link rel=apple-touch-icon href=https://iamgodot.com/icons/apple-touch-icon.png><link rel=mask-icon href=https://iamgodot.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://iamgodot.com/posts/index.xml><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=preload as=style href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;700&family=Source+Code+Pro:wght@400;700&display=swap"><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;700&family=Source+Code+Pro:wght@400;700&display=swap" media=print onload='this.media="all"'><link rel=preconnect href=https://plausible.iamgodot.com><script defer data-domain=iamgodot.com src=https://plausible.iamgodot.com/js/plausible.js></script>
<script>window.plausible=window.plausible||function(){(window.plausible.q=window.plausible.q||[]).push(arguments)}</script><script></script><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-157042624-1","auto"),ga("send","pageview"))</script><meta property="og:title" content="Posts"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://iamgodot.com/posts/"><meta name=twitter:card content="summary"><meta name=twitter:title content="Posts"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://iamgodot.com/posts/"}]}</script></head><body class="list dark" id=top><header class=header><nav class=nav><div class=logo><a href=https://iamgodot.com accesskey=h title="Godot's Blog (Alt + H)">Godot's Blog</a>
<span class=logo-switches></span></div><ul id=menu></ul></nav></header><main class=main><header class=page-header><h1>Posts</h1></header><article class=post-entry><header class=entry-header><h2>Numeric Strings in Python</h2></header><section class=entry-content><p>Python 的字符串自带了三种判断字符是否为数字的方法，但实际用处却相差很多。
TL;DR 三种方法 isdecimal &lt; isdigit &lt; isnumeric，即包含的范围越来越大 除了 ASCII 字符以外，对于 Unicode 的字符也都覆盖在内 三种方法对于小数点和负号都会返回 False 三种方法对于空字符串都会返回 False 比较简便判断数字字符串的方法：直接使用 float 方法并检测 ValueError Decimal & Digit & Numeric 对于 isdecimal, isdigit 和 isnumeric 三种方法，目的并不是判断字符串是不是一个有效数字，而是针对每一个字符的校验：
isdecimal: 判断字符串中的字符是否都为 Decimal，也就是在 Unicode 中类别为 Nd 的字符 isdigit: 除了 isdecimal 包含的范围之外，还会判断字符是否都为 Digit，即 Unicode 的 Numeric_Type 为 Digit 或 Decimal isnumeric: 除了 isdigit 包含的范围之外，还会判断字符是否都为 Numeric，即 Numeric_Type 为 Numeric 所以这三种方法覆盖的字符范围，每一个都是前一个的超集。对于超出 ASCII 字符之外的效果，比如：
“０１２３４５６７８９” 这种 Full-width 字符串 isdecimal 会判定为 True，后两个方法也一样 “⓪①②③④⑤⑥⑦⑧⑨” 这种 Circled-digit 字符串 isdecimal 判定 False，但 isdigit 和 isnumeric 为 True “一二三四五六七八九十壹貳參肆伍陸柒捌玖拾” 这种中文数字字符串只有 isnumeric 才会判定为 True 总之这几种方法有更广泛的用途，根本不是为了简单的 ASCII 数字字符串的判断。即使用来做判断的话，局限性也非常大，因为如果包含小数点和负号，三个方法都会返回 False....</p></section><footer class=entry-footer><span title='2021-11-21 17:44:36 +0800 +0800'>11-21</span>&nbsp;·&nbsp;1 min</footer><a class=entry-link aria-label="post link to Numeric Strings in Python" href=https://iamgodot.com/posts/numeric-strings-in-python/></a></article><article class=post-entry><header class=entry-header><h2>From Wireshark to Linux Capabilities</h2></header><section class=entry-content><p>Tcpdump 和 Wireshark 是抓包必备的程序，但是由于需要截取网络数据包，所以在 Linux 下必须以 root 的身份来运行。每次都 sudo 执行不方便也并不安全（对 Wireshark 来说捉包只是一小部分功能），解决方案当然有，在寻找的过程中我了解到了 Capabilities 的冰山一角。
TL;DR 可以通过设置 Setuid 以 root 身份执行，但如此以来赋予了过高的权限（也没有必要）。 Linux 下用 Capabilities 把系统权限划分成多个条目，以此实现细粒度地提升程序的执行能力。 Setuid 先盗一张图复习下 Linux File Permission 的基础知识：
除了 rwx 之外还存在三种特殊类型，即是为了在更高权限下运行程序：
Setuid: 程序的运行者不再是执行者，而是变成文件的所有者 Setgid: 程序的运行群组变成了文件的所在群组，如果给目录设置，那么其中新建的文件所有群组会变成目录的群组而不是执行者的群组 Sticky bit: 针对目录设置，目录下的文件只有所有者和 root 能够重命名、移动和删除 在 Linux 中 sudo 是 Setuid 最好的例子，而 crontab 和 tmp/ 分别是 Setgid 和 Sticky bit 的典型应用。
在命令行中测试：
# Setuid ➜ ~ umask -S u=rwx,g=rx,o=rx ➜ ~ umask # 掩码是 022，所以默认文件的权限是 666-022=644，而目录则是 777-022=755 022 ➜ ~ touch foo....</p></section><footer class=entry-footer><span title='2021-11-21 13:39:25 +0800 +0800'>11-21</span>&nbsp;·&nbsp;3 min</footer><a class=entry-link aria-label="post link to From Wireshark to Linux Capabilities" href=https://iamgodot.com/posts/from-wireshark-to-linux-capabilities/></a></article><article class=post-entry><header class=entry-header><h2>Overflow in Python</h2></header><section class=entry-content><p>犹记得在 Java 中，int 占用 4 bytes 所以大小限制在 -2^32 和 2^32 -1 之间，如果考虑到溢出的情况，就要用 long 类型来转换。
但是在 Python 中似乎从来没有考虑过类似的问题，也不记得 int 是占几个字节，那么是说 Python 的数字永远不会溢出吗？不可能吧。
答案是对于 int 类型来说，可以认为不会；而 float 类型则需要注意溢出的情况。
首先说 int 类型，打印 sys.maxsize 可以看到 Python 会根据系统是 32 位还是 64 位来确定一个上限值，这点与 Java 等语言一致。不同的是我们仍然可以使用比这个上限大（得多）的整数，因为 Python 支持的是 Arbitrary-precision arithmetic。也就是说为了突破 CPU 字长带来的运算限制，通过在软件层面模拟计算过程，是可以完成更高位数和精度的运算的。比如在公钥加密的场景下，经常需要对上百位的整数进行运算，这时候就需要在软件层面支持。
这确实说明我们可以使用任意长度的 int 数字，只要不超出内存限制的话。因为如果给 Python 解释器分配了 2GB 内存，但是 2 * 1024 * 1024 * 1024 * 8 这么多位也不够表达的话，还是会出错的，只是并非 Overflow，而是 MemoryError.
再说 float. 打印 sys.float_info.max 可以看到 float 的上限值，如果超出之后是会报错的，即 OverflowError....</p></section><footer class=entry-footer><span title='2021-11-12 17:20:10 +0800 +0800'>11-12</span>&nbsp;·&nbsp;1 min</footer><a class=entry-link aria-label="post link to Overflow in Python" href=https://iamgodot.com/posts/overflow-in-python/></a></article><article class=post-entry><header class=entry-header><h2>Understand Recursion Better</h2></header><section class=entry-content><p>在 Simple Recursion 之后，我一度把递归当作一种算法。但通过比较 Divide and Conquer 和 Dynamic Programming，我才发现之前的理解有点问题。
一切还是要从 Algorithmic Paradigm 说起：
An algorithmic paradigm or algorithm design paradigm is a generic model or framework which underlies the design of a class of algorithms. An algorithmic paradigm is an abstraction higher than the notion of an algorithm, just as an algorithm is an abstraction higher than a computer program.
算法范式，是在算法的层面上抽象出来的一种更泛化的思想，常用的有：
Brute-force search 暴力解法 Backtracking 回溯算法 Greedy algorithm 贪心算法 Divide and conquer 分治法 Dynamic programming 动态规划 Divide and Conquer 的基本思路是把复杂的问题分解成多个类似的简单问题，解决之后再组合起来得到最终结果。这种算法有很多应用，比如排序中的 Merge Sort，先将数列分解成单个元素，然后再归并，这时子数组都已经排好顺序了，所以过程很快。...</p></section><footer class=entry-footer><span title='2021-11-08 18:18:10 +0800 +0800'>11-08</span>&nbsp;·&nbsp;2 min</footer><a class=entry-link aria-label="post link to Understand Recursion Better" href=https://iamgodot.com/posts/understand-recursion-better/></a></article><article class=post-entry><header class=entry-header><h2>Record Terminal as GIF</h2></header><section class=entry-content><p>这几天在做一个 CLI 项目，因为涉及到命令行操作，所以想录制一段 GIF 放在 README 中展示。
印象里这种工具都是 JS 写的，但搜了搜居然发现有个 Python 的实现：asciinema
用法很简单，就是安装好之后在命令行执行 asciinema rec 便会启动一个新的 Shell 并开始录制，录制的时候就像正常使用 Terminal 一样即可，完成之后按 Ctrl-D 或者 Exit 退出，asciinema 会把录制好的 cast 文件保存到本地，也可以选择上传到他们的网站：asciinema.org.
那么 cast 文件是什么，又怎样得到 GIF 呢？其实这是 asciinema 自己定义的一种文件格式：
A CAST file is a record of a terminal session recorded using asciinema, an open source terminal recording program. It contains a JSON-formatted header and a timestamped record of the text typed and printed during a terminal session....</p></section><footer class=entry-footer><span title='2021-11-07 21:35:44 +0800 +0800'>11-07</span>&nbsp;·&nbsp;2 min</footer><a class=entry-link aria-label="post link to Record Terminal as GIF" href=https://iamgodot.com/posts/record-terminal/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://iamgodot.com/posts/page/4/>« Prev Page</a>
<a class=next href=https://iamgodot.com/posts/page/6/>Next Page »</a></nav></footer></main><footer class=footer><span>&copy; 2020-2022 <a href=https://iamgodot.com>Godot's Blog</a></span>
<span>| <a href=http://beian.miit.gov.cn/ target=_blank>京ICP备20005558号-2</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script></body></html>