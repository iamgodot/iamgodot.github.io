<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Sum of Total Strength of Wizards | Godot's Blog</title><meta name=keywords content="巫师的总力量和,单调栈,前缀和"><meta name=description content="前两天做了一道算法题，虽然没能成功解决，但是是一道很有意思的题目。
抛开题面的包装不谈，核心内容就是给定一个数组，计算它的所有子数组的最小值与加和的乘积的总和。
（这里要注意子数组的定义，一定是连续的，如果不连续的话叫做子序列。）
比如对于 [1, 2, 3] 来说，一共有六种情况：
[1]: 1 * 1 = 1 [2]: 2 * 2 = 4 [3]: 3 * 3 = 9 [1, 2]: 1 * (1 + 2) = 3 [2, 3]: 2 * (2 + 3) = 10 [1, 2, 3]: 1 * (1 + 2 + 3) = 6 最后答案为 1 + 4 + 9 + 3 + 10 + 6 = 33。"><meta name=author content><link rel=canonical href=https://iamgodot.com/posts/sum-of-total-strength-of-wizards/><link crossorigin=anonymous href=/assets/css/stylesheet.ccf31920937c003cd18f1d2c671cf276443c43adc691e4d3b8cbe72139577e06.css integrity="sha256-zPMZIJN8ADzRjx0sZxzydkQ8Q63GkeTTuMvnITlXfgY=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://iamgodot.com/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://iamgodot.com/icons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://iamgodot.com/icons/favicon-32x32.png><link rel=apple-touch-icon href=https://iamgodot.com/icons/apple-touch-icon.png><link rel=mask-icon href=https://iamgodot.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=preload as=style href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;700&family=Source+Code+Pro:wght@400;700&display=swap"><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;700&family=Source+Code+Pro:wght@400;700&display=swap" media=print onload='this.media="all"'><link rel=preconnect href=https://plausible.iamgodot.com><script defer data-domain=iamgodot.com src=https://plausible.iamgodot.com/js/plausible.js></script>
<script>window.plausible=window.plausible||function(){(window.plausible.q=window.plausible.q||[]).push(arguments)}</script><script></script><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-157042624-1","auto"),ga("send","pageview"))</script><meta property="og:title" content="Sum of Total Strength of Wizards"><meta property="og:description" content="前两天做了一道算法题，虽然没能成功解决，但是是一道很有意思的题目。
抛开题面的包装不谈，核心内容就是给定一个数组，计算它的所有子数组的最小值与加和的乘积的总和。
（这里要注意子数组的定义，一定是连续的，如果不连续的话叫做子序列。）
比如对于 [1, 2, 3] 来说，一共有六种情况：
[1]: 1 * 1 = 1 [2]: 2 * 2 = 4 [3]: 3 * 3 = 9 [1, 2]: 1 * (1 + 2) = 3 [2, 3]: 2 * (2 + 3) = 10 [1, 2, 3]: 1 * (1 + 2 + 3) = 6 最后答案为 1 + 4 + 9 + 3 + 10 + 6 = 33。"><meta property="og:type" content="article"><meta property="og:url" content="https://iamgodot.com/posts/sum-of-total-strength-of-wizards/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-07-26T10:41:55+08:00"><meta property="article:modified_time" content="2022-07-26T10:41:55+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Sum of Total Strength of Wizards"><meta name=twitter:description content="前两天做了一道算法题，虽然没能成功解决，但是是一道很有意思的题目。
抛开题面的包装不谈，核心内容就是给定一个数组，计算它的所有子数组的最小值与加和的乘积的总和。
（这里要注意子数组的定义，一定是连续的，如果不连续的话叫做子序列。）
比如对于 [1, 2, 3] 来说，一共有六种情况：
[1]: 1 * 1 = 1 [2]: 2 * 2 = 4 [3]: 3 * 3 = 9 [1, 2]: 1 * (1 + 2) = 3 [2, 3]: 2 * (2 + 3) = 10 [1, 2, 3]: 1 * (1 + 2 + 3) = 6 最后答案为 1 + 4 + 9 + 3 + 10 + 6 = 33。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://iamgodot.com/posts/"},{"@type":"ListItem","position":3,"name":"Sum of Total Strength of Wizards","item":"https://iamgodot.com/posts/sum-of-total-strength-of-wizards/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Sum of Total Strength of Wizards","name":"Sum of Total Strength of Wizards","description":"前两天做了一道算法题，虽然没能成功解决，但是是一道很有意思的题目。\n抛开题面的包装不谈，核心内容就是给定一个数组，计算它的所有子数组的最小值与加和的乘积的总和。\n（这里要注意子数组的定义，一定是连续的，如果不连续的话叫做子序列。）\n比如对于 [1, 2, 3] 来说，一共有六种情况：\n[1]: 1 * 1 = 1 [2]: 2 * 2 = 4 [3]: 3 * 3 = 9 [1, 2]: 1 * (1 + 2) = 3 [2, 3]: 2 * (2 + 3) = 10 [1, 2, 3]: 1 * (1 + 2 + 3) = 6 最后答案为 1 + 4 + 9 + 3 + 10 + 6 = 33。","keywords":["巫师的总力量和","单调栈","前缀和"],"articleBody":"前两天做了一道算法题，虽然没能成功解决，但是是一道很有意思的题目。\n抛开题面的包装不谈，核心内容就是给定一个数组，计算它的所有子数组的最小值与加和的乘积的总和。\n（这里要注意子数组的定义，一定是连续的，如果不连续的话叫做子序列。）\n比如对于 [1, 2, 3] 来说，一共有六种情况：\n[1]: 1 * 1 = 1 [2]: 2 * 2 = 4 [3]: 3 * 3 = 9 [1, 2]: 1 * (1 + 2) = 3 [2, 3]: 2 * (2 + 3) = 10 [1, 2, 3]: 1 * (1 + 2 + 3) = 6 最后答案为 1 + 4 + 9 + 3 + 10 + 6 = 33。\n暴力解法 直接的做法很容易想到，那就是嵌套遍历数组，对于每个子数组再计算 min 与 sum 的乘积，最后求和。\n看着感觉还好？但其实除了双层循环之外，计算最小值以及求和也需要一次遍历，最终的时间复杂度为 O(n^3)，非常之慢。\n看上去每个子数组的计算之间有很多重复，如何优化呢？\n单调栈 单独来看每一个元素：在某个区间内它一定是最小值，即便只有它自己，那么此范围内的子数组的最小值直接使用该元素即可。\n那么第一步就是找到每个元素的有效区间，于是问题变成了求前一个和后一个的更小元素。\n单调栈是专门来解决这类问题的，简单来说就是在遍历过程中保证栈的单调性，进而为每个元素定位前/后的更小/大元素值。一般可以这么写：\ndef find_last_greater(nums): stack = [] length = len(nums) last_greater_element_index = [-1] * length for i in range(length): while stack and nums[stack[-1]] \u003c= nums[i]: stack.pop() if stack: last_greater_element_index[i] = stack[-1] stack.append(i) return last_greater_element_index 其中，遍历的顺序决定往前找（正序）还是往后找（倒序），与栈顶元素的比较决定找到的是更小还是更大的元素（的下标）。需要注意比较中的等号，它表示寻找的条件是严格单调，即排除了等值的情况。\n此外，还有一个省力的技巧。如果想同时寻找前后两个更大的元素，那么只需遍历一次即可：\ndef mono_stack(nums): stack = [] length = len(nums) last_greater_element_index = [-1] * length next_greater_element_index = [length] * length for i in range(length): while stack and nums[stack[-1]] \u003c= nums[i]: # 这里正好利用出栈的机会来更新 next 数组 next_greater_element_index[stack.pop()] = i if stack: last_greater_element_index[i] = stack[-1] stack.append(i) return last_greater_element_index, next_greater_element_index 更小元素的话也是一样，改变比较条件就好了。另外结果中的两个数组正好是一开一闭的，不会出现对于等值情况的重复。\n还有初始值，比如对于前一个更大元素最好预设为 -1，这样逻辑上保持统一，计算区间长度的时候也更方便。\n前缀和 -\u003e 前缀和 找到了区间，也解决了最小值的问题，要想想怎么求和了。\n假设 [l, r] 之内包含着元素 i，这样产生的子数组数量（包含 i）为两边长度的乘积：(i - l + 1) * (r - i + 1)。\n如何加和呢，我当时也卡在了这里，虽然利用前缀和可以快速得到某个子数组的和，但依次遍历这些子数组求和的复杂度仍然很高。\n后来才知道，其实可以更上一层楼，应用前缀和的前缀和快速计算出区间内所有子数组和的总和。\n公式推导的过程参考这里，截图如下：\n一般的前缀和是前面所有元素加上当前元素之和，而图中的定义略有不同，每个前缀和并不包括当前位置的元素。基于此，推导图中第二行的右半部分应为 presum[r] - presum[l - 1]。\n另外，第三行到第四行之所以消解求和符号是因为公式中没有再依赖该变量，所以能够转化为乘积关系。\n实现 先以上图的原始推导结果展示代码：\nfrom itertools import accumulate def total_strength(strength): length = len(strength) min_left, min_right = [-1] * length, [length] * length stack = [] for i in range(length): while stack and strength[stack[-1]] \u003e= strength[i]: min_right[stack.pop()] = i if stack: min_left[i] = stack[-1] stack.append(i) res = 0 prepresum = list(accumulate(accumulate(strength, initial=0), initial=0)) for i in range(length): range_sum = (i - min_left[i]) * ( prepresum[min_right[i] + 1] - prepresum[i + 1] ) - (min_right[i] - i) * (prepresum[i + 1] - prepresum[min_left[i] + 1]) res += range_sum * strength[i] return res % (10 ** 9 + 7) 可以看到，在计算前缀和数组时，先在最前面增加了一个 0 元素（通过 initial 参数），这样得到的前缀和就是不包含当前位置元素的。好处是不会造成数组越界，因为下面 prepresum 的下标存在 i + 1、min_right[i] + 1 等情况。\n但这确实不符合直觉的前缀和定义，于是强迫症让我按照传统又推导了一遍，range_sum 中的 + 都变成了 -。这时候计算 prepresum 就不需要前面加 0 了。这里还有个坑要注意，因为 - 的存在，prepresum 的下标可能会小于 0，由于 Python 的切片特性并不会越界报错，而是从末尾继续计算，导致结果错误。因此，当下标变成负数时，value 要直接取 0。\nfrom itertools import accumulate def total_strength(strength): length = len(strength) min_left, min_right = [-1] * length, [length] * length stack = [] for i in range(length): while stack and strength[stack[-1]] \u003e= strength[i]: min_right[stack.pop()] = i if stack: min_left[i] = stack[-1] stack.append(i) res = 0 prepresum = list(accumulate(accumulate(strength))) for i in range(length): prepresum_i = prepresum[i - 1] if i \u003e 0 else 0 prepresum_left = prepresum[min_left[i] - 1] if min_left[i] - 1 \u003e= 0 else 0 prepresum_right = prepresum[min_right[i] - 1] if min_right[i] - 1 \u003e= 0 else 0 range_sum = (i - min_left[i]) * (prepresum_right - prepresum_i) - (min_right[i] - i) * (prepresum_i - prepresum_left) res += range_sum * strength[i] return res % (10 ** 9 + 7) 代码略微繁琐一点，不过我个人觉得还是更好理解些。\n最后之所以对 10^9 + 7 取余是因为测试数据量很大，会造成溢出。\n单调栈加前缀和的做法实现了线性的时间复杂度，相比暴力解法是飞跃般的提升，也让我切实感受到了算法之美。\nReferences\n巫师的总力量和 - Leetcode：原题参考。 Prefix Sum：综合讲解前缀和，上面的公式推导即出自这里。 子数组的最小值之和 - Leetcode：另一道类似的题目，主要是针对单调栈的应用。 ","wordCount":"451","inLanguage":"en","datePublished":"2022-07-26T10:41:55+08:00","dateModified":"2022-07-26T10:41:55+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://iamgodot.com/posts/sum-of-total-strength-of-wizards/"},"publisher":{"@type":"Organization","name":"Godot's Blog","logo":{"@type":"ImageObject","url":"https://iamgodot.com/icons/favicon.ico"}}}</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=https://iamgodot.com accesskey=h title="Godot's Blog (Alt + H)">Godot's Blog</a><div class=logo-switches></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Sum of Total Strength of Wizards</h1><div class=post-meta><span title='2022-07-26 10:41:55 +0800 +0800'>07-26</span>&nbsp;·&nbsp;3 min</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e6%9a%b4%e5%8a%9b%e8%a7%a3%e6%b3%95 aria-label=暴力解法>暴力解法</a></li><li><a href=#%e5%8d%95%e8%b0%83%e6%a0%88 aria-label=单调栈>单调栈</a></li><li><a href=#%e5%89%8d%e7%bc%80%e5%92%8c---%e5%89%8d%e7%bc%80%e5%92%8c aria-label="前缀和 -&amp;gt; 前缀和">前缀和 -> 前缀和</a></li><li><a href=#%e5%ae%9e%e7%8e%b0 aria-label=实现>实现</a></li></ul></div></details></div><div class=post-content><p>前两天做了一道算法题，虽然没能成功解决，但是是一道很有意思的题目。</p><p>抛开题面的包装不谈，核心内容就是给定一个数组，计算它的所有子数组的最小值与加和的乘积的总和。</p><p>（这里要注意子数组的定义，一定是连续的，如果不连续的话叫做子序列。）</p><p>比如对于 <code>[1, 2, 3]</code> 来说，一共有六种情况：</p><ul><li><code>[1]</code>: <code>1 * 1 = 1</code></li><li><code>[2]</code>: <code>2 * 2 = 4</code></li><li><code>[3]</code>: <code>3 * 3 = 9</code></li><li><code>[1, 2]</code>: <code>1 * (1 + 2) = 3</code></li><li><code>[2, 3]</code>: <code>2 * (2 + 3) = 10</code></li><li><code>[1, 2, 3]</code>: <code>1 * (1 + 2 + 3) = 6</code></li></ul><p>最后答案为 <code>1 + 4 + 9 + 3 + 10 + 6 = 33</code>。</p><h1 id=暴力解法>暴力解法<a hidden class=anchor aria-hidden=true href=#暴力解法>#</a></h1><p>直接的做法很容易想到，那就是嵌套遍历数组，对于每个子数组再计算 <code>min</code> 与 <code>sum</code> 的乘积，最后求和。</p><p>看着感觉还好？但其实除了双层循环之外，计算最小值以及求和也需要一次遍历，最终的时间复杂度为 <code>O(n^3)</code>，非常之慢。</p><p>看上去每个子数组的计算之间有很多重复，如何优化呢？</p><h1 id=单调栈>单调栈<a hidden class=anchor aria-hidden=true href=#单调栈>#</a></h1><p>单独来看每一个元素：在某个区间内它一定是最小值，即便只有它自己，那么此范围内的子数组的最小值直接使用该元素即可。</p><p>那么第一步就是找到每个元素的有效区间，于是问题变成了求前一个和后一个的更小元素。</p><p>单调栈是专门来解决这类问题的，简单来说就是在遍历过程中保证栈的单调性，进而为每个元素定位前/后的更小/大元素值。一般可以这么写：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>find_last_greater</span>(nums):
</span></span><span style=display:flex><span>    stack <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>    length <span style=color:#f92672>=</span> len(nums)
</span></span><span style=display:flex><span>    last_greater_element_index <span style=color:#f92672>=</span> [<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>*</span> length
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(length):
</span></span><span style=display:flex><span>    	<span style=color:#66d9ef>while</span> stack <span style=color:#f92672>and</span> nums[stack[<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]] <span style=color:#f92672>&lt;=</span> nums[i]:
</span></span><span style=display:flex><span>            stack<span style=color:#f92672>.</span>pop()
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> stack:
</span></span><span style=display:flex><span>            last_greater_element_index[i] <span style=color:#f92672>=</span> stack[<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>        stack<span style=color:#f92672>.</span>append(i)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> last_greater_element_index
</span></span></code></pre></div><p>其中，遍历的顺序决定往前找（正序）还是往后找（倒序），与栈顶元素的比较决定找到的是更小还是更大的元素（的下标）。需要注意比较中的等号，它表示寻找的条件是严格单调，即排除了等值的情况。</p><p>此外，还有一个省力的技巧。如果想同时寻找前后两个更大的元素，那么只需遍历一次即可：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>mono_stack</span>(nums):
</span></span><span style=display:flex><span>    stack <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>    length <span style=color:#f92672>=</span> len(nums)
</span></span><span style=display:flex><span>    last_greater_element_index <span style=color:#f92672>=</span> [<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>*</span> length
</span></span><span style=display:flex><span>    next_greater_element_index <span style=color:#f92672>=</span> [length] <span style=color:#f92672>*</span> length
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(length):
</span></span><span style=display:flex><span>    	<span style=color:#66d9ef>while</span> stack <span style=color:#f92672>and</span> nums[stack[<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]] <span style=color:#f92672>&lt;=</span> nums[i]:
</span></span><span style=display:flex><span>            <span style=color:#75715e># 这里正好利用出栈的机会来更新 next 数组</span>
</span></span><span style=display:flex><span>            next_greater_element_index[stack<span style=color:#f92672>.</span>pop()] <span style=color:#f92672>=</span> i
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> stack:
</span></span><span style=display:flex><span>            last_greater_element_index[i] <span style=color:#f92672>=</span> stack[<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>        stack<span style=color:#f92672>.</span>append(i)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> last_greater_element_index, next_greater_element_index
</span></span></code></pre></div><p>更小元素的话也是一样，改变比较条件就好了。另外结果中的两个数组正好是一开一闭的，不会出现对于等值情况的重复。</p><p>还有初始值，比如对于前一个更大元素最好预设为 <code>-1</code>，这样逻辑上保持统一，计算区间长度的时候也更方便。</p><h1 id=前缀和---前缀和>前缀和 -> 前缀和<a hidden class=anchor aria-hidden=true href=#前缀和---前缀和>#</a></h1><p>找到了区间，也解决了最小值的问题，要想想怎么求和了。</p><p>假设 <code>[l, r]</code> 之内包含着元素 <code>i</code>，这样产生的子数组数量（包含 <code>i</code>）为两边长度的乘积：<code>(i - l + 1) * (r - i + 1)</code>。</p><p>如何加和呢，我当时也卡在了这里，虽然利用前缀和可以快速得到某个子数组的和，但依次遍历这些子数组求和的复杂度仍然很高。</p><p>后来才知道，其实可以更上一层楼，应用前缀和的前缀和快速计算出区间内所有子数组和的总和。</p><p>公式推导的过程参考<a href=https://lctemplates.xyli.codes/en/latest/prefix-sum.html#prefix-sum-of-prefix-sum>这里</a>，截图如下：</p><p><img loading=lazy src=https://static.iamgodot.com/content/images/20220726162704.png alt></p><p>一般的前缀和是前面所有元素加上当前元素之和，而图中的定义略有不同，每个前缀和并不包括当前位置的元素。基于此，推导图中第二行的右半部分应为 <code>presum[r] - presum[l - 1]</code>。</p><p>另外，第三行到第四行之所以消解求和符号是因为公式中没有再依赖该变量，所以能够转化为乘积关系。</p><h1 id=实现>实现<a hidden class=anchor aria-hidden=true href=#实现>#</a></h1><p>先以上图的原始推导结果展示代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> itertools <span style=color:#f92672>import</span> accumulate
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>total_strength</span>(strength):
</span></span><span style=display:flex><span>    length <span style=color:#f92672>=</span> len(strength)
</span></span><span style=display:flex><span>    min_left, min_right <span style=color:#f92672>=</span> [<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>*</span> length, [length] <span style=color:#f92672>*</span> length
</span></span><span style=display:flex><span>    stack <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(length):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> stack <span style=color:#f92672>and</span> strength[stack[<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]] <span style=color:#f92672>&gt;=</span> strength[i]:
</span></span><span style=display:flex><span>            min_right[stack<span style=color:#f92672>.</span>pop()] <span style=color:#f92672>=</span> i
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> stack:
</span></span><span style=display:flex><span>            min_left[i] <span style=color:#f92672>=</span> stack[<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>        stack<span style=color:#f92672>.</span>append(i)
</span></span><span style=display:flex><span>    res <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    prepresum <span style=color:#f92672>=</span> list(accumulate(accumulate(strength, initial<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>), initial<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>))
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(length):
</span></span><span style=display:flex><span>        range_sum <span style=color:#f92672>=</span> (i <span style=color:#f92672>-</span> min_left[i]) <span style=color:#f92672>*</span> (
</span></span><span style=display:flex><span>            prepresum[min_right[i] <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>-</span> prepresum[i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>        ) <span style=color:#f92672>-</span> (min_right[i] <span style=color:#f92672>-</span> i) <span style=color:#f92672>*</span> (prepresum[i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>-</span> prepresum[min_left[i] <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>])
</span></span><span style=display:flex><span>        res <span style=color:#f92672>+=</span> range_sum <span style=color:#f92672>*</span> strength[i]
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> res <span style=color:#f92672>%</span> (<span style=color:#ae81ff>10</span> <span style=color:#f92672>**</span> <span style=color:#ae81ff>9</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>7</span>)
</span></span></code></pre></div><p>可以看到，在计算前缀和数组时，先在最前面增加了一个 <code>0</code> 元素（通过 <code>initial</code> 参数），这样得到的前缀和就是不包含当前位置元素的。好处是不会造成数组越界，因为下面 <code>prepresum</code> 的下标存在 <code>i + 1</code>、<code>min_right[i] + 1</code> 等情况。</p><p>但这确实不符合直觉的前缀和定义，于是强迫症让我按照传统又推导了一遍，<code>range_sum</code> 中的 <code>+</code> 都变成了 <code>-</code>。这时候计算 <code>prepresum</code> 就不需要前面加 <code>0</code> 了。这里还有个坑要注意，因为 <code>-</code> 的存在，<code>prepresum</code> 的下标可能会小于 0，由于 Python 的切片特性并不会越界报错，而是从末尾继续计算，导致结果错误。因此，当下标变成负数时，value 要直接取 <code>0</code>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> itertools <span style=color:#f92672>import</span> accumulate
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>total_strength</span>(strength):
</span></span><span style=display:flex><span>    length <span style=color:#f92672>=</span> len(strength)
</span></span><span style=display:flex><span>    min_left, min_right <span style=color:#f92672>=</span> [<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>*</span> length, [length] <span style=color:#f92672>*</span> length
</span></span><span style=display:flex><span>    stack <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(length):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> stack <span style=color:#f92672>and</span> strength[stack[<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]] <span style=color:#f92672>&gt;=</span> strength[i]:
</span></span><span style=display:flex><span>            min_right[stack<span style=color:#f92672>.</span>pop()] <span style=color:#f92672>=</span> i
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> stack:
</span></span><span style=display:flex><span>            min_left[i] <span style=color:#f92672>=</span> stack[<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>        stack<span style=color:#f92672>.</span>append(i)
</span></span><span style=display:flex><span>    res <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    prepresum <span style=color:#f92672>=</span> list(accumulate(accumulate(strength)))
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(length):
</span></span><span style=display:flex><span>        prepresum_i <span style=color:#f92672>=</span> prepresum[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>] <span style=color:#66d9ef>if</span> i <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> <span style=color:#66d9ef>else</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>        prepresum_left <span style=color:#f92672>=</span> prepresum[min_left[i] <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>] <span style=color:#66d9ef>if</span> min_left[i] <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span> <span style=color:#66d9ef>else</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>        prepresum_right <span style=color:#f92672>=</span> prepresum[min_right[i] <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>] <span style=color:#66d9ef>if</span> min_right[i] <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span> <span style=color:#66d9ef>else</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>        range_sum <span style=color:#f92672>=</span> (i <span style=color:#f92672>-</span> min_left[i]) <span style=color:#f92672>*</span> (prepresum_right <span style=color:#f92672>-</span> prepresum_i) <span style=color:#f92672>-</span> (min_right[i] <span style=color:#f92672>-</span> i) <span style=color:#f92672>*</span> (prepresum_i <span style=color:#f92672>-</span> prepresum_left)
</span></span><span style=display:flex><span>        res <span style=color:#f92672>+=</span> range_sum <span style=color:#f92672>*</span> strength[i]
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> res <span style=color:#f92672>%</span> (<span style=color:#ae81ff>10</span> <span style=color:#f92672>**</span> <span style=color:#ae81ff>9</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>7</span>)
</span></span></code></pre></div><p>代码略微繁琐一点，不过我个人觉得还是更好理解些。</p><p>最后之所以对 <code>10^9 + 7</code> 取余是因为测试数据量很大，会造成溢出。</p><p>单调栈加前缀和的做法实现了线性的时间复杂度，相比暴力解法是飞跃般的提升，也让我切实感受到了算法之美。</p><hr><p><em>References</em></p><ul><li><a href=https://leetcode.cn/problems/sum-of-total-strength-of-wizards/>巫师的总力量和 - Leetcode</a>：原题参考。</li><li><a href=https://lctemplates.xyli.codes/en/latest/prefix-sum.html#prefix-sum-of-prefix-sum>Prefix Sum</a>：综合讲解前缀和，上面的公式推导即出自这里。</li><li><a href=https://leetcode.cn/problems/sum-of-subarray-minimums/>子数组的最小值之和 - Leetcode</a>：另一道类似的题目，主要是针对单调栈的应用。</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://iamgodot.com/tags/dsa/>dsa</a></li></ul><nav class=paginav><a class=prev href=https://iamgodot.com/posts/visit-tengchong/><span class=title>« Prev</span><br><span>游腾冲</span></a>
<a class=next href=https://iamgodot.com/posts/a-peaceful-afternoon/><span class=title>Next »</span><br><span>夏日午后</span></a></nav></footer><script src=https://giscus.app/client.js data-repo=iamgodot/godot-blog-comments data-repo-id="MDEwOlJlcG9zaXRvcnkzOTk0Nzk0MTY=" data-category=Announcements data-category-id=DIC_kwDOF8-SeM4CO3OX data-mapping=pathname data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=dark_dimmed data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2020-2023 <a href=https://iamgodot.com>Godot's Blog</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>