<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Python Logging 源码分析 | Godot's Blog</title><meta name=keywords content="Python Logging,Logging 源码,Logging 用法详解"><meta name=description content="阅读了源码之后，我对 Python Logging 模块的几大疑惑都得到了解答：
为什么 Logger 和 Handler 都有 setLevel 方法？
Logging 中会出现 Race condition 吗？（感觉都是很直接的 write 操作）
正式环境中想看日志又没办法动态调整 logLevel，感觉很鸡肋。
用起来好像还不如 print 方便。
会有性能问题吗？
日常使用 首先要了解下 Logging 的用法。
1. 配置 基本上有三种方式，代码、文件和字典。先看下如何用代码设置：
import logging # create logger logger = logging.getLogger('simple_example') logger.setLevel(logging.DEBUG) # create console handler and set level to debug ch = logging.StreamHandler() ch.setLevel(logging.DEBUG) # create formatter formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s') # add formatter to ch ch."><meta name=author content><link rel=canonical href=https://iamgodot.com/posts/sourcecode-of-python-logging/><link crossorigin=anonymous href=/assets/css/stylesheet.ccf31920937c003cd18f1d2c671cf276443c43adc691e4d3b8cbe72139577e06.css integrity="sha256-zPMZIJN8ADzRjx0sZxzydkQ8Q63GkeTTuMvnITlXfgY=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://iamgodot.com/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://iamgodot.com/icons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://iamgodot.com/icons/favicon-32x32.png><link rel=apple-touch-icon href=https://iamgodot.com/icons/apple-touch-icon.png><link rel=mask-icon href=https://iamgodot.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=preload as=style href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;700&family=Source+Code+Pro:wght@400;700&display=swap"><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;700&family=Source+Code+Pro:wght@400;700&display=swap" media=print onload='this.media="all"'><link rel=preconnect href=https://plausible.iamgodot.com><script defer data-domain=iamgodot.com src=https://plausible.iamgodot.com/js/plausible.js></script>
<script>window.plausible=window.plausible||function(){(window.plausible.q=window.plausible.q||[]).push(arguments)}</script><script></script><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-157042624-1","auto"),ga("send","pageview"))</script><meta property="og:title" content="Python Logging 源码分析"><meta property="og:description" content="阅读了源码之后，我对 Python Logging 模块的几大疑惑都得到了解答：
为什么 Logger 和 Handler 都有 setLevel 方法？
Logging 中会出现 Race condition 吗？（感觉都是很直接的 write 操作）
正式环境中想看日志又没办法动态调整 logLevel，感觉很鸡肋。
用起来好像还不如 print 方便。
会有性能问题吗？
日常使用 首先要了解下 Logging 的用法。
1. 配置 基本上有三种方式，代码、文件和字典。先看下如何用代码设置：
import logging # create logger logger = logging.getLogger('simple_example') logger.setLevel(logging.DEBUG) # create console handler and set level to debug ch = logging.StreamHandler() ch.setLevel(logging.DEBUG) # create formatter formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s') # add formatter to ch ch."><meta property="og:type" content="article"><meta property="og:url" content="https://iamgodot.com/posts/sourcecode-of-python-logging/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-04-09T09:52:51+08:00"><meta property="article:modified_time" content="2022-04-09T09:52:51+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Python Logging 源码分析"><meta name=twitter:description content="阅读了源码之后，我对 Python Logging 模块的几大疑惑都得到了解答：
为什么 Logger 和 Handler 都有 setLevel 方法？
Logging 中会出现 Race condition 吗？（感觉都是很直接的 write 操作）
正式环境中想看日志又没办法动态调整 logLevel，感觉很鸡肋。
用起来好像还不如 print 方便。
会有性能问题吗？
日常使用 首先要了解下 Logging 的用法。
1. 配置 基本上有三种方式，代码、文件和字典。先看下如何用代码设置：
import logging # create logger logger = logging.getLogger('simple_example') logger.setLevel(logging.DEBUG) # create console handler and set level to debug ch = logging.StreamHandler() ch.setLevel(logging.DEBUG) # create formatter formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s') # add formatter to ch ch."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://iamgodot.com/posts/"},{"@type":"ListItem","position":3,"name":"Python Logging 源码分析","item":"https://iamgodot.com/posts/sourcecode-of-python-logging/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Python Logging 源码分析","name":"Python Logging 源码分析","description":"阅读了源码之后，我对 Python Logging 模块的几大疑惑都得到了解答：\n为什么 Logger 和 Handler 都有 setLevel 方法？\nLogging 中会出现 Race condition 吗？（感觉都是很直接的 write 操作）\n正式环境中想看日志又没办法动态调整 logLevel，感觉很鸡肋。\n用起来好像还不如 print 方便。\n会有性能问题吗？\n日常使用 首先要了解下 Logging 的用法。\n1. 配置 基本上有三种方式，代码、文件和字典。先看下如何用代码设置：\nimport logging # create logger logger = logging.getLogger(\u0026#39;simple_example\u0026#39;) logger.setLevel(logging.DEBUG) # create console handler and set level to debug ch = logging.StreamHandler() ch.setLevel(logging.DEBUG) # create formatter formatter = logging.Formatter(\u0026#39;%(asctime)s - %(name)s - %(levelname)s - %(message)s\u0026#39;) # add formatter to ch ch.","keywords":["Python Logging","Logging 源码","Logging 用法详解"],"articleBody":"阅读了源码之后，我对 Python Logging 模块的几大疑惑都得到了解答：\n为什么 Logger 和 Handler 都有 setLevel 方法？\nLogging 中会出现 Race condition 吗？（感觉都是很直接的 write 操作）\n正式环境中想看日志又没办法动态调整 logLevel，感觉很鸡肋。\n用起来好像还不如 print 方便。\n会有性能问题吗？\n日常使用 首先要了解下 Logging 的用法。\n1. 配置 基本上有三种方式，代码、文件和字典。先看下如何用代码设置：\nimport logging # create logger logger = logging.getLogger('simple_example') logger.setLevel(logging.DEBUG) # create console handler and set level to debug ch = logging.StreamHandler() ch.setLevel(logging.DEBUG) # create formatter formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s') # add formatter to ch ch.setFormatter(formatter) # add ch to logger logger.addHandler(ch) Logging 的接口很多都是 camelCase 而非 snake_case，应该有历史原因。另外注意 setFormatter 和 addHandler 这种用词的区别，说明 Handler 的 Formatter 只能有一个，而 Logger 可以添加多个 Handler。\n第二种是文件，使用 fileConfig 接口读取，这里要求文件使用符合 ConfigParser 的格式。\n最后是利用 dictConfig 来读取一个字典，这就提供了使用 json/yaml 作为配置文件的可能，也是比较常用的一种方式。\n当然如果不做任何自定义配置也是可以 Logging 的，这时默认会将日志输出到 sys.stderr 并且 logLevel 为 WARNING。\n2. 日志打印 像 debug/info/warning/error 这些方法都会创建对应 logLevel 的日志对象，不过 exception 特殊一点，相当于 error，但是会打印额外的异常信息。\nLogging 本身的操作一般不会导致异常，但如果出现（比如配置错误或者打日志方法传入的字符串 格式化出错），除了 SystemExit 和 KeyboardInterrupt 之外，都会由 Handler 来处理：默认不会抛出，而是将错误打印到 sys.stderr。这种行为是由 logging.raiseExceptions 来控制的，也可以设置为 False，这样就会把异常直接吞掉。\n3. 更多用法 最后还有一些进阶的用法，比如自定义日志对象，可以通过定制的 Filter 添加额外的日志信息：\nimport logging from random import choice class ContextFilter(logging.Filter): \"\"\" This is a filter which injects contextual information into the log. Rather than use actual contextual information, we just use random data in this demo. \"\"\" USERS = ['jim', 'fred', 'sheila'] IPS = ['123.231.231.123', '127.0.0.1', '192.168.0.1'] def filter(self, record): record.ip = choice(ContextFilter.IPS) record.user = choice(ContextFilter.USERS) return True 代码分析 通过画图可以快速熟悉代码中的设计，比如用流程图来展示 Logging 的执行过程：\nflowchart TB Start([\"Start Logging call e.g. Logger.info(...)\"]) --\u003e LoggerLevel{\"Is current\\n level disabled?\"} LoggerLevel --\u003e |No| Stop([\"Stop\"]) LoggerLevel --\u003e |Yes| LogRecord[\"Create log record\"] LogRecord --\u003e Filter{\"Should the record\\n be filtered?\"} Filter --\u003e |Yes| Stop Filter --\u003e |No| Handler subgraph Handler[\"Handle for current logger\"] Lock[\"Acquire RLock\"] --\u003e Emit[\"Format log and write to stream\"] end Handler --\u003e Propagate{\"Should propagate\\n for current logger?\"} Propagate --\u003e |No| Stop Propagate --\u003e |Yes| ParentLogger{\"Is there a\\n parent logger?\"} ParentLogger --\u003e |No| Stop ParentLogger --\u003e |Yes| SetCurrentLogger[\"Set parent logger as current\"] SetCurrentLogger --\u003e Handler 用类图表达各个 Class 之间的关系：\nclassDiagram direction TB Filterer \u003c|-- Logger Filterer \u003c|-- Handler LoggerAdapter \"1\" *-- \"1\" Logger Manager \"1\" *-- \"1..*\" Logger Logger \u003c|-- RootLogger Logger \"1\" *-- \"*\" Filter Logger \"1\" *-- \"*\" Handler Handler \"1\" *-- \"1\" Formatter Handler \u003c-- LogRecord Handler \u003c|-- StreamHandler StreamHandler \u003c|-- FileHandler Formatter \u003c-- LogRecord Filter \u003c-- LogRecord class Manager{ +Logger root +Int disable +Dict loggerDict +getLogger() -_fixupParent() -_fixupChildren() -_clear_cache() } class LoggerAdapter{ +Logger logger +process() +debug/info/warning/error/...() } class Filterer{ +List filters +addFilter() +removeFilter() +filter() } class Logger{ +debug/info/warning/error/...() +isEnabledFor() -_log() +makeRecord() +handle() +addHandler() } class Handler{ -Str _name +Formatter formatter +RLock lock +acquire() +release() +handle() +emit() +flush() +handleError() } class StreamHandler{ +stream +setStream() } class FileHandler{ +filename +name +encoding } class Filter{ +Str name +filter() } class Formatter{ -_fmt -_style +datefmt +format() +formatTime() +formatMessage() +formatException() +formatStack() } class LogRecord{ +Str name +Str msg +args +getMessage() } 至此可以比较清晰地了解日志过程中 Logger/Filter/Handler/Formatter 几个组件之间的交互了。Logging 的实现非常 OOP，但并不是很 Pythonic，比如一些不必要的 Setter/Getter、本应该却没有使用 with 的地方（大量线程锁的获取和释放）、camelCase 的函数命名等等。不过鉴于这个模块出现得很早，可能也背了不少历史包袱吧。\n1. 线程安全 模块中有不少全局的数据结构变量，这也解释了为什么要保证线程安全，比如 logLevel：\nCRITICAL = 50 FATAL = CRITICAL ERROR = 40 WARNING = 30 WARN = WARNING INFO = 20 DEBUG = 10 NOTSET = 0 _levelToName = { CRITICAL: 'CRITICAL', ERROR: 'ERROR', WARNING: 'WARNING', INFO: 'INFO', DEBUG: 'DEBUG', NOTSET: 'NOTSET', } _nameToLevel = { 'CRITICAL': CRITICAL, 'FATAL': FATAL, 'ERROR': ERROR, 'WARN': WARNING, 'WARNING': WARNING, 'INFO': INFO, 'DEBUG': DEBUG, 'NOTSET': NOTSET, } 还有 Handlers：\n_handlers = weakref.WeakValueDictionary() #map of handler names to handlers _handlerList = [] # added to allow handlers to be removed in reverse of order initialized 线程锁的使用主要在两处，一是全局范围的，保证像上面这两种全局变量的安全读写：\n#_lock is used to serialize access to shared data structures in this module. #This needs to be an RLock because fileConfig() creates and configures #Handlers, and so might arbitrary user threads. Since Handler code updates the #shared dictionary _handlers, it needs to acquire the lock. But if configuring, #the lock would already have been acquired - so we need an RLock. #The same argument applies to Loggers and Manager.loggerDict. # _lock = threading.RLock() def _acquireLock(): if _lock: _lock.acquire() def _releaseLock(): if _lock: _lock.release() 如注释所说，因为 fileConfig() 时会重复上锁，需要 Re-entrant lock；另外一处在 Handler 内部：\nclass Handler(Filterer): def createLock(self): \"\"\" Acquire a thread lock for serializing access to the underlying I/O. \"\"\" self.lock = threading.RLock() _register_at_fork_reinit_lock(self) def handle(self, record): rv = self.filter(record) if rv: self.acquire() try: self.emit(record) finally: self.release() return rv 很明显，这里是为了保证 I/O 操作的原子性而上锁，不过似乎用普通的 Mutex 也是可以的。需要注意的是，这里的原子操作只针对一个线程 + 一个文件描述符的场景，如果有两个线程分别打开同一个文件日志的话是存在乱写的可能的，也就是 garble。同理，在多进程下 Logging 是不安全的，比较保险的做法是使用额外的全局锁（效率低）或者 QueueHandler。其实如果不写入文件直接输出到 sys.stderr 问题并不大，即使出现 garble（概率很低）影响也很小，在应用容器之外再做日志收集和聚合就好了。\n为了尽量保证 I/O 不出现 garble，Handler 也尽量做了优化，比如 StreamHandler 的 emit 方法：\nclass StreamHandler(Handler): def emit(self, record): try: msg = self.format(record) stream = self.stream # issue 35046: merged two stream.writes into one. stream.write(msg + self.terminator) # 使用一次 write 操作 self.flush() # 及时清空 buffer 内容 except RecursionError: # See issue 36272 raise except Exception: self.handleError(record) 2. Logger 结构 Logging 对于 Loggers 的结构设计有点类似前缀树。首先是存在一个 Root logger 作为根节点的，这也是为什么可以直接用 import logging;logging.info(...)；其次 name 不为空的 Logger 会按照 . 来切割，比如 a.b.c 这个 Logger 可以被划分为三层，a 和 a.b 这两个 Logger 如果存在的话则作为 a.b.c 的 parent，如果不存在则初始化为 PlaceHolder 占位；最后，每定义一个 Logger 都会创建对应的节点并更新上下游的父子节点。这些逻辑都被封装在 Manager 类中，简单看下代码（这里也可以看出全局线程锁的应用）：\nclass Manager(object): def getLogger(self, name): rv = None if not isinstance(name, str): raise TypeError('A logger name must be a string') _acquireLock() try: if name in self.loggerDict: rv = self.loggerDict[name] if isinstance(rv, PlaceHolder): ph = rv rv = (self.loggerClass or _loggerClass)(name) rv.manager = self self.loggerDict[name] = rv self._fixupChildren(ph, rv) self._fixupParents(rv) else: rv = (self.loggerClass or _loggerClass)(name) rv.manager = self self.loggerDict[name] = rv self._fixupParents(rv) finally: _releaseLock() return rv # 这两个方法会在创建 Logger 时更新相关的父子节点 def _fixupParents(self, alogger): \"\"\" Ensure that there are either loggers or placeholders all the way from the specified logger to the root of the logger hierarchy. \"\"\" name = alogger.name i = name.rfind(\".\") rv = None while (i \u003e 0) and not rv: substr = name[:i] if substr not in self.loggerDict: self.loggerDict[substr] = PlaceHolder(alogger) else: obj = self.loggerDict[substr] if isinstance(obj, Logger): rv = obj else: assert isinstance(obj, PlaceHolder) obj.append(alogger) i = name.rfind(\".\", 0, i - 1) if not rv: rv = self.root alogger.parent = rv def _fixupChildren(self, ph, alogger): \"\"\" Ensure that children of the placeholder ph are connected to the specified logger. \"\"\" name = alogger.name namelen = len(name) for c in ph.loggerMap.keys(): #The if means ... if not c.parent.name.startswith(nm) if c.parent.name[:namelen] != name: alogger.parent = c.parent c.parent = alogger 像 logging.getLogger 实际上就是用的这里提供的接口，除此之外在 propagate 的时候也是通过 Manager 来定位 Parent logger。\n3. 设置 logging level Handler 的 setLevel 其实没什么用，不像 Logger 会使用 logLevel 来辅助判断是否 enabled，Handler 最多在 repr 时打印一下，不过这样设计又会造成两者的 logLevel 不一致，总之使用时以 Logger 为准就好了。\n另外其实在 Logging 的设计中 logLevel 虽然有预设，但是是可以自定义的。大概可能是默认设置已经很够用了，还没见到过哪里真的去做定制的。\n最后，不得不说，Logging 的注释非常详细，甚至有过度解释代码的嫌疑，不过作为这么古老的基础模块，可能也不是一件坏事。\n一些结论 除了代码，Logging 的官方文档也介绍了许多场景下的 Best practice。\n如果想在应用运行过程中更改配置，那么一种简单的实现是使用 fileConfig 并开启额外的端口来监听文件内容的变化。当然如果从更高层的角度来考虑，解决办法还有很多，比如在 Redis 中保存配置，再单独启动一个 Worker 来订阅更新并在变动时重新设置。\n还有关于性能的优化。另外注意不要初始化太多的 Logger，因为这些实例是不会自动 GC 的（正常来说按模块来初始化就够了，比如logger = logging.getLogger(__name__)，这样也正好合理利用了模块的名称来划分 Logger 层级）。如果有需要的话，可以考虑使用 LoggerAdapter 来维护额外的上下文信息。\n最后，到底选择 Logging 还是 print？除了这里提到的，如果涉及到多线程的场景，前者会更安全一些。而 print 简单好用，还不需要额外 import。所以很简单，一切选择都应当以实际场景为准，没有绝对的好坏和对错。\nReferences\nLogging HOWTO - Python Docs Logging Cookbook - Python Docs Logging - The Hitchhiker’s Guide to Python ","wordCount":"1042","inLanguage":"en","datePublished":"2022-04-09T09:52:51+08:00","dateModified":"2022-04-09T09:52:51+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://iamgodot.com/posts/sourcecode-of-python-logging/"},"publisher":{"@type":"Organization","name":"Godot's Blog","logo":{"@type":"ImageObject","url":"https://iamgodot.com/icons/favicon.ico"}}}</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=https://iamgodot.com accesskey=h title="Godot's Blog (Alt + H)">Godot's Blog</a><div class=logo-switches></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Python Logging 源码分析</h1><div class=post-meta><span title='2022-04-09 09:52:51 +0800 +0800'>04-09</span>&nbsp;·&nbsp;5 min</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e6%97%a5%e5%b8%b8%e4%bd%bf%e7%94%a8 aria-label=日常使用>日常使用</a><ul><li><a href=#1-%e9%85%8d%e7%bd%ae aria-label="1. 配置">1. 配置</a></li><li><a href=#2-%e6%97%a5%e5%bf%97%e6%89%93%e5%8d%b0 aria-label="2. 日志打印">2. 日志打印</a></li><li><a href=#3-%e6%9b%b4%e5%a4%9a%e7%94%a8%e6%b3%95 aria-label="3. 更多用法">3. 更多用法</a></li></ul></li><li><a href=#%e4%bb%a3%e7%a0%81%e5%88%86%e6%9e%90 aria-label=代码分析>代码分析</a><ul><li><a href=#1-%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8 aria-label="1. 线程安全">1. 线程安全</a></li><li><a href=#2-logger-%e7%bb%93%e6%9e%84 aria-label="2. Logger 结构">2. Logger 结构</a></li><li><a href=#3-%e8%ae%be%e7%bd%ae-logging-level aria-label="3. 设置 logging level">3. 设置 logging level</a></li></ul></li><li><a href=#%e4%b8%80%e4%ba%9b%e7%bb%93%e8%ae%ba aria-label=一些结论>一些结论</a></li></ul></div></details></div><div class=post-content><p>阅读了源码之后，我对 Python Logging 模块的几大疑惑都得到了解答：</p><ul><li><p>为什么 Logger 和 Handler 都有 <code>setLevel</code> 方法？</p></li><li><p>Logging 中会出现 Race condition 吗？（感觉都是很直接的 write 操作）</p></li><li><p>正式环境中想看日志又没办法动态调整 <code>logLevel</code>，感觉很鸡肋。</p></li><li><p>用起来好像还不如 <code>print</code> 方便。</p></li><li><p>会有性能问题吗？</p></li></ul><h1 id=日常使用>日常使用<a hidden class=anchor aria-hidden=true href=#日常使用>#</a></h1><p>首先要了解下 Logging 的用法。</p><h2 id=1-配置>1. 配置<a hidden class=anchor aria-hidden=true href=#1-配置>#</a></h2><p>基本上有三种方式，代码、文件和字典。先看下如何用代码设置：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> logging
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># create logger</span>
</span></span><span style=display:flex><span>logger <span style=color:#f92672>=</span> logging<span style=color:#f92672>.</span>getLogger(<span style=color:#e6db74>&#39;simple_example&#39;</span>)
</span></span><span style=display:flex><span>logger<span style=color:#f92672>.</span>setLevel(logging<span style=color:#f92672>.</span>DEBUG)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># create console handler and set level to debug</span>
</span></span><span style=display:flex><span>ch <span style=color:#f92672>=</span> logging<span style=color:#f92672>.</span>StreamHandler()
</span></span><span style=display:flex><span>ch<span style=color:#f92672>.</span>setLevel(logging<span style=color:#f92672>.</span>DEBUG)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># create formatter</span>
</span></span><span style=display:flex><span>formatter <span style=color:#f92672>=</span> logging<span style=color:#f92672>.</span>Formatter(<span style=color:#e6db74>&#39;</span><span style=color:#e6db74>%(asctime)s</span><span style=color:#e6db74> - </span><span style=color:#e6db74>%(name)s</span><span style=color:#e6db74> - </span><span style=color:#e6db74>%(levelname)s</span><span style=color:#e6db74> - </span><span style=color:#e6db74>%(message)s</span><span style=color:#e6db74>&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># add formatter to ch</span>
</span></span><span style=display:flex><span>ch<span style=color:#f92672>.</span>setFormatter(formatter)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># add ch to logger</span>
</span></span><span style=display:flex><span>logger<span style=color:#f92672>.</span>addHandler(ch)
</span></span></code></pre></div><p>Logging 的接口很多都是 <code>camelCase</code> 而非 <code>snake_case</code>，应该有历史原因。另外注意 <code>setFormatter</code> 和 <code>addHandler</code> 这种用词的区别，说明 <code>Handler</code> 的 <code>Formatter</code> 只能有一个，而 <code>Logger</code> 可以添加多个 <code>Handler</code>。</p><p>第二种是文件，使用 <code>fileConfig</code> 接口读取，这里要求文件使用符合 <a href=https://docs.python.org/3/library/configparser.html#module-configparser>ConfigParser</a> 的格式。</p><p>最后是利用 <code>dictConfig</code> 来读取一个字典，这就提供了使用 <code>json/yaml</code> 作为配置文件的可能，也是比较常用的一种方式。</p><p>当然如果不做任何自定义配置也是可以 Logging 的，这时默认会将日志输出到 <code>sys.stderr</code> 并且 <code>logLevel</code> 为 <code>WARNING</code>。</p><h2 id=2-日志打印>2. 日志打印<a hidden class=anchor aria-hidden=true href=#2-日志打印>#</a></h2><p>像 <code>debug/info/warning/error</code> 这些方法都会创建对应 <code>logLevel</code> 的日志对象，不过 <code>exception</code> 特殊一点，相当于 <code>error</code>，但是会打印额外的异常信息。</p><p>Logging 本身的操作一般不会导致异常，但如果出现（比如配置错误或者打日志方法传入的字符串 格式化出错），除了 <code>SystemExit</code> 和 <code>KeyboardInterrupt</code> 之外，都会由 <code>Handler</code> 来处理：默认不会抛出，而是将错误打印到 <code>sys.stderr</code>。这种行为是由 <code>logging.raiseExceptions</code> 来控制的，也可以设置为 False，这样就会把异常直接吞掉。</p><h2 id=3-更多用法>3. 更多用法<a hidden class=anchor aria-hidden=true href=#3-更多用法>#</a></h2><p>最后还有一些进阶的用法，比如自定义日志对象，可以通过定制的 <code>Filter</code> 添加额外的日志信息：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> logging
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> random <span style=color:#f92672>import</span> choice
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ContextFilter</span>(logging<span style=color:#f92672>.</span>Filter):
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    This is a filter which injects contextual information into the log.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    Rather than use actual contextual information, we just use random
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    data in this demo.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    USERS <span style=color:#f92672>=</span> [<span style=color:#e6db74>&#39;jim&#39;</span>, <span style=color:#e6db74>&#39;fred&#39;</span>, <span style=color:#e6db74>&#39;sheila&#39;</span>]
</span></span><span style=display:flex><span>    IPS <span style=color:#f92672>=</span> [<span style=color:#e6db74>&#39;123.231.231.123&#39;</span>, <span style=color:#e6db74>&#39;127.0.0.1&#39;</span>, <span style=color:#e6db74>&#39;192.168.0.1&#39;</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>filter</span>(self, record):
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        record<span style=color:#f92672>.</span>ip <span style=color:#f92672>=</span> choice(ContextFilter<span style=color:#f92672>.</span>IPS)
</span></span><span style=display:flex><span>        record<span style=color:#f92672>.</span>user <span style=color:#f92672>=</span> choice(ContextFilter<span style=color:#f92672>.</span>USERS)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>True</span>
</span></span></code></pre></div><h1 id=代码分析>代码分析<a hidden class=anchor aria-hidden=true href=#代码分析>#</a></h1><p>通过画图可以快速熟悉代码中的设计，比如用流程图来展示 Logging 的执行过程：</p><script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script>
<script>mermaid.initialize({startOnLoad:!0,theme:"dark"})</script><div class=mermaid>flowchart TB
Start(["Start Logging call e.g. Logger.info(...)"]) --> LoggerLevel{"Is current\n level disabled?"}
LoggerLevel --> |No| Stop(["Stop"])
LoggerLevel --> |Yes| LogRecord["Create log record"]
LogRecord --> Filter{"Should the record\n be filtered?"}
Filter --> |Yes| Stop
Filter --> |No| Handler
subgraph Handler["Handle for current logger"]
Lock["Acquire RLock"] --> Emit["Format log and write to stream"]
end
Handler --> Propagate{"Should propagate\n for current logger?"}
Propagate --> |No| Stop
Propagate --> |Yes| ParentLogger{"Is there a\n parent logger?"}
ParentLogger --> |No| Stop
ParentLogger --> |Yes| SetCurrentLogger["Set parent logger as current"]
SetCurrentLogger --> Handler</div><p>用类图表达各个 Class 之间的关系：</p><script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script>
<script>mermaid.initialize({startOnLoad:!0,theme:"dark"})</script><div class=mermaid>classDiagram
direction TB
Filterer <|-- Logger
Filterer <|-- Handler
LoggerAdapter "1" *-- "1" Logger
Manager "1" *-- "1..*" Logger
Logger <|-- RootLogger
Logger "1" *-- "*" Filter
Logger "1" *-- "*" Handler
Handler "1" *-- "1" Formatter
Handler <-- LogRecord
Handler <|-- StreamHandler
StreamHandler <|-- FileHandler
Formatter <-- LogRecord
Filter <-- LogRecord
class Manager{
+Logger root
+Int disable
+Dict loggerDict
+getLogger()
-_fixupParent()
-_fixupChildren()
-_clear_cache()
}
class LoggerAdapter{
+Logger logger
+process()
+debug/info/warning/error/...()
}
class Filterer{
+List filters
+addFilter()
+removeFilter()
+filter()
}
class Logger{
+debug/info/warning/error/...()
+isEnabledFor()
-_log()
+makeRecord()
+handle()
+addHandler()
}
class Handler{
-Str _name
+Formatter formatter
+RLock lock
+acquire()
+release()
+handle()
+emit()
+flush()
+handleError()
}
class StreamHandler{
+stream
+setStream()
}
class FileHandler{
+filename
+name
+encoding
}
class Filter{
+Str name
+filter()
}
class Formatter{
-_fmt
-_style
+datefmt
+format()
+formatTime()
+formatMessage()
+formatException()
+formatStack()
}
class LogRecord{
+Str name
+Str msg
+args
+getMessage()
}</div><p>至此可以比较清晰地了解日志过程中 Logger/Filter/Handler/Formatter 几个组件之间的交互了。Logging 的实现非常 OOP，但并不是很 Pythonic，比如一些不必要的 Setter/Getter、本应该却没有使用 <code>with</code> 的地方（大量线程锁的获取和释放）、<code>camelCase</code> 的函数命名等等。不过鉴于这个模块出现得很早，可能也背了不少历史包袱吧。</p><h2 id=1-线程安全>1. 线程安全<a hidden class=anchor aria-hidden=true href=#1-线程安全>#</a></h2><p>模块中有不少全局的数据结构变量，这也解释了为什么要保证线程安全，比如 <code>logLevel</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>CRITICAL <span style=color:#f92672>=</span> <span style=color:#ae81ff>50</span>
</span></span><span style=display:flex><span>FATAL <span style=color:#f92672>=</span> CRITICAL
</span></span><span style=display:flex><span>ERROR <span style=color:#f92672>=</span> <span style=color:#ae81ff>40</span>
</span></span><span style=display:flex><span>WARNING <span style=color:#f92672>=</span> <span style=color:#ae81ff>30</span>
</span></span><span style=display:flex><span>WARN <span style=color:#f92672>=</span> WARNING
</span></span><span style=display:flex><span>INFO <span style=color:#f92672>=</span> <span style=color:#ae81ff>20</span>
</span></span><span style=display:flex><span>DEBUG <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>
</span></span><span style=display:flex><span>NOTSET <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>_levelToName <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    CRITICAL: <span style=color:#e6db74>&#39;CRITICAL&#39;</span>,
</span></span><span style=display:flex><span>    ERROR: <span style=color:#e6db74>&#39;ERROR&#39;</span>,
</span></span><span style=display:flex><span>    WARNING: <span style=color:#e6db74>&#39;WARNING&#39;</span>,
</span></span><span style=display:flex><span>    INFO: <span style=color:#e6db74>&#39;INFO&#39;</span>,
</span></span><span style=display:flex><span>    DEBUG: <span style=color:#e6db74>&#39;DEBUG&#39;</span>,
</span></span><span style=display:flex><span>    NOTSET: <span style=color:#e6db74>&#39;NOTSET&#39;</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>_nameToLevel <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;CRITICAL&#39;</span>: CRITICAL,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;FATAL&#39;</span>: FATAL,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;ERROR&#39;</span>: ERROR,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;WARN&#39;</span>: WARNING,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;WARNING&#39;</span>: WARNING,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;INFO&#39;</span>: INFO,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;DEBUG&#39;</span>: DEBUG,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;NOTSET&#39;</span>: NOTSET,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>还有 <code>Handlers</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>_handlers <span style=color:#f92672>=</span> weakref<span style=color:#f92672>.</span>WeakValueDictionary()  <span style=color:#75715e>#map of handler names to handlers</span>
</span></span><span style=display:flex><span>_handlerList <span style=color:#f92672>=</span> [] <span style=color:#75715e># added to allow handlers to be removed in reverse of order initialized</span>
</span></span></code></pre></div><p>线程锁的使用主要在两处，一是全局范围的，保证像上面这两种全局变量的安全读写：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e>#_lock is used to serialize access to shared data structures in this module.</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#This needs to be an RLock because fileConfig() creates and configures</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#Handlers, and so might arbitrary user threads. Since Handler code updates the</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#shared dictionary _handlers, it needs to acquire the lock. But if configuring,</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#the lock would already have been acquired - so we need an RLock.</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#The same argument applies to Loggers and Manager.loggerDict.</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span><span style=display:flex><span>_lock <span style=color:#f92672>=</span> threading<span style=color:#f92672>.</span>RLock()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>_acquireLock</span>():
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> _lock:
</span></span><span style=display:flex><span>        _lock<span style=color:#f92672>.</span>acquire()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>_releaseLock</span>():
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> _lock:
</span></span><span style=display:flex><span>        _lock<span style=color:#f92672>.</span>release()
</span></span></code></pre></div><p>如注释所说，因为 <code>fileConfig()</code> 时会重复上锁，需要 Re-entrant lock；另外一处在 <code>Handler</code> 内部：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Handler</span>(Filterer):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>createLock</span>(self):
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        Acquire a thread lock for serializing access to the underlying I/O.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>lock <span style=color:#f92672>=</span> threading<span style=color:#f92672>.</span>RLock()
</span></span><span style=display:flex><span>        _register_at_fork_reinit_lock(self)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>handle</span>(self, record):
</span></span><span style=display:flex><span>        rv <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>filter(record)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> rv:
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>acquire()
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>                self<span style=color:#f92672>.</span>emit(record)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>finally</span>:
</span></span><span style=display:flex><span>                self<span style=color:#f92672>.</span>release()
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> rv
</span></span></code></pre></div><p>很明显，这里是为了保证 <code>I/O</code> 操作的原子性而上锁，不过似乎用普通的 <code>Mutex</code> 也是可以的。需要注意的是，这里的原子操作只针对一个线程 + 一个文件描述符的场景，如果有两个线程分别打开同一个文件日志的话是存在乱写的可能的，也就是 <code>garble</code>。同理，在多进程下 Logging 是不安全的，比较保险的做法是使用额外的全局锁（效率低）或者 <code>QueueHandler</code>。其实如果不写入文件直接输出到 <code>sys.stderr</code> 问题并不大，即使出现 <code>garble</code>（概率很低）影响也很小，在应用容器之外再做日志收集和聚合就好了。</p><p>为了尽量保证 <code>I/O</code> 不出现 <code>garble</code>，<code>Handler</code> 也尽量做了优化，比如 <code>StreamHandler</code> 的 <code>emit</code> 方法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>StreamHandler</span>(Handler):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>emit</span>(self, record):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>            msg <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>format(record)
</span></span><span style=display:flex><span>            stream <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>stream
</span></span><span style=display:flex><span>            <span style=color:#75715e># issue 35046: merged two stream.writes into one.</span>
</span></span><span style=display:flex><span>            stream<span style=color:#f92672>.</span>write(msg <span style=color:#f92672>+</span> self<span style=color:#f92672>.</span>terminator)  <span style=color:#75715e># 使用一次 write 操作</span>
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>flush()  <span style=color:#75715e># 及时清空 buffer 内容</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>except</span> <span style=color:#a6e22e>RecursionError</span>:  <span style=color:#75715e># See issue 36272</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>raise</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>except</span> <span style=color:#a6e22e>Exception</span>:
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>handleError(record)
</span></span></code></pre></div><h2 id=2-logger-结构>2. Logger 结构<a hidden class=anchor aria-hidden=true href=#2-logger-结构>#</a></h2><p>Logging 对于 Loggers 的结构设计有点类似前缀树。首先是存在一个 Root logger 作为根节点的，这也是为什么可以直接用 <code>import logging;logging.info(...)</code>；其次 <code>name</code> 不为空的 Logger 会按照 <code>.</code> 来切割，比如 <code>a.b.c</code> 这个 Logger 可以被划分为三层，<code>a</code> 和 <code>a.b</code> 这两个 Logger 如果存在的话则作为 <code>a.b.c</code> 的 parent，如果不存在则初始化为 <code>PlaceHolder</code> 占位；最后，每定义一个 Logger 都会创建对应的节点并更新上下游的父子节点。这些逻辑都被封装在 <code>Manager</code> 类中，简单看下代码（这里也可以看出全局线程锁的应用）：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Manager</span>(object):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>getLogger</span>(self, name):
</span></span><span style=display:flex><span>        rv <span style=color:#f92672>=</span> <span style=color:#66d9ef>None</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> isinstance(name, str):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>raise</span> <span style=color:#a6e22e>TypeError</span>(<span style=color:#e6db74>&#39;A logger name must be a string&#39;</span>)
</span></span><span style=display:flex><span>        _acquireLock()
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> name <span style=color:#f92672>in</span> self<span style=color:#f92672>.</span>loggerDict:
</span></span><span style=display:flex><span>                rv <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>loggerDict[name]
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> isinstance(rv, PlaceHolder):
</span></span><span style=display:flex><span>                    ph <span style=color:#f92672>=</span> rv
</span></span><span style=display:flex><span>                    rv <span style=color:#f92672>=</span> (self<span style=color:#f92672>.</span>loggerClass <span style=color:#f92672>or</span> _loggerClass)(name)
</span></span><span style=display:flex><span>                    rv<span style=color:#f92672>.</span>manager <span style=color:#f92672>=</span> self
</span></span><span style=display:flex><span>                    self<span style=color:#f92672>.</span>loggerDict[name] <span style=color:#f92672>=</span> rv
</span></span><span style=display:flex><span>                    self<span style=color:#f92672>.</span>_fixupChildren(ph, rv)
</span></span><span style=display:flex><span>                    self<span style=color:#f92672>.</span>_fixupParents(rv)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>                rv <span style=color:#f92672>=</span> (self<span style=color:#f92672>.</span>loggerClass <span style=color:#f92672>or</span> _loggerClass)(name)
</span></span><span style=display:flex><span>                rv<span style=color:#f92672>.</span>manager <span style=color:#f92672>=</span> self
</span></span><span style=display:flex><span>                self<span style=color:#f92672>.</span>loggerDict[name] <span style=color:#f92672>=</span> rv
</span></span><span style=display:flex><span>                self<span style=color:#f92672>.</span>_fixupParents(rv)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>finally</span>:
</span></span><span style=display:flex><span>            _releaseLock()
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> rv
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 这两个方法会在创建 Logger 时更新相关的父子节点</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>_fixupParents</span>(self, alogger):
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        Ensure that there are either loggers or placeholders all the way
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        from the specified logger to the root of the logger hierarchy.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>        name <span style=color:#f92672>=</span> alogger<span style=color:#f92672>.</span>name
</span></span><span style=display:flex><span>        i <span style=color:#f92672>=</span> name<span style=color:#f92672>.</span>rfind(<span style=color:#e6db74>&#34;.&#34;</span>)
</span></span><span style=display:flex><span>        rv <span style=color:#f92672>=</span> <span style=color:#66d9ef>None</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (i <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) <span style=color:#f92672>and</span> <span style=color:#f92672>not</span> rv:
</span></span><span style=display:flex><span>            substr <span style=color:#f92672>=</span> name[:i]
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> substr <span style=color:#f92672>not</span> <span style=color:#f92672>in</span> self<span style=color:#f92672>.</span>loggerDict:
</span></span><span style=display:flex><span>                self<span style=color:#f92672>.</span>loggerDict[substr] <span style=color:#f92672>=</span> PlaceHolder(alogger)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>                obj <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>loggerDict[substr]
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> isinstance(obj, Logger):
</span></span><span style=display:flex><span>                    rv <span style=color:#f92672>=</span> obj
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>assert</span> isinstance(obj, PlaceHolder)
</span></span><span style=display:flex><span>                    obj<span style=color:#f92672>.</span>append(alogger)
</span></span><span style=display:flex><span>            i <span style=color:#f92672>=</span> name<span style=color:#f92672>.</span>rfind(<span style=color:#e6db74>&#34;.&#34;</span>, <span style=color:#ae81ff>0</span>, i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> rv:
</span></span><span style=display:flex><span>            rv <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>root
</span></span><span style=display:flex><span>        alogger<span style=color:#f92672>.</span>parent <span style=color:#f92672>=</span> rv
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>_fixupChildren</span>(self, ph, alogger):
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        Ensure that children of the placeholder ph are connected to the
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        specified logger.
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>        name <span style=color:#f92672>=</span> alogger<span style=color:#f92672>.</span>name
</span></span><span style=display:flex><span>        namelen <span style=color:#f92672>=</span> len(name)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> c <span style=color:#f92672>in</span> ph<span style=color:#f92672>.</span>loggerMap<span style=color:#f92672>.</span>keys():
</span></span><span style=display:flex><span>            <span style=color:#75715e>#The if means ... if not c.parent.name.startswith(nm)</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> c<span style=color:#f92672>.</span>parent<span style=color:#f92672>.</span>name[:namelen] <span style=color:#f92672>!=</span> name:
</span></span><span style=display:flex><span>                alogger<span style=color:#f92672>.</span>parent <span style=color:#f92672>=</span> c<span style=color:#f92672>.</span>parent
</span></span><span style=display:flex><span>                c<span style=color:#f92672>.</span>parent <span style=color:#f92672>=</span> alogger
</span></span></code></pre></div><p>像 <code>logging.getLogger</code> 实际上就是用的这里提供的接口，除此之外在 <code>propagate</code> 的时候也是通过 <code>Manager</code> 来定位 Parent logger。</p><h2 id=3-设置-logging-level>3. 设置 logging level<a hidden class=anchor aria-hidden=true href=#3-设置-logging-level>#</a></h2><p><code>Handler</code> 的 <code>setLevel</code> 其实没什么用，不像 <code>Logger</code> 会使用 <code>logLevel</code> 来辅助判断是否 <code>enabled</code>，<code>Handler</code> 最多在 <code>repr</code> 时打印一下，不过这样设计又会造成两者的 <code>logLevel</code> 不一致，总之使用时以 <code>Logger</code> 为准就好了。</p><p>另外其实在 Logging 的设计中 <code>logLevel</code> 虽然有预设，但是是可以自定义的。大概可能是默认设置已经很够用了，还没见到过哪里真的去做定制的。</p><p>最后，不得不说，Logging 的注释非常详细，甚至有过度解释代码的嫌疑，不过作为这么古老的基础模块，可能也不是一件坏事。</p><h1 id=一些结论>一些结论<a hidden class=anchor aria-hidden=true href=#一些结论>#</a></h1><p>除了代码，Logging 的官方文档也介绍了许多场景下的 Best practice。</p><p>如果想在应用运行过程中更改配置，那么一种简单的实现是使用 <code>fileConfig</code> 并开启额外的端口来监听文件内容的变化。当然如果从更高层的角度来考虑，解决办法还有很多，比如在 Redis 中保存配置，再单独启动一个 Worker 来订阅更新并在变动时重新设置。</p><p>还有关于<a href=https://docs.python.org/3/howto/logging.html#optimization>性能的优化</a>。另外注意不要初始化太多的 Logger，因为这些实例是不会自动 GC 的（正常来说按模块来初始化就够了，比如<code>logger = logging.getLogger(__name__)</code>，这样也正好合理利用了模块的名称来划分 Logger 层级）。如果有需要的话，可以考虑使用 <code>LoggerAdapter</code> 来维护额外的上下文信息。</p><p>最后，到底选择 Logging 还是 <code>print</code>？除了<a href=https://docs.python-guide.org/writing/logging/#or-print>这里</a>提到的，如果涉及到多线程的场景，前者会更安全一些。而 <code>print</code> 简单好用，还不需要额外 <code>import</code>。所以很简单，一切选择都应当以实际场景为准，没有绝对的好坏和对错。</p><hr><p><em>References</em></p><ul><li><a href=https://docs.python.org/3/howto/logging.html>Logging HOWTO - Python Docs</a></li><li><a href=https://docs.python.org/3/howto/logging-cookbook.html>Logging Cookbook - Python Docs</a></li><li><a href=https://docs.python-guide.org/writing/logging/>Logging - The Hitchhiker&rsquo;s Guide to Python</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://iamgodot.com/tags/python/>python</a></li></ul><nav class=paginav><a class=prev href=https://iamgodot.com/posts/sourcecode-of-python-threadlocal/><span class=title>« Prev</span><br><span>Python 中的 TLS 是如何实现的</span></a>
<a class=next href=https://iamgodot.com/posts/about-pager/><span class=title>Next »</span><br><span>关于 Pager</span></a></nav></footer><script src=https://giscus.app/client.js data-repo=iamgodot/godot-blog-comments data-repo-id="MDEwOlJlcG9zaXRvcnkzOTk0Nzk0MTY=" data-category=Announcements data-category-id=DIC_kwDOF8-SeM4CO3OX data-mapping=pathname data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=dark_dimmed data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2020-2023 <a href=https://iamgodot.com>Godot's Blog</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>