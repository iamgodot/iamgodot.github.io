<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Find Median | Godot's Blog - 个人生活分享</title><meta name=keywords content="dsa"><meta name=description content="祸从天降的一天。
早上起不来，于是刷手机清醒一下，突然看到一个 ACMer 楼主提到自己没有刷过 Leetcode，面试的时候差点儿被打脸了。
看了一下题目，要求是 O(logn) 的复杂度，默默想了想，没有特别清晰的思路。
结果翻了翻评论，很多人都在蜻蜓点水般地表示二分查找不断分割就可以了。
要那么简单还用你说吗？起床了起床了。
题目是这样的：
给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的中位数。
我本来的想法是归并之后计算中位数，但只能做到 O(m+n)，再优化感觉只能二分了。
于是又开始想分别取两个数组的中位数，比较之后就可以各扔掉一半，然后对两个折半的数组继续取中位数比较。
比如一开始找到的中位数是这样：[&mldr;5&mldr;], [&mldr;10&mldr;]，那么 5 的左边和 10 的右边就可以丢掉了，因为最终的中位数肯定在 5 和 10 中间。
如果接下来是这样：[5..8&mldr;], [&mldr;7..10]，那么 8 的右边和 7 的左边也可以丢掉，因为比 8 大的元素数量达不到这两个小数组的一半，所以中位数不会在里面，比 7 小的同理。
一直重复这个流程，最后得到的肯定就是一个或两个数，平均下就好了，时间复杂度也是符合要求的 O(logn).
结果等到看完标答后我才反应过来自己错在哪里了，这是后话。（因为 m 和 n 不一定一样大，所以显然折半的逻辑不对）
最优的解决方案是可以做到 O(log min(m, n)) 的，核心也是二分法，不过思路要复杂一些：
首先明确中位数的定义。对于奇数个数字来说是最中间的元素，偶数则是中间两个元素的平均值。 要做的是将两个数组各分一刀，假设划分的下标分别是 i 和 j，那么 nums1 被分成 nums1[0, i], nums1[i:]，而 nums2 分为 nums2[0, j], nums2[j:]. 因为数组中元素的数量是奇是偶不一定，所以规定好是奇数的话多的一个放到左边。如此 i 的位置就是右边部分的第一个，而左半边正好有 i 个元素。 下标 i 和 j 之间是存在一个等式关系的，因为是中位数，所以 i + j 等于元素总数的一半，或者一半多一个（因为说好了左边多一个嘛）。那么就有 i+j=(m+n)/2 | i+j=(m+n)/2+1，合并起来写成 (m+n+1)/2."><meta name=author content><link rel=canonical href=https://iamgodot.com/posts/find-median/><link crossorigin=anonymous href=/assets/css/stylesheet.min.7cb1aaa4414c482febc7034a427761d087a2cf358f1be8f7beba5afc947b57d0.css integrity="sha256-fLGqpEFMSC/rxwNKQndh0IeizzWPG+j3vrpa/JR7V9A=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js integrity="sha256-uVus3DnjejMqn4g7Hni+Srwf3KK8HyZB9V4809q9TWE=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://iamgodot.com/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://iamgodot.com/icons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://iamgodot.com/icons/favicon-32x32.png><link rel=apple-touch-icon href=https://iamgodot.com/icons/apple-touch-icon.png><link rel=mask-icon href=https://iamgodot.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=preload as=style href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;700&family=Source+Code+Pro:wght@400;700&display=swap"><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;700&family=Source+Code+Pro:wght@400;700&display=swap" media=print onload='this.media="all"'><link rel=preconnect href=https://plausible.iamgodot.com><script defer data-domain=iamgodot.com src=https://plausible.iamgodot.com/js/plausible.js></script>
<script>window.plausible=window.plausible||function(){(window.plausible.q=window.plausible.q||[]).push(arguments)}</script><script></script><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-157042624-1","auto"),ga("send","pageview"))</script><meta property="og:title" content="Find Median"><meta property="og:description" content="祸从天降的一天。
早上起不来，于是刷手机清醒一下，突然看到一个 ACMer 楼主提到自己没有刷过 Leetcode，面试的时候差点儿被打脸了。
看了一下题目，要求是 O(logn) 的复杂度，默默想了想，没有特别清晰的思路。
结果翻了翻评论，很多人都在蜻蜓点水般地表示二分查找不断分割就可以了。
要那么简单还用你说吗？起床了起床了。
题目是这样的：
给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的中位数。
我本来的想法是归并之后计算中位数，但只能做到 O(m+n)，再优化感觉只能二分了。
于是又开始想分别取两个数组的中位数，比较之后就可以各扔掉一半，然后对两个折半的数组继续取中位数比较。
比如一开始找到的中位数是这样：[&mldr;5&mldr;], [&mldr;10&mldr;]，那么 5 的左边和 10 的右边就可以丢掉了，因为最终的中位数肯定在 5 和 10 中间。
如果接下来是这样：[5..8&mldr;], [&mldr;7..10]，那么 8 的右边和 7 的左边也可以丢掉，因为比 8 大的元素数量达不到这两个小数组的一半，所以中位数不会在里面，比 7 小的同理。
一直重复这个流程，最后得到的肯定就是一个或两个数，平均下就好了，时间复杂度也是符合要求的 O(logn).
结果等到看完标答后我才反应过来自己错在哪里了，这是后话。（因为 m 和 n 不一定一样大，所以显然折半的逻辑不对）
最优的解决方案是可以做到 O(log min(m, n)) 的，核心也是二分法，不过思路要复杂一些：
首先明确中位数的定义。对于奇数个数字来说是最中间的元素，偶数则是中间两个元素的平均值。 要做的是将两个数组各分一刀，假设划分的下标分别是 i 和 j，那么 nums1 被分成 nums1[0, i], nums1[i:]，而 nums2 分为 nums2[0, j], nums2[j:]. 因为数组中元素的数量是奇是偶不一定，所以规定好是奇数的话多的一个放到左边。如此 i 的位置就是右边部分的第一个，而左半边正好有 i 个元素。 下标 i 和 j 之间是存在一个等式关系的，因为是中位数，所以 i + j 等于元素总数的一半，或者一半多一个（因为说好了左边多一个嘛）。那么就有 i+j=(m+n)/2 | i+j=(m+n)/2+1，合并起来写成 (m+n+1)/2."><meta property="og:type" content="article"><meta property="og:url" content="https://iamgodot.com/posts/find-median/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-11-03T17:07:04+08:00"><meta property="article:modified_time" content="2021-11-03T17:07:04+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Find Median"><meta name=twitter:description content="祸从天降的一天。
早上起不来，于是刷手机清醒一下，突然看到一个 ACMer 楼主提到自己没有刷过 Leetcode，面试的时候差点儿被打脸了。
看了一下题目，要求是 O(logn) 的复杂度，默默想了想，没有特别清晰的思路。
结果翻了翻评论，很多人都在蜻蜓点水般地表示二分查找不断分割就可以了。
要那么简单还用你说吗？起床了起床了。
题目是这样的：
给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的中位数。
我本来的想法是归并之后计算中位数，但只能做到 O(m+n)，再优化感觉只能二分了。
于是又开始想分别取两个数组的中位数，比较之后就可以各扔掉一半，然后对两个折半的数组继续取中位数比较。
比如一开始找到的中位数是这样：[&mldr;5&mldr;], [&mldr;10&mldr;]，那么 5 的左边和 10 的右边就可以丢掉了，因为最终的中位数肯定在 5 和 10 中间。
如果接下来是这样：[5..8&mldr;], [&mldr;7..10]，那么 8 的右边和 7 的左边也可以丢掉，因为比 8 大的元素数量达不到这两个小数组的一半，所以中位数不会在里面，比 7 小的同理。
一直重复这个流程，最后得到的肯定就是一个或两个数，平均下就好了，时间复杂度也是符合要求的 O(logn).
结果等到看完标答后我才反应过来自己错在哪里了，这是后话。（因为 m 和 n 不一定一样大，所以显然折半的逻辑不对）
最优的解决方案是可以做到 O(log min(m, n)) 的，核心也是二分法，不过思路要复杂一些：
首先明确中位数的定义。对于奇数个数字来说是最中间的元素，偶数则是中间两个元素的平均值。 要做的是将两个数组各分一刀，假设划分的下标分别是 i 和 j，那么 nums1 被分成 nums1[0, i], nums1[i:]，而 nums2 分为 nums2[0, j], nums2[j:]. 因为数组中元素的数量是奇是偶不一定，所以规定好是奇数的话多的一个放到左边。如此 i 的位置就是右边部分的第一个，而左半边正好有 i 个元素。 下标 i 和 j 之间是存在一个等式关系的，因为是中位数，所以 i + j 等于元素总数的一半，或者一半多一个（因为说好了左边多一个嘛）。那么就有 i+j=(m+n)/2 | i+j=(m+n)/2+1，合并起来写成 (m+n+1)/2."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://iamgodot.com/posts/"},{"@type":"ListItem","position":3,"name":"Find Median","item":"https://iamgodot.com/posts/find-median/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Find Median","name":"Find Median","description":"祸从天降的一天。\n早上起不来，于是刷手机清醒一下，突然看到一个 ACMer 楼主提到自己没有刷过 Leetcode，面试的时候差点儿被打脸了。\n看了一下题目，要求是 O(logn) 的复杂度，默默想了想，没有特别清晰的思路。\n结果翻了翻评论，很多人都在蜻蜓点水般地表示二分查找不断分割就可以了。\n要那么简单还用你说吗？起床了起床了。\n题目是这样的：\n给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的中位数。\n我本来的想法是归并之后计算中位数，但只能做到 O(m+n)，再优化感觉只能二分了。\n于是又开始想分别取两个数组的中位数，比较之后就可以各扔掉一半，然后对两个折半的数组继续取中位数比较。\n比如一开始找到的中位数是这样：[\u0026hellip;5\u0026hellip;], [\u0026hellip;10\u0026hellip;]，那么 5 的左边和 10 的右边就可以丢掉了，因为最终的中位数肯定在 5 和 10 中间。\n如果接下来是这样：[5..8\u0026hellip;], [\u0026hellip;7..10]，那么 8 的右边和 7 的左边也可以丢掉，因为比 8 大的元素数量达不到这两个小数组的一半，所以中位数不会在里面，比 7 小的同理。\n一直重复这个流程，最后得到的肯定就是一个或两个数，平均下就好了，时间复杂度也是符合要求的 O(logn).\n结果等到看完标答后我才反应过来自己错在哪里了，这是后话。（因为 m 和 n 不一定一样大，所以显然折半的逻辑不对）\n最优的解决方案是可以做到 O(log min(m, n)) 的，核心也是二分法，不过思路要复杂一些：\n首先明确中位数的定义。对于奇数个数字来说是最中间的元素，偶数则是中间两个元素的平均值。 要做的是将两个数组各分一刀，假设划分的下标分别是 i 和 j，那么 nums1 被分成 nums1[0, i], nums1[i:]，而 nums2 分为 nums2[0, j], nums2[j:]. 因为数组中元素的数量是奇是偶不一定，所以规定好是奇数的话多的一个放到左边。如此 i 的位置就是右边部分的第一个，而左半边正好有 i 个元素。 下标 i 和 j 之间是存在一个等式关系的，因为是中位数，所以 i + j 等于元素总数的一半，或者一半多一个（因为说好了左边多一个嘛）。那么就有 i+j=(m+n)/2 | i+j=(m+n)/2+1，合并起来写成 (m+n+1)/2.","keywords":["dsa"],"articleBody":"祸从天降的一天。\n早上起不来，于是刷手机清醒一下，突然看到一个 ACMer 楼主提到自己没有刷过 Leetcode，面试的时候差点儿被打脸了。\n看了一下题目，要求是 O(logn) 的复杂度，默默想了想，没有特别清晰的思路。\n结果翻了翻评论，很多人都在蜻蜓点水般地表示二分查找不断分割就可以了。\n要那么简单还用你说吗？起床了起床了。\n题目是这样的：\n给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的中位数。\n我本来的想法是归并之后计算中位数，但只能做到 O(m+n)，再优化感觉只能二分了。\n于是又开始想分别取两个数组的中位数，比较之后就可以各扔掉一半，然后对两个折半的数组继续取中位数比较。\n比如一开始找到的中位数是这样：[…5…], […10…]，那么 5 的左边和 10 的右边就可以丢掉了，因为最终的中位数肯定在 5 和 10 中间。\n如果接下来是这样：[5..8…], […7..10]，那么 8 的右边和 7 的左边也可以丢掉，因为比 8 大的元素数量达不到这两个小数组的一半，所以中位数不会在里面，比 7 小的同理。\n一直重复这个流程，最后得到的肯定就是一个或两个数，平均下就好了，时间复杂度也是符合要求的 O(logn).\n结果等到看完标答后我才反应过来自己错在哪里了，这是后话。（因为 m 和 n 不一定一样大，所以显然折半的逻辑不对）\n最优的解决方案是可以做到 O(log min(m, n)) 的，核心也是二分法，不过思路要复杂一些：\n首先明确中位数的定义。对于奇数个数字来说是最中间的元素，偶数则是中间两个元素的平均值。 要做的是将两个数组各分一刀，假设划分的下标分别是 i 和 j，那么 nums1 被分成 nums1[0, i], nums1[i:]，而 nums2 分为 nums2[0, j], nums2[j:]. 因为数组中元素的数量是奇是偶不一定，所以规定好是奇数的话多的一个放到左边。如此 i 的位置就是右边部分的第一个，而左半边正好有 i 个元素。 下标 i 和 j 之间是存在一个等式关系的，因为是中位数，所以 i + j 等于元素总数的一半，或者一半多一个（因为说好了左边多一个嘛）。那么就有 i+j=(m+n)/2 | i+j=(m+n)/2+1，合并起来写成 (m+n+1)/2. 一开始 i 的选择就先定在 nums1 的中间位置，然后根据规则不断地二分，如此就完成了最核心的循环。那么根据什么规则呢？就是两个左半部分不能大于两个右半部分，也就是 nums1[i-1]\u003c=nums2[j] \u0026 nums2[j-1]\u003c=nums1[i]. 还要注意的是 i 不是每次向左或向右移动一位，而是要按照二分的规则走，不然就变成线性的复杂度了。 解决了核心逻辑，还有两个问题要考虑： 1. 中位数计算。走完了循环我们可以获得四个数值，也就是 i-1, i, j-1, j 对应的四个元素。 1. 如果元素总数是奇数的话，我们比较 nums1[i-1] 和 nums2[j-1] 取个大的就好了（还是那句话，说好了左边多一个嘛）。 2. 否则就要取中间两个数平均了。这两个数就是两个左边的最大值，和两个右边的最小值。 2. 边界条件。之所以后说这个是因为中位数计算的时候不考虑边界就会报错，比如对 i 来说，如果 i=0 或者 i=m 的话都是会出界的，所以要分别处理。 1. 如果 i=0，说明 nums1 的左半部分为空，那么就假设这里的最大值为无限小，这样比较的话就相当于只考虑 nums2 的左半部分了。 2. 如果 i=m，说明 nums1 的右半部分为空，那么就假设这里的最小值为无限大，这样比较的话就相当于只考虑 nums2 的右半部分了。 上代码：\ndef find_median(nums1, nums2): if len(nums1) \u003e len(nums2): nums1, nums2 = nums2, nums1 m, n = len(nums1), len(nums2) left, right = 0, m total_left = (m + n + 1) // 2 # 注意用 // 而不是 /，因为下标不能是浮点数 while left \u003c right: i = left + (right - left + 1) // 2 # 注意用 // 而不是 /，因为下标不能是浮点数 j = total_left - i if nums1[i - 1] \u003e nums2[j]: right = i - 1 else: left = i i, j = left, total_left - left first_left_max = nums1[i - 1] if i \u003e 0 else -float(\"inf\") first_right_min = nums1[i] if i \u003c m else float(\"inf\") second_left_max = nums2[j - 1] if j \u003e 0 else -float(\"inf\") second_right_min = nums2[j] if j \u003c n else float(\"inf\") if (m + n) % 2 == 1: return max(first_left_max, second_left_max) else: return ( max(first_left_max, second_left_max) + min(first_right_min, second_right_min) ) / 2 用 Python 实现的话，有两点需要注意：\n计算 total_left 和 i 的时候要用 //. 使用 float(\"inf\") 来表示极大值，加负号表示极小值。 到了这里基本就结束了，但是仔细看会发现函数的一开始会比较两个数组的长度，进而保证 nums1 是长度更短的那一个。\n这是因为如果 nums1 非常长而 nums2 很短会造成 j = total_left - i 计算出来的 j 超过 nums2 的长度而出界。\n而这是因为 i 是根据 left 和 right 计算得到的（也就是 m），从而能保证界限，j 是减出来的就不一定保险了。\n最后来看一下这种方法的复杂度，因为保证了 nums1 较短，所以二分得到的时间复杂度为 O(logmin(m, n))，空间复杂度 O(1).\n虽说上面的解法最优，但并不是一个很通用的方案，可以找到中位数，但对于求 k 位数这种问题就解决不了了。又看了下官方次优的解法，虽然时间复杂度为 O(log(m+n))，但是更普适：\n分别找出两个数组的 k/2-1 的位置，那么这个位置前面有 k/2-1 个元素。 两个位置上的元素分别成为 pivot1, pivot2，如果 pivot1 的值小于 pivot2 的值，则可以舍弃 pivot1 及前面的 k/2-1 个元素。（因为即使 pivot2 前面的元素都小于 pivot1，pivot1 最多也就是第 k-1 大的元素，中位数肯定不在其中） 去掉了这部分元素之后 nums1 就相当于变短了，而 nums2 不变，于是基于这两个数组继续。 同时也要记得更新 k 值，因为已经去掉一部分元素了，所以 k 变为了原来的一半。 继续此流程。当然过程中还要注意空数组、下标越界和 k=1 等边界情况。 此处不贴代码了，见官方答案。 实现代码如下：\ndef find_median(nums1, nums2): def find_kth_element(k, nums1, nums2): '''注意 k 是从 1 开始而不是 0''' m, n = len(nums1), len(nums2) start1, start2 = 0, 0 while True: if start1 == m: return nums2[start2 + k - 1] if start2 == n: return nums1[start1 + k - 1] if k == 1: return min(nums1[start1], nums2[start2]) # 因为 if 检查在上面，所以要取 min 防止下面 nums1[i] 或 nums2[j] 越界 i = min(start1 + k // 2 - 1, m - 1) j = min(start2 + k // 2 - 1, n - 1) if nums1[i] \u003c= nums2[j]: # k 的更新基于 start1，所以先改 k 再改 start1 k -= i - start1 + 1 start1 = i + 1 else: k -= j - start2 + 1 start2 = j + 1 length = len(nums1) + len(nums2) if length % 2 == 1: return find_kth_element(length // 2 + 1, nums1, nums2) else: return ( find_kth_element(length // 2, nums1, nums2) + find_kth_element(length // 2 + 1, nums1, nums2) ) / 2 整理完思路和代码已经是下午了，疲惫地什么都不想做。刷手机须谨慎，有风险别乱看。\nReferences\nMedia of two sorted arrays 官方答案 - Leetcode 个人觉得比较容易理解的答案 - Leetcode ","wordCount":"541","inLanguage":"en","datePublished":"2021-11-03T17:07:04+08:00","dateModified":"2021-11-03T17:07:04+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://iamgodot.com/posts/find-median/"},"publisher":{"@type":"Organization","name":"Godot's Blog - 个人生活分享","logo":{"@type":"ImageObject","url":"https://iamgodot.com/icons/favicon.ico"}}}</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=https://iamgodot.com accesskey=h title="Godot's Blog - 个人生活分享 (Alt + H)">Godot's Blog - 个人生活分享</a>
<span class=logo-switches></span></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Find Median</h1><div class=post-meta><span title='2021-11-03 17:07:04 +0800 +0800'>11-03</span>&nbsp;·&nbsp;3 min</div></header><div class=post-content><p>祸从天降的一天。</p><p>早上起不来，于是刷手机清醒一下，突然看到一个 ACMer 楼主提到自己没有刷过 Leetcode，面试的时候差点儿被打脸了。</p><p>看了一下题目，要求是 O(logn) 的复杂度，默默想了想，没有特别清晰的思路。</p><p>结果翻了翻评论，很多人都在蜻蜓点水般地表示二分查找不断分割就可以了。</p><p>要那么简单还用你说吗？起床了起床了。</p><p>题目是这样的：</p><blockquote><p>给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的中位数。</p></blockquote><p>我本来的想法是归并之后计算中位数，但只能做到 O(m+n)，再优化感觉只能二分了。</p><p>于是又开始想分别取两个数组的中位数，比较之后就可以各扔掉一半，然后对两个折半的数组继续取中位数比较。</p><p>比如一开始找到的中位数是这样：[&mldr;5&mldr;], [&mldr;10&mldr;]，那么 5 的左边和 10 的右边就可以丢掉了，因为最终的中位数肯定在 5 和 10 中间。</p><p>如果接下来是这样：[5..8&mldr;], [&mldr;7..10]，那么 8 的右边和 7 的左边也可以丢掉，因为比 8 大的元素数量达不到这两个小数组的一半，所以中位数不会在里面，比 7 小的同理。</p><p>一直重复这个流程，最后得到的肯定就是一个或两个数，平均下就好了，时间复杂度也是符合要求的 O(logn).</p><p>结果等到看完标答后我才反应过来自己错在哪里了，这是后话。（因为 m 和 n 不一定一样大，所以显然折半的逻辑不对）</p><p>最优的解决方案是可以做到 O(log min(m, n)) 的，核心也是二分法，不过思路要复杂一些：</p><ol><li>首先明确中位数的定义。对于奇数个数字来说是最中间的元素，偶数则是中间两个元素的平均值。</li><li>要做的是将两个数组各分一刀，假设划分的下标分别是 i 和 j，那么 nums1 被分成 nums1[0, i], nums1[i:]，而 nums2 分为 nums2[0, j], nums2[j:].</li><li>因为数组中元素的数量是奇是偶不一定，所以规定好是奇数的话多的一个放到左边。如此 i 的位置就是右边部分的第一个，而左半边正好有 i 个元素。</li><li>下标 i 和 j 之间是存在一个等式关系的，因为是中位数，所以 i + j 等于元素总数的一半，或者一半多一个（因为说好了左边多一个嘛）。那么就有 i+j=(m+n)/2 | i+j=(m+n)/2+1，合并起来写成 (m+n+1)/2.</li><li>一开始 i 的选择就先定在 nums1 的中间位置，然后根据规则不断地二分，如此就完成了最核心的循环。那么根据什么规则呢？就是两个左半部分不能大于两个右半部分，也就是 nums1[i-1]&lt;=nums2[j] & nums2[j-1]&lt;=nums1[i].</li><li>还要注意的是 i 不是每次向左或向右移动一位，而是要按照二分的规则走，不然就变成线性的复杂度了。</li><li>解决了核心逻辑，还有两个问题要考虑：
1. 中位数计算。走完了循环我们可以获得四个数值，也就是 i-1, i, j-1, j 对应的四个元素。
1. 如果元素总数是奇数的话，我们比较 nums1[i-1] 和 nums2[j-1] 取个大的就好了（还是那句话，说好了左边多一个嘛）。
2. 否则就要取中间两个数平均了。这两个数就是两个左边的最大值，和两个右边的最小值。
2. 边界条件。之所以后说这个是因为中位数计算的时候不考虑边界就会报错，比如对 i 来说，如果 i=0 或者 i=m 的话都是会出界的，所以要分别处理。
1. 如果 i=0，说明 nums1 的左半部分为空，那么就假设这里的最大值为无限小，这样比较的话就相当于只考虑 nums2 的左半部分了。
2. 如果 i=m，说明 nums1 的右半部分为空，那么就假设这里的最小值为无限大，这样比较的话就相当于只考虑 nums2 的右半部分了。</li></ol><p>上代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>find_median</span>(nums1, nums2):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> len(nums1) <span style=color:#f92672>&gt;</span> len(nums2):
</span></span><span style=display:flex><span>        nums1, nums2 <span style=color:#f92672>=</span> nums2, nums1
</span></span><span style=display:flex><span>    m, n <span style=color:#f92672>=</span> len(nums1), len(nums2)
</span></span><span style=display:flex><span>    left, right <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, m
</span></span><span style=display:flex><span>    total_left <span style=color:#f92672>=</span> (m <span style=color:#f92672>+</span> n <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>//</span> <span style=color:#ae81ff>2</span>  <span style=color:#75715e># 注意用 // 而不是 /，因为下标不能是浮点数</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> left <span style=color:#f92672>&lt;</span> right:
</span></span><span style=display:flex><span>        i <span style=color:#f92672>=</span> left <span style=color:#f92672>+</span> (right <span style=color:#f92672>-</span> left <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>//</span> <span style=color:#ae81ff>2</span>  <span style=color:#75715e># 注意用 // 而不是 /，因为下标不能是浮点数</span>
</span></span><span style=display:flex><span>        j <span style=color:#f92672>=</span> total_left <span style=color:#f92672>-</span> i
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> nums1[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>&gt;</span> nums2[j]:
</span></span><span style=display:flex><span>            right <span style=color:#f92672>=</span> i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>            left <span style=color:#f92672>=</span> i
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    i, j <span style=color:#f92672>=</span> left, total_left <span style=color:#f92672>-</span> left
</span></span><span style=display:flex><span>    first_left_max <span style=color:#f92672>=</span> nums1[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>] <span style=color:#66d9ef>if</span> i <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> <span style=color:#66d9ef>else</span> <span style=color:#f92672>-</span>float(<span style=color:#e6db74>&#34;inf&#34;</span>)
</span></span><span style=display:flex><span>    first_right_min <span style=color:#f92672>=</span> nums1[i] <span style=color:#66d9ef>if</span> i <span style=color:#f92672>&lt;</span> m <span style=color:#66d9ef>else</span> float(<span style=color:#e6db74>&#34;inf&#34;</span>)
</span></span><span style=display:flex><span>    second_left_max <span style=color:#f92672>=</span> nums2[j <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>] <span style=color:#66d9ef>if</span> j <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> <span style=color:#66d9ef>else</span> <span style=color:#f92672>-</span>float(<span style=color:#e6db74>&#34;inf&#34;</span>)
</span></span><span style=display:flex><span>    second_right_min <span style=color:#f92672>=</span> nums2[j] <span style=color:#66d9ef>if</span> j <span style=color:#f92672>&lt;</span> n <span style=color:#66d9ef>else</span> float(<span style=color:#e6db74>&#34;inf&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (m <span style=color:#f92672>+</span> n) <span style=color:#f92672>%</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> max(first_left_max, second_left_max)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> (
</span></span><span style=display:flex><span>            max(first_left_max, second_left_max)
</span></span><span style=display:flex><span>            <span style=color:#f92672>+</span> min(first_right_min, second_right_min)
</span></span><span style=display:flex><span>        ) <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>
</span></span></code></pre></div><p>用 Python 实现的话，有两点需要注意：</p><ol><li>计算 <code>total_left</code> 和 <code>i</code> 的时候要用 <code>//</code>.</li><li>使用 <code>float("inf")</code> 来表示极大值，加负号表示极小值。</li></ol><p>到了这里基本就结束了，但是仔细看会发现函数的一开始会比较两个数组的长度，进而保证 nums1 是长度更短的那一个。</p><p>这是因为如果 nums1 非常长而 nums2 很短会造成 <code>j = total_left - i</code> 计算出来的 j 超过 nums2 的长度而出界。</p><p>而这是因为 i 是根据 left 和 right 计算得到的（也就是 m），从而能保证界限，j 是减出来的就不一定保险了。</p><p>最后来看一下这种方法的复杂度，因为保证了 nums1 较短，所以二分得到的时间复杂度为 O(logmin(m, n))，空间复杂度 O(1).</p><p>虽说上面的解法最优，但并不是一个很通用的方案，可以找到中位数，但对于求 k 位数这种问题就解决不了了。又看了下官方次优的解法，虽然时间复杂度为 O(log(m+n))，但是更普适：</p><ol><li>分别找出两个数组的 k/2-1 的位置，那么这个位置前面有 k/2-1 个元素。</li><li>两个位置上的元素分别成为 pivot1, pivot2，如果 pivot1 的值小于 pivot2 的值，则可以舍弃 pivot1 及前面的 k/2-1 个元素。（因为即使 pivot2 前面的元素都小于 pivot1，pivot1 最多也就是第 k-1 大的元素，中位数肯定不在其中）</li><li>去掉了这部分元素之后 nums1 就相当于变短了，而 nums2 不变，于是基于这两个数组继续。</li><li>同时也要记得更新 k 值，因为已经去掉一部分元素了，所以 k 变为了原来的一半。</li><li>继续此流程。当然过程中还要注意空数组、下标越界和 k=1 等边界情况。</li></ol><p><del>此处不贴代码了，见官方答案。</del> 实现代码如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>find_median</span>(nums1, nums2):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>find_kth_element</span>(k, nums1, nums2):
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#39;&#39;&#39;注意 k 是从 1 开始而不是 0&#39;&#39;&#39;</span>
</span></span><span style=display:flex><span>        m, n <span style=color:#f92672>=</span> len(nums1), len(nums2)
</span></span><span style=display:flex><span>        start1, start2 <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> <span style=color:#66d9ef>True</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> start1 <span style=color:#f92672>==</span> m:
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> nums2[start2 <span style=color:#f92672>+</span> k <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> start2 <span style=color:#f92672>==</span> n:
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> nums1[start1 <span style=color:#f92672>+</span> k <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> k <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>:
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> min(nums1[start1], nums2[start2])
</span></span><span style=display:flex><span>            <span style=color:#75715e># 因为 if 检查在上面，所以要取 min 防止下面 nums1[i] 或 nums2[j] 越界</span>
</span></span><span style=display:flex><span>            i <span style=color:#f92672>=</span> min(start1 <span style=color:#f92672>+</span> k <span style=color:#f92672>//</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>, m <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>            j <span style=color:#f92672>=</span> min(start2 <span style=color:#f92672>+</span> k <span style=color:#f92672>//</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>, n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> nums1[i] <span style=color:#f92672>&lt;=</span> nums2[j]:
</span></span><span style=display:flex><span>                <span style=color:#75715e># k 的更新基于 start1，所以先改 k 再改 start1</span>
</span></span><span style=display:flex><span>                k <span style=color:#f92672>-=</span> i <span style=color:#f92672>-</span> start1 <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>                start1 <span style=color:#f92672>=</span> i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>                k <span style=color:#f92672>-=</span> j <span style=color:#f92672>-</span> start2 <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>                start2 <span style=color:#f92672>=</span> j <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    length <span style=color:#f92672>=</span> len(nums1) <span style=color:#f92672>+</span> len(nums2)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> length <span style=color:#f92672>%</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> find_kth_element(length <span style=color:#f92672>//</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, nums1, nums2)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> (
</span></span><span style=display:flex><span>            find_kth_element(length <span style=color:#f92672>//</span> <span style=color:#ae81ff>2</span>, nums1, nums2)
</span></span><span style=display:flex><span>            <span style=color:#f92672>+</span> find_kth_element(length <span style=color:#f92672>//</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, nums1, nums2)
</span></span><span style=display:flex><span>        ) <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>
</span></span></code></pre></div><hr><p>整理完思路和代码已经是下午了，疲惫地什么都不想做。刷手机须谨慎，有风险别乱看。</p><hr><p><em>References</em></p><ul><li><a href=https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-s-114/>Media of two sorted arrays 官方答案 - Leetcode</a></li><li><a href=https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/he-bing-yi-hou-zhao-gui-bing-guo-cheng-zhong-zhao-/>个人觉得比较容易理解的答案 - Leetcode</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://iamgodot.com/tags/dsa/>dsa</a></li></ul><nav class=paginav><a class=prev href=https://iamgodot.com/posts/look-and-say/><span class=title>« Prev Page</span><br><span>Look and Say</span></a>
<a class=next href=https://iamgodot.com/posts/simple-recursion/><span class=title>Next Page »</span><br><span>(Re)Write recursions easily</span></a></nav></footer><script src=https://giscus.app/client.js data-repo=iamgodot/godot-blog-comments data-repo-id="MDEwOlJlcG9zaXRvcnkzOTk0Nzk0MTY=" data-category=Announcements data-category-id=DIC_kwDOF8-SeM4CO3OX data-mapping=pathname data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=dark_dimmed data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2020-2023 <a href=https://iamgodot.com>Godot's Blog - 个人生活分享</a></span>
<span>| <a href=http://beian.miit.gov.cn/ target=_blank>京ICP备20005558号-2</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>