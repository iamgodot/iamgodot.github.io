<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Python 中的 TLS 是如何实现的 | Godot's Blog</title><meta name=keywords content="Python 的 Threadlocal,Python 的 threading.local 实现,Flask 的 Local"><meta name=description content="TLS(Thread Local Storage)，或者说 Threadlocal，可以说是一种并发编程的常用模式，既实现了线程之间的资源隔离，又满足了全局变量的使用。
从 TLS 出发，这篇文章研究了 Python 中的 Threadlocal 是如何实现的，比如自带的 threading.local，再比如 Flask 框架中 Local 对象。
Why Threadlocal 先思考一下为什么要用 Threadlocal，这就不得不提到线程安全。Race condition 说到底是因为数据共享和非原子操作，这可以体现在函数的两种基本写法：一种是显式地传参（参数对象也可能变化？这也是为什么最好不要传递可变对象），没有共享自然安全；另一种就是全局对象，这么写既简化了函数签名，代码也比较清晰，缺点就是很容易出现线程不安全的问题，所以经常会和锁配合使用。
而 Threadlocal 就结合了两者的优点，在共享全局变量的同时，保证每个线程操作的都是自己独有的数据对象。
对比一下 Django 和 Flask 两大框架就会发现，前者总是在视图函数中显式声明 request 参数，而后者的只需要 import 一次就可以到处使用。在 Flask 的文档中，Armin Ronacher 也提及了这一点：
For example, Flask uses thread-local objects internally so that you don’t have to pass objects around from function to function within a request in order to stay threadsafe.
不过 Flask 并没有直接使用 Python 内置的 threading."><meta name=author content><link rel=canonical href=https://iamgodot.com/posts/sourcecode-of-python-threadlocal/><link crossorigin=anonymous href=/assets/css/stylesheet.min.7cb1aaa4414c482febc7034a427761d087a2cf358f1be8f7beba5afc947b57d0.css integrity="sha256-fLGqpEFMSC/rxwNKQndh0IeizzWPG+j3vrpa/JR7V9A=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js integrity="sha256-uVus3DnjejMqn4g7Hni+Srwf3KK8HyZB9V4809q9TWE=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://iamgodot.com/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://iamgodot.com/icons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://iamgodot.com/icons/favicon-32x32.png><link rel=apple-touch-icon href=https://iamgodot.com/icons/apple-touch-icon.png><link rel=mask-icon href=https://iamgodot.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=preload as=style href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;700&family=Source+Code+Pro:wght@400;700&display=swap"><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;700&family=Source+Code+Pro:wght@400;700&display=swap" media=print onload='this.media="all"'><link rel=preconnect href=https://plausible.iamgodot.com><script defer data-domain=iamgodot.com src=https://plausible.iamgodot.com/js/plausible.js></script>
<script>window.plausible=window.plausible||function(){(window.plausible.q=window.plausible.q||[]).push(arguments)}</script><script></script><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-157042624-1","auto"),ga("send","pageview"))</script><meta property="og:title" content="Python 中的 TLS 是如何实现的"><meta property="og:description" content="TLS(Thread Local Storage)，或者说 Threadlocal，可以说是一种并发编程的常用模式，既实现了线程之间的资源隔离，又满足了全局变量的使用。
从 TLS 出发，这篇文章研究了 Python 中的 Threadlocal 是如何实现的，比如自带的 threading.local，再比如 Flask 框架中 Local 对象。
Why Threadlocal 先思考一下为什么要用 Threadlocal，这就不得不提到线程安全。Race condition 说到底是因为数据共享和非原子操作，这可以体现在函数的两种基本写法：一种是显式地传参（参数对象也可能变化？这也是为什么最好不要传递可变对象），没有共享自然安全；另一种就是全局对象，这么写既简化了函数签名，代码也比较清晰，缺点就是很容易出现线程不安全的问题，所以经常会和锁配合使用。
而 Threadlocal 就结合了两者的优点，在共享全局变量的同时，保证每个线程操作的都是自己独有的数据对象。
对比一下 Django 和 Flask 两大框架就会发现，前者总是在视图函数中显式声明 request 参数，而后者的只需要 import 一次就可以到处使用。在 Flask 的文档中，Armin Ronacher 也提及了这一点：
For example, Flask uses thread-local objects internally so that you don’t have to pass objects around from function to function within a request in order to stay threadsafe.
不过 Flask 并没有直接使用 Python 内置的 threading."><meta property="og:type" content="article"><meta property="og:url" content="https://iamgodot.com/posts/sourcecode-of-python-threadlocal/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-04-11T16:13:49+08:00"><meta property="article:modified_time" content="2022-04-11T16:13:49+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Python 中的 TLS 是如何实现的"><meta name=twitter:description content="TLS(Thread Local Storage)，或者说 Threadlocal，可以说是一种并发编程的常用模式，既实现了线程之间的资源隔离，又满足了全局变量的使用。
从 TLS 出发，这篇文章研究了 Python 中的 Threadlocal 是如何实现的，比如自带的 threading.local，再比如 Flask 框架中 Local 对象。
Why Threadlocal 先思考一下为什么要用 Threadlocal，这就不得不提到线程安全。Race condition 说到底是因为数据共享和非原子操作，这可以体现在函数的两种基本写法：一种是显式地传参（参数对象也可能变化？这也是为什么最好不要传递可变对象），没有共享自然安全；另一种就是全局对象，这么写既简化了函数签名，代码也比较清晰，缺点就是很容易出现线程不安全的问题，所以经常会和锁配合使用。
而 Threadlocal 就结合了两者的优点，在共享全局变量的同时，保证每个线程操作的都是自己独有的数据对象。
对比一下 Django 和 Flask 两大框架就会发现，前者总是在视图函数中显式声明 request 参数，而后者的只需要 import 一次就可以到处使用。在 Flask 的文档中，Armin Ronacher 也提及了这一点：
For example, Flask uses thread-local objects internally so that you don’t have to pass objects around from function to function within a request in order to stay threadsafe.
不过 Flask 并没有直接使用 Python 内置的 threading."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://iamgodot.com/posts/"},{"@type":"ListItem","position":3,"name":"Python 中的 TLS 是如何实现的","item":"https://iamgodot.com/posts/sourcecode-of-python-threadlocal/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Python 中的 TLS 是如何实现的","name":"Python 中的 TLS 是如何实现的","description":"TLS(Thread Local Storage)，或者说 Threadlocal，可以说是一种并发编程的常用模式，既实现了线程之间的资源隔离，又满足了全局变量的使用。\n从 TLS 出发，这篇文章研究了 Python 中的 Threadlocal 是如何实现的，比如自带的 threading.local，再比如 Flask 框架中 Local 对象。\nWhy Threadlocal 先思考一下为什么要用 Threadlocal，这就不得不提到线程安全。Race condition 说到底是因为数据共享和非原子操作，这可以体现在函数的两种基本写法：一种是显式地传参（参数对象也可能变化？这也是为什么最好不要传递可变对象），没有共享自然安全；另一种就是全局对象，这么写既简化了函数签名，代码也比较清晰，缺点就是很容易出现线程不安全的问题，所以经常会和锁配合使用。\n而 Threadlocal 就结合了两者的优点，在共享全局变量的同时，保证每个线程操作的都是自己独有的数据对象。\n对比一下 Django 和 Flask 两大框架就会发现，前者总是在视图函数中显式声明 request 参数，而后者的只需要 import 一次就可以到处使用。在 Flask 的文档中，Armin Ronacher 也提及了这一点：\nFor example, Flask uses thread-local objects internally so that you don’t have to pass objects around from function to function within a request in order to stay threadsafe.\n不过 Flask 并没有直接使用 Python 内置的 threading.","keywords":["Python 的 Threadlocal","Python 的 threading.local 实现","Flask 的 Local"],"articleBody":"TLS(Thread Local Storage)，或者说 Threadlocal，可以说是一种并发编程的常用模式，既实现了线程之间的资源隔离，又满足了全局变量的使用。\n从 TLS 出发，这篇文章研究了 Python 中的 Threadlocal 是如何实现的，比如自带的 threading.local，再比如 Flask 框架中 Local 对象。\nWhy Threadlocal 先思考一下为什么要用 Threadlocal，这就不得不提到线程安全。Race condition 说到底是因为数据共享和非原子操作，这可以体现在函数的两种基本写法：一种是显式地传参（参数对象也可能变化？这也是为什么最好不要传递可变对象），没有共享自然安全；另一种就是全局对象，这么写既简化了函数签名，代码也比较清晰，缺点就是很容易出现线程不安全的问题，所以经常会和锁配合使用。\n而 Threadlocal 就结合了两者的优点，在共享全局变量的同时，保证每个线程操作的都是自己独有的数据对象。\n对比一下 Django 和 Flask 两大框架就会发现，前者总是在视图函数中显式声明 request 参数，而后者的只需要 import 一次就可以到处使用。在 Flask 的文档中，Armin Ronacher 也提及了这一点：\nFor example, Flask uses thread-local objects internally so that you don’t have to pass objects around from function to function within a request in order to stay threadsafe.\n不过 Flask 并没有直接使用 Python 内置的 threading.local，而是重新做了实现。\nThreading.local Python 的threading.local 用法很简单：\nfrom threading import Thread, local mydata = local() mydata.number = 42 print(mydata.number) # 42 nums = [] def f(): mydata.number = 11 nums.append(mydata.number) t = Thread(target=f) t.start() t.join() print(nums) # [11] print(mydata.number) # 42 线程可以共享全局对象，但实际上各自维护了数据，互不影响。如何做到的呢？其实思路也很简单，在字典中给每个线程都创建单独的字典，在使用之前先切换过去，看上去好像在用同一个变量，其实内部分得很清楚。下面看看源码：\n... @contextmanager def _patch(self): ... with impl.locallock: object.__setattr__(self, \"__dict__\", dct) yield class local: ... def __getattribute__(self, name): with _patch(self): return object.__getattribute__(self, name) def __setattr__(self, name, value): if name == \"__dict__\": raise AttributeError( \"%r object attribute '__dict__' is read-only\" % self.__class__.__name__ ) with _patch(self): return object.__setattr__(self, name, value) ... 其中 local 在 get/set 的时候都偷偷地 _patch 了下，那么 _patch 又做了什么呢？原来是临时把 local 的 __dict__ 替换成了另外的从 impl 取到的 dict。其实现在已经大概能猜到了，通过把 local 的属性字典替换成当前线程自己的字典，就实现了 Threadlocal 的核心功能。现在来看 impl 的内部结构：\nclass _localimpl: __slots__ = \"key\", \"dicts\", \"localargs\", \"locallock\", \"__weakref__\" def __init__(self): self.key = \"_threading_local._localimpl.\" + str(id(self)) # { id(Thread) -\u003e (ref(Thread), thread-local dict) } self.dicts = {} def get_dict(self): thread = current_thread() return self.dicts[id(thread)][1] def create_dict(self): localdict = {} key = self.key thread = current_thread() idt = id(thread) def local_deleted(_, key=key): thread = wrthread() if thread is not None: del thread.__dict__[key] def thread_deleted(_, idt=idt): local = wrlocal() if local is not None: dct = local.dicts.pop(idt) wrlocal = ref(self, local_deleted) wrthread = ref(thread, thread_deleted) thread.__dict__[key] = wrlocal self.dicts[idt] = wrthread, localdict return localdict 从第六行的注释可以看出，dicts 中保存了每个线程及其对应的字典，具体是用线程 id 对应到一个包含了线程弱引用和字典的元组。此外还有个单独的 self.key 属性，从 create_dict 方法中发现是为了给线程设置并标识 impl 本身用的。另外 wrlocal 和 wrthread 都小心地用了弱引用，这样就不影响 impl 和 thread 的内存回收，同时还会从相关字典中删除已经回收的对象（local_deleted 和 thread_deleted 作为 weakref 的 callback 函数）。\n现在再回头看看 local 其余的部分：\nclass local: __slots__ = \"_local__impl\", \"__dict__\" def __new__(cls, /, *args, **kw): if (args or kw) and (cls.__init__ is object.__init__): raise TypeError(\"Initialization arguments are not supported\") self = object.__new__(cls) impl = _localimpl() impl.localargs = (args, kw) impl.locallock = RLock() object.__setattr__(self, \"_local__impl\", impl) impl.create_dict() return self 有一点不太好理解，就是为什么要改写 __new__，而且上来就做了一个异常判断，为什么不在 __init__ 中实现呢？其实这是为了支持以继承的方式来定制 local：\nclass MyLocal(local): def __init__(self, /, **kw): self.__dict__.update(kw) mydata = MyLocal(color='red') 在 __new__ 里 hack 让继承覆盖 __init__ 少了很多负担，又因为 local 本身是不支持参数的，所以有了一开始的异常判断。\n接下来说说 impl 的 localargs 和 locallock：\n@contextmanager def _patch(self): impl = object.__getattribute__(self, \"_local__impl\") try: dct = impl.get_dict() except KeyError: dct = impl.create_dict() args, kw = impl.localargs self.__init__(*args, **kw) with impl.locallock: object.__setattr__(self, \"__dict__\", dct) yield 一目了然，localargs 是在为新线程创建字典时重新初始化（对 Subclass 的情况很必要），而 locallock 自然是要保证线程安全，因为这里的 __setattr__ 与后面 local 的 get/set 操作中间可能会出现 Race condition。\n到这里代码已经分析得差不多了，不过还要解释下 __slots__。local 和 _localimpl 中都定义了 __slots__ 来限制可用属性，既可以优化内存也能保证使用安全。同时为了不影响弱引用和属性赋值，它们又在各自的 __slots__ 中分别加入了 __weakref__ 和 __dict__。当然，这对 local 的使用也产生了负影响：\nclass MyLocal(local): __slots__ = 'number' mydata = MyLocal() mydata.number = 42 # 这里的 number 是所有线程共享的 这是因为 __slots__ 中的属性是由数据修饰符来控制的，不在 __dict__ 中保存，因此 _patch 无法产生效果。\nContext Locals 现在要说说 Flask 使用 Threadlocal 的思路，前面提到，这样的好处是不用到处传参，但必须要保证线程安全。然而对于一个 Web 框架来说，还需要考虑更多：\nThis approach, however, has a few disadvantages. For example, besides threads, there are other types of concurrency in Python. A very popular one is greenlets. Also, whether every request gets its own thread is not guaranteed in WSGI. It could be that a request is reusing a thread from a previous request, and hence data is left over in the thread local object.\n除了 greenlet，同一个线程也可能被用于处理多个请求，那么 threading.local 就不够用了，Flask 也因此重新做了实现（其实是 Werkzeug）。下面看一下源码：\ntry: from greenlet import getcurrent as get_ident except ImportError: try: from thread import get_ident except ImportError: from _thread import get_ident class Local(object): __slots__ = (\"__storage__\", \"__ident_func__\") def __init__(self): object.__setattr__(self, \"__storage__\", {}) object.__setattr__(self, \"__ident_func__\", get_ident) def __iter__(self): return iter(self.__storage__.items()) def __call__(self, proxy): \"\"\"Create a proxy for a name.\"\"\" return LocalProxy(self, proxy) def __release_local__(self): self.__storage__.pop(self.__ident_func__(), None) def __getattr__(self, name): try: return self.__storage__[self.__ident_func__()][name] except KeyError: raise AttributeError(name) def __setattr__(self, name, value): ident = self.__ident_func__() storage = self.__storage__ try: storage[ident][name] = value except KeyError: storage[ident] = {name: value} def __delattr__(self, name): try: del self.__storage__[self.__ident_func__()][name] except KeyError: raise AttributeError(name) 相比 threading.local 这个版本简单了不少，首先尝试 import greenlet 的 get_ident 方法作为内部的 __ident_func__，如果失败再 fallback 到线程上面，这就解决了 greenlet 的问题。而对于请求复用线程的情况还引入了 LocalManager：\nclass LocalManager(object): def __init__(self, locals=None, ident_func=None): if locals is None: self.locals = [] elif isinstance(locals, Local): self.locals = [locals] else: self.locals = list(locals) if ident_func is not None: self.ident_func = ident_func for local in self.locals: object.__setattr__(local, \"__ident_func__\", ident_func) else: self.ident_func = get_ident def get_ident(self): return self.ident_func() def cleanup(self): for local in self.locals: release_local(local) def make_middleware(self, app): def application(environ, start_response): return ClosingIterator(app(environ, start_response), self.cleanup) return application 简单来说就是线程在处理完 WSGI 请求之后会调用 cleanup 方法来保证 release_local 的执行，这样会把之前的数据字典从 local 中删除，然后在下一个请求中重新创建。\n相比 threading.local 这种实现更直接明了，当然前者也是为了支持 Subclass 等功能和更底层的优化，归根到底是由不同的需求决定的。\nContext Variable 除了线程和 greenlet，还有协程，如此一来上面那一套也不够用了。怎么办？Python 3.7 推出了 contextvars 这个库来保证异步任务执行的上下文隔离，不管是线程还是协程都可以直接用它做到类似 Threadlocal 的事情。\n所以 Werkzeug 从 2.x 版本开始也使用 ContextVar 来实现 Local 了：\nfrom contextvars import ContextVar class Local: __slots__ = (\"_storage\",) def __init__(self) -\u003e None: object.__setattr__(self, \"_storage\", ContextVar(\"local_storage\")) def __iter__(self) -\u003e t.Iterator[t.Tuple[int, t.Any]]: return iter(self._storage.get({}).items()) def __call__(self, proxy: str) -\u003e \"LocalProxy\": \"\"\"Create a proxy for a name.\"\"\" return LocalProxy(self, proxy) def __release_local__(self) -\u003e None: self._storage.set({}) def __getattr__(self, name: str) -\u003e t.Any: values = self._storage.get({}) try: return values[name] except KeyError: raise AttributeError(name) from None def __setattr__(self, name: str, value: t.Any) -\u003e None: values = self._storage.get({}).copy() values[name] = value self._storage.set(values) def __delattr__(self, name: str) -\u003e None: values = self._storage.get({}).copy() try: del values[name] self._storage.set(values) except KeyError: raise AttributeError(name) from None 代码相比之前更加简洁，而且外部接口完全不变。\nThe End 可以想象，Threadlocal 的写法是从线程安全和代码简洁等需求中演变而来的。理解了这些，就能更好地在设计开发中做出正确的选择。\nThread-Locals in Flask Context Locals - Werkzeug Contextvars - Python Docs ","wordCount":"848","inLanguage":"en","datePublished":"2022-04-11T16:13:49+08:00","dateModified":"2022-04-11T16:13:49+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://iamgodot.com/posts/sourcecode-of-python-threadlocal/"},"publisher":{"@type":"Organization","name":"Godot's Blog","logo":{"@type":"ImageObject","url":"https://iamgodot.com/icons/favicon.ico"}}}</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=https://iamgodot.com accesskey=h title="Godot's Blog (Alt + H)">Godot's Blog</a>
<span class=logo-switches></span></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Python 中的 TLS 是如何实现的</h1><div class=post-meta><span title='2022-04-11 16:13:49 +0800 +0800'>04-11</span>&nbsp;·&nbsp;4 min</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#why-threadlocal aria-label="Why Threadlocal">Why Threadlocal</a></li><li><a href=#threadinglocal aria-label=Threading.local>Threading.local</a></li><li><a href=#context-locals aria-label="Context Locals">Context Locals</a></li><li><a href=#context-variable aria-label="Context Variable">Context Variable</a></li><li><a href=#the-end aria-label="The End">The End</a></li></ul></div></details></div><div class=post-content><p>TLS(Thread Local Storage)，或者说 Threadlocal，可以说是一种并发编程的常用模式，既实现了线程之间的资源隔离，又满足了全局变量的使用。</p><p>从 TLS 出发，这篇文章研究了 Python 中的 Threadlocal 是如何实现的，比如自带的 <code>threading.local</code>，再比如 Flask 框架中 <code>Local</code> 对象。</p><h1 id=why-threadlocal>Why Threadlocal<a hidden class=anchor aria-hidden=true href=#why-threadlocal>#</a></h1><p>先思考一下为什么要用 Threadlocal，这就不得不提到线程安全。Race condition 说到底是因为数据共享和非原子操作，这可以体现在函数的两种基本写法：一种是显式地传参（参数对象也可能变化？这也是为什么最好不要传递可变对象），没有共享自然安全；另一种就是全局对象，这么写既简化了函数签名，代码也比较清晰，缺点就是很容易出现线程不安全的问题，所以经常会和锁配合使用。</p><p>而 Threadlocal 就结合了两者的优点，在共享全局变量的同时，保证每个线程操作的都是自己独有的数据对象。</p><p>对比一下 Django 和 Flask 两大框架就会发现，前者总是在视图函数中显式声明 <code>request</code> 参数，而后者的只需要 import 一次就可以到处使用。在 Flask 的<a href=https://flask.palletsprojects.com/en/2.0.x/advanced_foreword/>文档</a>中，Armin Ronacher 也提及了这一点：</p><blockquote><p>For example, Flask uses thread-local objects internally so that you don’t have to pass objects around from function to function within a request in order to stay threadsafe.</p></blockquote><p>不过 Flask 并没有直接使用 Python 内置的 <code>threading.local</code>，而是重新做了实现。</p><h1 id=threadinglocal>Threading.local<a hidden class=anchor aria-hidden=true href=#threadinglocal>#</a></h1><p>Python 的<code>threading.local</code> 用法很简单：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> threading <span style=color:#f92672>import</span> Thread, local
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>mydata <span style=color:#f92672>=</span> local()
</span></span><span style=display:flex><span>mydata<span style=color:#f92672>.</span>number <span style=color:#f92672>=</span> <span style=color:#ae81ff>42</span>
</span></span><span style=display:flex><span>print(mydata<span style=color:#f92672>.</span>number)  <span style=color:#75715e># 42</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>nums <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>f</span>():
</span></span><span style=display:flex><span>    mydata<span style=color:#f92672>.</span>number <span style=color:#f92672>=</span> <span style=color:#ae81ff>11</span>
</span></span><span style=display:flex><span>    nums<span style=color:#f92672>.</span>append(mydata<span style=color:#f92672>.</span>number)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>t <span style=color:#f92672>=</span> Thread(target<span style=color:#f92672>=</span>f)
</span></span><span style=display:flex><span>t<span style=color:#f92672>.</span>start()
</span></span><span style=display:flex><span>t<span style=color:#f92672>.</span>join()
</span></span><span style=display:flex><span>print(nums)  <span style=color:#75715e># [11]</span>
</span></span><span style=display:flex><span>print(mydata<span style=color:#f92672>.</span>number)  <span style=color:#75715e># 42</span>
</span></span></code></pre></div><p>线程可以共享全局对象，但实际上各自维护了数据，互不影响。如何做到的呢？其实思路也很简单，在字典中给每个线程都创建单独的字典，在使用之前先切换过去，看上去好像在用同一个变量，其实内部分得很清楚。下面看看源码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@contextmanager</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>_patch</span>(self):
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>with</span> impl<span style=color:#f92672>.</span>locallock:
</span></span><span style=display:flex><span>        object<span style=color:#f92672>.</span>__setattr__(self, <span style=color:#e6db74>&#34;__dict__&#34;</span>, dct)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>yield</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>local</span>:
</span></span><span style=display:flex><span>	<span style=color:#f92672>...</span>   
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __getattribute__(self, name):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>with</span> _patch(self):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> object<span style=color:#f92672>.</span>__getattribute__(self, name)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __setattr__(self, name, value):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> name <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;__dict__&#34;</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>raise</span> <span style=color:#a6e22e>AttributeError</span>(
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>%r</span><span style=color:#e6db74> object attribute &#39;__dict__&#39; is read-only&#34;</span> <span style=color:#f92672>%</span> self<span style=color:#f92672>.</span>__class__<span style=color:#f92672>.</span>__name__
</span></span><span style=display:flex><span>            )
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>with</span> _patch(self):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> object<span style=color:#f92672>.</span>__setattr__(self, name, value)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>
</span></span></code></pre></div><p>其中 <code>local</code> 在 <code>get/set</code> 的时候都偷偷地 <code>_patch</code> 了下，那么 <code>_patch</code> 又做了什么呢？原来是临时把 <code>local</code> 的 <code>__dict__</code> 替换成了另外的从 <code>impl</code> 取到的 dict。其实现在已经大概能猜到了，通过把 local 的属性字典替换成当前线程自己的字典，就实现了 Threadlocal 的核心功能。现在来看 <code>impl</code> 的内部结构：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>_localimpl</span>:
</span></span><span style=display:flex><span>    __slots__ <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;key&#34;</span>, <span style=color:#e6db74>&#34;dicts&#34;</span>, <span style=color:#e6db74>&#34;localargs&#34;</span>, <span style=color:#e6db74>&#34;locallock&#34;</span>, <span style=color:#e6db74>&#34;__weakref__&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(self):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>key <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;_threading_local._localimpl.&#34;</span> <span style=color:#f92672>+</span> str(id(self))
</span></span><span style=display:flex><span>        <span style=color:#75715e># { id(Thread) -&gt; (ref(Thread), thread-local dict) }</span>
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>dicts <span style=color:#f92672>=</span> {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get_dict</span>(self):
</span></span><span style=display:flex><span>        thread <span style=color:#f92672>=</span> current_thread()
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> self<span style=color:#f92672>.</span>dicts[id(thread)][<span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>create_dict</span>(self):
</span></span><span style=display:flex><span>        localdict <span style=color:#f92672>=</span> {}
</span></span><span style=display:flex><span>        key <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>key
</span></span><span style=display:flex><span>        thread <span style=color:#f92672>=</span> current_thread()
</span></span><span style=display:flex><span>        idt <span style=color:#f92672>=</span> id(thread)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>local_deleted</span>(_, key<span style=color:#f92672>=</span>key):
</span></span><span style=display:flex><span>            thread <span style=color:#f92672>=</span> wrthread()
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> thread <span style=color:#f92672>is</span> <span style=color:#f92672>not</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>del</span> thread<span style=color:#f92672>.</span>__dict__[key]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>thread_deleted</span>(_, idt<span style=color:#f92672>=</span>idt):
</span></span><span style=display:flex><span>            local <span style=color:#f92672>=</span> wrlocal()
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> local <span style=color:#f92672>is</span> <span style=color:#f92672>not</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>                dct <span style=color:#f92672>=</span> local<span style=color:#f92672>.</span>dicts<span style=color:#f92672>.</span>pop(idt)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        wrlocal <span style=color:#f92672>=</span> ref(self, local_deleted)
</span></span><span style=display:flex><span>        wrthread <span style=color:#f92672>=</span> ref(thread, thread_deleted)
</span></span><span style=display:flex><span>        thread<span style=color:#f92672>.</span>__dict__[key] <span style=color:#f92672>=</span> wrlocal
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>dicts[idt] <span style=color:#f92672>=</span> wrthread, localdict
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> localdict
</span></span></code></pre></div><p>从第六行的注释可以看出，<code>dicts</code> 中保存了每个线程及其对应的字典，具体是用线程 id 对应到一个包含了线程弱引用和字典的元组。此外还有个单独的 <code>self.key</code> 属性，从 <code>create_dict</code> 方法中发现是为了给线程设置并标识 <code>impl</code> 本身用的。另外 <code>wrlocal</code> 和 <code>wrthread</code> 都小心地用了弱引用，这样就不影响 <code>impl</code> 和 <code>thread</code> 的内存回收，同时还会从相关字典中删除已经回收的对象（<code>local_deleted</code> 和 <code>thread_deleted</code> 作为 <code>weakref</code> 的 callback 函数）。</p><p>现在再回头看看 <code>local</code> 其余的部分：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>local</span>:
</span></span><span style=display:flex><span>    __slots__ <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;_local__impl&#34;</span>, <span style=color:#e6db74>&#34;__dict__&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __new__(cls, <span style=color:#f92672>/</span>, <span style=color:#f92672>*</span>args, <span style=color:#f92672>**</span>kw):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (args <span style=color:#f92672>or</span> kw) <span style=color:#f92672>and</span> (cls<span style=color:#f92672>.</span>__init__ <span style=color:#f92672>is</span> object<span style=color:#f92672>.</span>__init__):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>raise</span> <span style=color:#a6e22e>TypeError</span>(<span style=color:#e6db74>&#34;Initialization arguments are not supported&#34;</span>)
</span></span><span style=display:flex><span>        self <span style=color:#f92672>=</span> object<span style=color:#f92672>.</span>__new__(cls)
</span></span><span style=display:flex><span>        impl <span style=color:#f92672>=</span> _localimpl()
</span></span><span style=display:flex><span>        impl<span style=color:#f92672>.</span>localargs <span style=color:#f92672>=</span> (args, kw)
</span></span><span style=display:flex><span>        impl<span style=color:#f92672>.</span>locallock <span style=color:#f92672>=</span> RLock()
</span></span><span style=display:flex><span>        object<span style=color:#f92672>.</span>__setattr__(self, <span style=color:#e6db74>&#34;_local__impl&#34;</span>, impl)
</span></span><span style=display:flex><span>        impl<span style=color:#f92672>.</span>create_dict()
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> self
</span></span></code></pre></div><p>有一点不太好理解，就是为什么要改写 <code>__new__</code>，而且上来就做了一个异常判断，为什么不在 <code>__init__</code> 中实现呢？其实这是为了支持以继承的方式来定制 <code>local</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyLocal</span>(local):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(self, <span style=color:#f92672>/</span>, <span style=color:#f92672>**</span>kw):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>__dict__<span style=color:#f92672>.</span>update(kw)
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>mydata <span style=color:#f92672>=</span> MyLocal(color<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;red&#39;</span>)
</span></span></code></pre></div><p>在 <code>__new__</code> 里 hack 让继承覆盖 <code>__init__</code> 少了很多负担，又因为 <code>local</code> 本身是不支持参数的，所以有了一开始的异常判断。</p><p>接下来说说 <code>impl</code> 的 <code>localargs</code> 和 <code>locallock</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#a6e22e>@contextmanager</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>_patch</span>(self):
</span></span><span style=display:flex><span>    impl <span style=color:#f92672>=</span> object<span style=color:#f92672>.</span>__getattribute__(self, <span style=color:#e6db74>&#34;_local__impl&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>        dct <span style=color:#f92672>=</span> impl<span style=color:#f92672>.</span>get_dict()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>except</span> <span style=color:#a6e22e>KeyError</span>:
</span></span><span style=display:flex><span>        dct <span style=color:#f92672>=</span> impl<span style=color:#f92672>.</span>create_dict()
</span></span><span style=display:flex><span>        args, kw <span style=color:#f92672>=</span> impl<span style=color:#f92672>.</span>localargs
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>__init__(<span style=color:#f92672>*</span>args, <span style=color:#f92672>**</span>kw)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>with</span> impl<span style=color:#f92672>.</span>locallock:
</span></span><span style=display:flex><span>        object<span style=color:#f92672>.</span>__setattr__(self, <span style=color:#e6db74>&#34;__dict__&#34;</span>, dct)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>yield</span>
</span></span></code></pre></div><p>一目了然，<code>localargs</code> 是在为新线程创建字典时重新初始化（对 Subclass 的情况很必要），而 <code>locallock</code> 自然是要保证线程安全，因为这里的 <code>__setattr__</code> 与后面 <code>local</code> 的 <code>get/set</code> 操作中间可能会出现 Race condition。</p><p>到这里代码已经分析得差不多了，不过还要解释下 <code>__slots__</code>。<code>local</code> 和 <code>_localimpl</code> 中都定义了 <code>__slots__</code> 来限制可用属性，既可以优化内存也能保证使用安全。同时为了不影响弱引用和属性赋值，它们又在各自的 <code>__slots__</code> 中分别加入了 <code>__weakref__</code> 和 <code>__dict__</code>。当然，这对 <code>local</code> 的使用也产生了负影响：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyLocal</span>(local):
</span></span><span style=display:flex><span>    __slots__ <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;number&#39;</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>mydata <span style=color:#f92672>=</span> MyLocal()
</span></span><span style=display:flex><span>mydata<span style=color:#f92672>.</span>number <span style=color:#f92672>=</span> <span style=color:#ae81ff>42</span>  <span style=color:#75715e># 这里的 number 是所有线程共享的</span>
</span></span></code></pre></div><p>这是因为 <code>__slots__</code> 中的属性是由数据修饰符来控制的，不在 <code>__dict__</code> 中保存，因此 <code>_patch</code> 无法产生效果。</p><h1 id=context-locals>Context Locals<a hidden class=anchor aria-hidden=true href=#context-locals>#</a></h1><p>现在要说说 Flask 使用 Threadlocal 的思路，前面提到，这样的好处是不用到处传参，但必须要保证线程安全。然而对于一个 Web 框架来说，还需要考虑更多：</p><blockquote><p>This approach, however, has a few disadvantages. For example, besides threads, there are other types of concurrency in Python. A very popular one is greenlets. Also, whether every request gets its own thread is not guaranteed in WSGI. It could be that a request is reusing a thread from a previous request, and hence data is left over in the thread local object.</p></blockquote><p>除了 <code>greenlet</code>，同一个线程也可能被用于处理多个请求，那么 <code>threading.local</code> 就不够用了，Flask 也因此重新做了实现（其实是 Werkzeug）。下面看一下源码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>from</span> greenlet <span style=color:#f92672>import</span> getcurrent <span style=color:#66d9ef>as</span> get_ident
</span></span><span style=display:flex><span><span style=color:#66d9ef>except</span> <span style=color:#a6e22e>ImportError</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>from</span> thread <span style=color:#f92672>import</span> get_ident
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>except</span> <span style=color:#a6e22e>ImportError</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>from</span> _thread <span style=color:#f92672>import</span> get_ident
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Local</span>(object):
</span></span><span style=display:flex><span>    __slots__ <span style=color:#f92672>=</span> (<span style=color:#e6db74>&#34;__storage__&#34;</span>, <span style=color:#e6db74>&#34;__ident_func__&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(self):
</span></span><span style=display:flex><span>        object<span style=color:#f92672>.</span>__setattr__(self, <span style=color:#e6db74>&#34;__storage__&#34;</span>, {})
</span></span><span style=display:flex><span>        object<span style=color:#f92672>.</span>__setattr__(self, <span style=color:#e6db74>&#34;__ident_func__&#34;</span>, get_ident)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __iter__(self):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> iter(self<span style=color:#f92672>.</span>__storage__<span style=color:#f92672>.</span>items())
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __call__(self, proxy):
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;&#34;&#34;Create a proxy for a name.&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> LocalProxy(self, proxy)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__release_local__</span>(self):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>__storage__<span style=color:#f92672>.</span>pop(self<span style=color:#f92672>.</span>__ident_func__(), <span style=color:#66d9ef>None</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __getattr__(self, name):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> self<span style=color:#f92672>.</span>__storage__[self<span style=color:#f92672>.</span>__ident_func__()][name]
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>except</span> <span style=color:#a6e22e>KeyError</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>raise</span> <span style=color:#a6e22e>AttributeError</span>(name)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __setattr__(self, name, value):
</span></span><span style=display:flex><span>        ident <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>__ident_func__()
</span></span><span style=display:flex><span>        storage <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>__storage__
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>            storage[ident][name] <span style=color:#f92672>=</span> value
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>except</span> <span style=color:#a6e22e>KeyError</span>:
</span></span><span style=display:flex><span>            storage[ident] <span style=color:#f92672>=</span> {name: value}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __delattr__(self, name):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>del</span> self<span style=color:#f92672>.</span>__storage__[self<span style=color:#f92672>.</span>__ident_func__()][name]
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>except</span> <span style=color:#a6e22e>KeyError</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>raise</span> <span style=color:#a6e22e>AttributeError</span>(name)
</span></span></code></pre></div><p>相比 <code>threading.local</code> 这个版本简单了不少，首先尝试 import <code>greenlet</code> 的 <code>get_ident</code> 方法作为内部的 <code>__ident_func__</code>，如果失败再 fallback 到线程上面，这就解决了 <code>greenlet</code> 的问题。而对于请求复用线程的情况还引入了 <code>LocalManager</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>LocalManager</span>(object):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(self, locals<span style=color:#f92672>=</span><span style=color:#66d9ef>None</span>, ident_func<span style=color:#f92672>=</span><span style=color:#66d9ef>None</span>):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> locals <span style=color:#f92672>is</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>locals <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>elif</span> isinstance(locals, Local):
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>locals <span style=color:#f92672>=</span> [locals]
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>locals <span style=color:#f92672>=</span> list(locals)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> ident_func <span style=color:#f92672>is</span> <span style=color:#f92672>not</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>ident_func <span style=color:#f92672>=</span> ident_func
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> local <span style=color:#f92672>in</span> self<span style=color:#f92672>.</span>locals:
</span></span><span style=display:flex><span>                object<span style=color:#f92672>.</span>__setattr__(local, <span style=color:#e6db74>&#34;__ident_func__&#34;</span>, ident_func)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>ident_func <span style=color:#f92672>=</span> get_ident
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get_ident</span>(self):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> self<span style=color:#f92672>.</span>ident_func()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>cleanup</span>(self):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> local <span style=color:#f92672>in</span> self<span style=color:#f92672>.</span>locals:
</span></span><span style=display:flex><span>            release_local(local)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>make_middleware</span>(self, app):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>application</span>(environ, start_response):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> ClosingIterator(app(environ, start_response), self<span style=color:#f92672>.</span>cleanup)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> application
</span></span></code></pre></div><p>简单来说就是线程在处理完 WSGI 请求之后会调用 <code>cleanup</code> 方法来保证 <code>release_local</code> 的执行，这样会把之前的数据字典从 <code>local</code> 中删除，然后在下一个请求中重新创建。</p><p>相比 <code>threading.local</code> 这种实现更直接明了，当然前者也是为了支持 Subclass 等功能和更底层的优化，归根到底是由不同的需求决定的。</p><h1 id=context-variable>Context Variable<a hidden class=anchor aria-hidden=true href=#context-variable>#</a></h1><p>除了线程和 <code>greenlet</code>，还有协程，如此一来上面那一套也不够用了。怎么办？Python 3.7 推出了 <a href=https://docs.python.org/3/library/contextvars.html>contextvars</a> 这个库来保证异步任务执行的上下文隔离，不管是线程还是协程都可以直接用它做到类似 Threadlocal 的事情。</p><p>所以 Werkzeug 从 2.x 版本开始也使用 <code>ContextVar</code> 来实现 <code>Local</code> 了：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> contextvars <span style=color:#f92672>import</span> ContextVar
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Local</span>:
</span></span><span style=display:flex><span>    __slots__ <span style=color:#f92672>=</span> (<span style=color:#e6db74>&#34;_storage&#34;</span>,)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(self) <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>        object<span style=color:#f92672>.</span>__setattr__(self, <span style=color:#e6db74>&#34;_storage&#34;</span>, ContextVar(<span style=color:#e6db74>&#34;local_storage&#34;</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __iter__(self) <span style=color:#f92672>-&gt;</span> t<span style=color:#f92672>.</span>Iterator[t<span style=color:#f92672>.</span>Tuple[int, t<span style=color:#f92672>.</span>Any]]:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> iter(self<span style=color:#f92672>.</span>_storage<span style=color:#f92672>.</span>get({})<span style=color:#f92672>.</span>items())
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __call__(self, proxy: str) <span style=color:#f92672>-&gt;</span> <span style=color:#e6db74>&#34;LocalProxy&#34;</span>:
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;&#34;&#34;Create a proxy for a name.&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> LocalProxy(self, proxy)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__release_local__</span>(self) <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>_storage<span style=color:#f92672>.</span>set({})
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __getattr__(self, name: str) <span style=color:#f92672>-&gt;</span> t<span style=color:#f92672>.</span>Any:
</span></span><span style=display:flex><span>        values <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>_storage<span style=color:#f92672>.</span>get({})
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> values[name]
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>except</span> <span style=color:#a6e22e>KeyError</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>raise</span> <span style=color:#a6e22e>AttributeError</span>(name) <span style=color:#f92672>from</span> None
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __setattr__(self, name: str, value: t<span style=color:#f92672>.</span>Any) <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>        values <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>_storage<span style=color:#f92672>.</span>get({})<span style=color:#f92672>.</span>copy()
</span></span><span style=display:flex><span>        values[name] <span style=color:#f92672>=</span> value
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>_storage<span style=color:#f92672>.</span>set(values)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __delattr__(self, name: str) <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>        values <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>_storage<span style=color:#f92672>.</span>get({})<span style=color:#f92672>.</span>copy()
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>del</span> values[name]
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>_storage<span style=color:#f92672>.</span>set(values)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>except</span> <span style=color:#a6e22e>KeyError</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>raise</span> <span style=color:#a6e22e>AttributeError</span>(name) <span style=color:#f92672>from</span> None
</span></span></code></pre></div><p>代码相比之前更加简洁，而且外部接口完全不变。</p><h1 id=the-end>The End<a hidden class=anchor aria-hidden=true href=#the-end>#</a></h1><p>可以想象，Threadlocal 的写法是从线程安全和代码简洁等需求中演变而来的。理解了这些，就能更好地在设计开发中做出正确的选择。</p><hr><ul><li><a href=https://flask.palletsprojects.com/en/2.1.x/advanced_foreword/>Thread-Locals in Flask</a></li><li><a href=https://werkzeug.palletsprojects.com/en/2.1.x/local/>Context Locals - Werkzeug</a></li><li><a href=https://docs.python.org/3/library/contextvars.html>Contextvars - Python Docs</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://iamgodot.com/tags/python/>python</a></li></ul><nav class=paginav><a class=prev href=https://iamgodot.com/posts/source-code-of-bottle/><span class=title>« Prev Page</span><br><span>Bottle 框架源码阅读</span></a>
<a class=next href=https://iamgodot.com/posts/sourcecode-of-python-logging/><span class=title>Next Page »</span><br><span>Python Logging 源码分析</span></a></nav></footer><script src=https://giscus.app/client.js data-repo=iamgodot/godot-blog-comments data-repo-id="MDEwOlJlcG9zaXRvcnkzOTk0Nzk0MTY=" data-category=Announcements data-category-id=DIC_kwDOF8-SeM4CO3OX data-mapping=pathname data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=dark_dimmed data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2020-2022 <a href=https://iamgodot.com>Godot's Blog</a></span>
<span>| <a href=http://beian.miit.gov.cn/ target=_blank>京ICP备20005558号-2</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>