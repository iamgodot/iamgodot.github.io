<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Python Import 源码阅读 | Godot's Blog</title><meta name=keywords content="Python import 用法,Python import 源码"><meta name=description content="浅析一下 Python 中的 Import 机制。
Module & Package Import 的对象就是各种各样的模块，即 Module。如何定义呢？官方文档这样描述：
A module is a file containing Python definitions and statements.
实际上，Module 可以是 Builtin，也可以是 C extension，但最常见的存在形式还是 *.py 文件。
一个 Module 同时也可能是 Package，此时它从文件升级为目录，就可以拥有 Submodule 了。Package 分为两种：
Regular package：这类 Package 必须包含一个 __init__.py 文件，代表了这个 Module(Package) 本身。 Namespace package：如果不存在 __init__.py，Python 会将其创建为此类 Package。Namespace package 的特殊之处在于同名的 Package 可以出现在多个目录下，而 Import 完成之后又可以统一使用。 不管是哪一种 Package，都会有 __path__ 属性，指向目录的路径。属性值是个列表，这对于 Namespace package 尤为重要。除此之外，一个 Module 还有：
__name__：模块名称。 __file__：文件位置。 __package__：主要是为了在 Relative import 时计算起点位置。 如果是 Package 则设置为 __name__。 如果非 Package 则设置为 Parent package 的名称（Top-level 的 Module 应为空字符串）。 如果以脚本执行，那么取值为 None。 How to Import 一般情况下 Import 都是通过 import 关键字完成的，可分为两大类："><meta name=author content><link rel=canonical href=https://iamgodot.com/posts/source-code-of-python-import/><link crossorigin=anonymous href=/assets/css/stylesheet.min.7cb1aaa4414c482febc7034a427761d087a2cf358f1be8f7beba5afc947b57d0.css integrity="sha256-fLGqpEFMSC/rxwNKQndh0IeizzWPG+j3vrpa/JR7V9A=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js integrity="sha256-uVus3DnjejMqn4g7Hni+Srwf3KK8HyZB9V4809q9TWE=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://iamgodot.com/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://iamgodot.com/icons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://iamgodot.com/icons/favicon-32x32.png><link rel=apple-touch-icon href=https://iamgodot.com/icons/apple-touch-icon.png><link rel=mask-icon href=https://iamgodot.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=preload as=style href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;700&family=Source+Code+Pro:wght@400;700&display=swap"><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;700&family=Source+Code+Pro:wght@400;700&display=swap" media=print onload='this.media="all"'><link rel=preconnect href=https://plausible.iamgodot.com><script defer data-domain=iamgodot.com src=https://plausible.iamgodot.com/js/plausible.js></script>
<script>window.plausible=window.plausible||function(){(window.plausible.q=window.plausible.q||[]).push(arguments)}</script><script></script><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-157042624-1","auto"),ga("send","pageview"))</script><meta property="og:title" content="Python Import 源码阅读"><meta property="og:description" content="浅析一下 Python 中的 Import 机制。
Module & Package Import 的对象就是各种各样的模块，即 Module。如何定义呢？官方文档这样描述：
A module is a file containing Python definitions and statements.
实际上，Module 可以是 Builtin，也可以是 C extension，但最常见的存在形式还是 *.py 文件。
一个 Module 同时也可能是 Package，此时它从文件升级为目录，就可以拥有 Submodule 了。Package 分为两种：
Regular package：这类 Package 必须包含一个 __init__.py 文件，代表了这个 Module(Package) 本身。 Namespace package：如果不存在 __init__.py，Python 会将其创建为此类 Package。Namespace package 的特殊之处在于同名的 Package 可以出现在多个目录下，而 Import 完成之后又可以统一使用。 不管是哪一种 Package，都会有 __path__ 属性，指向目录的路径。属性值是个列表，这对于 Namespace package 尤为重要。除此之外，一个 Module 还有：
__name__：模块名称。 __file__：文件位置。 __package__：主要是为了在 Relative import 时计算起点位置。 如果是 Package 则设置为 __name__。 如果非 Package 则设置为 Parent package 的名称（Top-level 的 Module 应为空字符串）。 如果以脚本执行，那么取值为 None。 How to Import 一般情况下 Import 都是通过 import 关键字完成的，可分为两大类："><meta property="og:type" content="article"><meta property="og:url" content="https://iamgodot.com/posts/source-code-of-python-import/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-09-10T18:20:40+08:00"><meta property="article:modified_time" content="2022-09-10T18:20:40+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Python Import 源码阅读"><meta name=twitter:description content="浅析一下 Python 中的 Import 机制。
Module & Package Import 的对象就是各种各样的模块，即 Module。如何定义呢？官方文档这样描述：
A module is a file containing Python definitions and statements.
实际上，Module 可以是 Builtin，也可以是 C extension，但最常见的存在形式还是 *.py 文件。
一个 Module 同时也可能是 Package，此时它从文件升级为目录，就可以拥有 Submodule 了。Package 分为两种：
Regular package：这类 Package 必须包含一个 __init__.py 文件，代表了这个 Module(Package) 本身。 Namespace package：如果不存在 __init__.py，Python 会将其创建为此类 Package。Namespace package 的特殊之处在于同名的 Package 可以出现在多个目录下，而 Import 完成之后又可以统一使用。 不管是哪一种 Package，都会有 __path__ 属性，指向目录的路径。属性值是个列表，这对于 Namespace package 尤为重要。除此之外，一个 Module 还有：
__name__：模块名称。 __file__：文件位置。 __package__：主要是为了在 Relative import 时计算起点位置。 如果是 Package 则设置为 __name__。 如果非 Package 则设置为 Parent package 的名称（Top-level 的 Module 应为空字符串）。 如果以脚本执行，那么取值为 None。 How to Import 一般情况下 Import 都是通过 import 关键字完成的，可分为两大类："><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://iamgodot.com/posts/"},{"@type":"ListItem","position":3,"name":"Python Import 源码阅读","item":"https://iamgodot.com/posts/source-code-of-python-import/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Python Import 源码阅读","name":"Python Import 源码阅读","description":"浅析一下 Python 中的 Import 机制。\nModule \u0026amp; Package Import 的对象就是各种各样的模块，即 Module。如何定义呢？官方文档这样描述：\nA module is a file containing Python definitions and statements.\n实际上，Module 可以是 Builtin，也可以是 C extension，但最常见的存在形式还是 *.py 文件。\n一个 Module 同时也可能是 Package，此时它从文件升级为目录，就可以拥有 Submodule 了。Package 分为两种：\nRegular package：这类 Package 必须包含一个 __init__.py 文件，代表了这个 Module(Package) 本身。 Namespace package：如果不存在 __init__.py，Python 会将其创建为此类 Package。Namespace package 的特殊之处在于同名的 Package 可以出现在多个目录下，而 Import 完成之后又可以统一使用。 不管是哪一种 Package，都会有 __path__ 属性，指向目录的路径。属性值是个列表，这对于 Namespace package 尤为重要。除此之外，一个 Module 还有：\n__name__：模块名称。 __file__：文件位置。 __package__：主要是为了在 Relative import 时计算起点位置。 如果是 Package 则设置为 __name__。 如果非 Package 则设置为 Parent package 的名称（Top-level 的 Module 应为空字符串）。 如果以脚本执行，那么取值为 None。 How to Import 一般情况下 Import 都是通过 import 关键字完成的，可分为两大类：","keywords":["Python import 用法","Python import 源码"],"articleBody":"浅析一下 Python 中的 Import 机制。\nModule \u0026 Package Import 的对象就是各种各样的模块，即 Module。如何定义呢？官方文档这样描述：\nA module is a file containing Python definitions and statements.\n实际上，Module 可以是 Builtin，也可以是 C extension，但最常见的存在形式还是 *.py 文件。\n一个 Module 同时也可能是 Package，此时它从文件升级为目录，就可以拥有 Submodule 了。Package 分为两种：\nRegular package：这类 Package 必须包含一个 __init__.py 文件，代表了这个 Module(Package) 本身。 Namespace package：如果不存在 __init__.py，Python 会将其创建为此类 Package。Namespace package 的特殊之处在于同名的 Package 可以出现在多个目录下，而 Import 完成之后又可以统一使用。 不管是哪一种 Package，都会有 __path__ 属性，指向目录的路径。属性值是个列表，这对于 Namespace package 尤为重要。除此之外，一个 Module 还有：\n__name__：模块名称。 __file__：文件位置。 __package__：主要是为了在 Relative import 时计算起点位置。 如果是 Package 则设置为 __name__。 如果非 Package 则设置为 Parent package 的名称（Top-level 的 Module 应为空字符串）。 如果以脚本执行，那么取值为 None。 How to Import 一般情况下 Import 都是通过 import 关键字完成的，可分为两大类：\nAbsolute import：from foo import bar as bat 其中 bar 可以是 Function，Class 或者 Submodule。 如果 import module.submodule，则实际 Import 的是整个 module。 Wildcard import：from module import * 如果 module 中定义了 __all__，则只会 Import 其指定的部分。 如果没有 __all__，那么非 _ 开头的属性都会被 Import。 Relative import：from ..foo import bar 这种方式会以当前 Module 为起点定位 foo，一般会出现两种错误： 相对位置超出了 Top-level package：ImportError: attempted relative import beyond top-level package 以脚本的方式运行：ImportError: attempted relative import with no known parent package 以模块的方式运行文件：python -m package.module 此时 module 的 __name__ 仍然是 __main__，和脚本方式一样。 而 __package__ 则不会是 None，而是 package。 此外，Python 还提供了 importlib，这样就可以在代码中动态 Import。实际上，__import__（也就是 import 关键字） 和 importlib.import_module 都是基于同一套 Codebase 实现的。\nHow Import Works 先来看两个接口的实现：\ndef __import__(name, globals=None, locals=None, fromlist=(), level=0): if level == 0: module = _gcd_import(name) else: globals_ = globals if globals is not None else {} package = _calc___package__(globals_) module = _gcd_import(name, package, level) if not fromlist: if level == 0: return _gcd_import(name.partition('.')[0]) elif not name: return module else: cut_off = len(name) - len(name.partition('.')[0]) return sys.modules[module.__name__[:len(module.__name__)-cut_off]] elif hasattr(module, '__path__'): return _handle_fromlist(module, fromlist, _gcd_import) else: return module def import_module(name, package=None): level = 0 if name.startswith('.'): if not package: msg = (\"the 'package' argument is required to perform a relative \" \"import for {!r}\") raise TypeError(msg.format(name)) for character in name: if character != '.': break level += 1 return _bootstrap._gcd_import(name[level:], package, level) 可以发现，两者在实际 Import 时调用的都是 _gcd_import 这个方法。gcd 的意思是 greatest common denominator，表示其作为两个接口的主要功能的公共函数。\n相对来说，__import__ 要更灵活一点，因为还提供了 fromlist 参数，可以指定要 Import 的具体属性，在代码中会对其做进一步的解析和校验。\n下面从 _gcd_import 出发，梳理一下 Import 的具体流程：\n一开始的 Sanity check 和 Name resolving 主要是针对 Relative import 的情况，比较容易理解。接下来会在 sys.modules 中检查 Module 是否已经存在，避免重复开销。如果 Parent module 尚不存在，则以递归的方式先对其做 Import，再继续执行当前流程。\n正式的 Import 主要包括 Find 和 Load 两大步骤。在大多数情况下，都是先定位到对应的 *.py 文件，读取到内存，最后生成一个 Module 对象并返回。\n看上去很简单，但有几个问题要考虑：\n在多线程情况下共享 sys.modules 这个字典结构，必须保证操作的原子性，还要考虑到 Deadlock。 模块文件可能分散在系统的多个目录下，因此必须要实现一个有效的管理和搜索策略。 Import 作为底层功能，还牵涉到很多 I/O 操作，所以在速度上要尽可能地优化。 先看多线程的处理。这里引入了 Global import lock 和 Module lock 两种锁。\n# A dict mapping module names to weakrefs of _ModuleLock instances # Dictionary protected by the global import lock _module_locks = {} class _ModuleLockManager: def __init__(self, name): self._name = name self._lock = None def __enter__(self): self._lock = _get_module_lock(self._name) self._lock.acquire() def __exit__(self, *args, **kwargs): self._lock.release() def _get_module_lock(name): # 获取 Global lock _imp.acquire_lock() try: try: # 尝试获取 Module lock # 所有的 Module lock 都在一个字典中维护 lock = _module_locks[name]() except KeyError: lock = None if lock is None: if _thread is None: lock = _DummyModuleLock(name) else: lock = _ModuleLock(name) # 这里通过 weakref 的 callback 避免内存泄漏 def cb(ref, name=name): _imp.acquire_lock() try: if _module_locks.get(name) is ref: del _module_locks[name] finally: _imp.release_lock() _module_locks[name] = _weakref.ref(lock, cb) finally: _imp.release_lock() return lock class _ModuleLock: def __init__(self, name): self.lock = _thread.allocate_lock() self.wakeup = _thread.allocate_lock() self.name = name self.owner = None self.count = 0 self.waiters = 0 def has_deadlock(self): # Deadlock avoidance for concurrent circular imports. me = _thread.get_ident() tid = self.owner seen = set() while True: lock = _blocking_on.get(tid) if lock is None: return False tid = lock.owner # 如果我等待的锁的 owner 在等待我手上的锁，说明出现 Deadlock if tid == me: return True if tid in seen: return False seen.add(tid) def acquire(self): ... def release(self): ... 下面来看 Module lock 的使用：\n_NEEDS_LOADING = object() # 作为 Sentinel object def _find_and_load(name, import_): module = sys.modules.get(name, _NEEDS_LOADING) if (module is _NEEDS_LOADING or getattr(getattr(module, \"__spec__\", None), \"_initializing\", False)): # 这里先获取 Global lock 和 Module lock with _ModuleLockManager(name): module = sys.modules.get(name, _NEEDS_LOADING) if module is _NEEDS_LOADING: # 开始真正的 Import return _find_and_load_unlocked(name, import_) # 如果 _initializing 为 True，说明有其他 Thread 正在 Import _lock_unlock_module(name) if module is None: message = ('import of {} halted; ' 'None in sys.modules'.format(name)) raise ModuleNotFoundError(message, name=name) return module ... def _lock_unlock_module(name): # 两个主要作用 # 一是通过 lock 的 acquire\u0026release 来保证 Initializing 的完成 lock = _get_module_lock(name) try: lock.acquire() # 二是捕捉并忽略 Deadlock 异常 except _DeadlockError: pass else: lock.release() 获取 Module lock 之后，下一步要找到 Spec，它决定了 Module 的类别与一些相关属性，以及后面加载要使用的 Loader。为了查找 Spec，解释器会分别尝试下面三种 Importer 的 find_spec 方法，这些 Importer 是在 sys.meta_path 中定义的：\nBuiltinImporter FrozenImporter PathFinder 前两者针对的是预编译好的模块，最常用的其实是 PathFinder，因为 Python 自带的函数库和第三方库都要通过它找到模块文件再进行加载。这些文件分散在系统的多个路径下，为了方便管理，sys.path 中定义了一个目录列表，里面每个条目都代表一个特定的搜索路径。对于每个条目，PathFinder 会调用对应的 PathEntryFinder(其实是 FileFinder) 进行查找。\n因为目录可能很多，所以这里又引入了缓存优化（前面的 sys.modules 也是一层缓存）：先在 sys.path_importer_cache 中寻找 PathEntryFinder，如果没有，再调用 sys.path_hooks 中的钩子函数做初始化创建并更新到 cache 中。\n针对 Namespace package 的处理也在这部分：\nclass PathFinder: ... @classmethod def _get_spec(cls, fullname, path, target=None): namespace_path = [] # 遍历 sys.path 中的每个条目 for entry in path: if not isinstance(entry, (str, bytes)): continue # 优先从 sys.path_importer_cache 中查找 # 如果没有则通过 sys.path_hooks 生成 finder = cls._path_importer_cache(entry) if finder is not None: if hasattr(finder, 'find_spec'): spec = finder.find_spec(fullname, target) else: spec = cls._legacy_get_spec(fullname, finder) if spec is None: continue if spec.loader is not None: return spec portions = spec.submodule_search_locations if portions is None: raise ImportError('spec missing loader') # 记录所有可能作为 Namespace package 的 path 目录 namespace_path.extend(portions) else: spec = _bootstrap.ModuleSpec(fullname, None) spec.submodule_search_locations = namespace_path return spec @classmethod def find_spec(cls, fullname, path=None, target=None): if path is None: path = sys.path spec = cls._get_spec(fullname, path, target) if spec is None: return None elif spec.loader is None: namespace_path = spec.submodule_search_locations if namespace_path: # 这里会创建针对 Namespace package 的 Spec spec.origin = None spec.submodule_search_locations = _NamespacePath(fullname, namespace_path, cls._get_spec) return spec else: return None else: return spec 找到 Spec 以后，也就确定了要使用的 Loader。一般来说，Load 就是执行 *.py 文件的内容，将里面的属性绑定到 Module object 上面。最后再返回这个 Object 便完成了 Import。\nPartially Circular Import 对于下面这种情况：\n# foo.py import bar # bar.py import foo 看起来会出现错误，其实是可以执行成功的。原因在于 Import 做了特殊处理，来看代码：\ndef _load_unlocked(spec): # 这里的 initializing 对应了前面的 _lock_unlock_module spec._initializing = True try: # 现在已经得到了 Spec，准备进行 Load # 但是在实际的 exec_module 之前会先将 Module object 放进 sys.modules # 这样在 Circular import 时缓存中就可以找到这个 Module object # 但是这个 Object 尚未完成加载，所以是 Partial 的 sys.modules[spec.name] = module try: if spec.loader is None: if spec.submodule_search_locations is None: raise ImportError('missing loader', name=spec.name) else: spec.loader.exec_module(module) except: try: del sys.modules[spec.name] except KeyError: pass raise module = sys.modules.pop(spec.name) sys.modules[spec.name] = module _verbose_message('import {!r} # {!r}', spec.name, spec.loader) finally: spec._initializing = False return module 当然，如果使用不当也是会引发异常的。\n# foo.py from foo import a a = 11 # 这种情况下 Import foo 会导致 ImportError # ImportError: cannot import name 'a' from partially initialized module 'foo' (most likely due to a circular import) # foo.py import bar # bar.py import foo print(foo.a) # 这种情况下 Import foo 会导致 AttributeError # AttributeError: partially initialized module 'foo' has no attribute 'a' (most likely due to a circular import) 原因就是尝试在 foo 模块仅仅 Partially imported 的情况下获取尚不存在的属性。\nReload 除了 import_module，importlib 还提供了一个 reload 接口，可以用来重新加载之前 Import 过的模块。\nreload 会刷新 sys.modules 中的 Module object，这没有问题。但是，对于 from foo import bar 这样的 Import 方式，bar 是不会单独更新的。\n# foo.py def bar(): print('bar') # 如果 import foo，然后这样使用 foo.bar()。Reload 是 OK 的。 # 如果再加上 from foo import bar，那么即使改变 bar 的代码再 reload(foo)，bar() 还是会保持原有的效果，即打印 `bar` 字符串。 从源码来理解，这是因为以上涉及到的 Import 实现都只针对 Module object 的创建和更新。从字节码可以看到：\n➜ echo 'from os import path' | python -m dis 1 0 LOAD_CONST 0 (0) 2 LOAD_CONST 1 (('path',)) 4 IMPORT_NAME 0 (os) 6 IMPORT_FROM 1 (path) 8 STORE_NAME 1 (path) 10 POP_TOP 12 LOAD_CONST 2 (None) 14 RETURN_VALUE path 的 Name binding 是通过 STORE_NAME 指令完成的，而 Import 的代码只负责 IMPORT_NAME 和 IMPORT_FROM，所以 reload 才会有 Module level 的限制。\nReferences\nHow the Python import system works\nModule attributes - Python Docs\nReload - python3 Cookbook\n","wordCount":"1153","inLanguage":"en","datePublished":"2022-09-10T18:20:40+08:00","dateModified":"2022-09-10T18:20:40+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://iamgodot.com/posts/source-code-of-python-import/"},"publisher":{"@type":"Organization","name":"Godot's Blog","logo":{"@type":"ImageObject","url":"https://iamgodot.com/icons/favicon.ico"}}}</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=https://iamgodot.com accesskey=h title="Godot's Blog (Alt + H)">Godot's Blog</a>
<span class=logo-switches></span></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Python Import 源码阅读</h1><div class=post-meta><span title='2022-09-10 18:20:40 +0800 +0800'>09-10</span>&nbsp;·&nbsp;6 min</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#module--package aria-label="Module &amp;amp; Package">Module & Package</a></li><li><a href=#how-to-import aria-label="How to Import">How to Import</a></li><li><a href=#how-import-works aria-label="How Import Works">How Import Works</a></li><li><a href=#partially-circular-import aria-label="Partially Circular Import">Partially Circular Import</a></li><li><a href=#reload aria-label=Reload>Reload</a></li></ul></div></details></div><div class=post-content><p>浅析一下 Python 中的 Import 机制。</p><h1 id=module--package>Module & Package<a hidden class=anchor aria-hidden=true href=#module--package>#</a></h1><p>Import 的对象就是各种各样的模块，即 Module。如何定义呢？官方文档这样描述：</p><blockquote><p>A module is a file containing Python definitions and statements.</p></blockquote><p>实际上，Module 可以是 Builtin，也可以是 C extension，但最常见的存在形式还是 <code>*.py</code> 文件。</p><p>一个 Module 同时也可能是 Package，此时它从文件升级为目录，就可以拥有 Submodule 了。Package 分为两种：</p><ol><li>Regular package：这类 Package 必须包含一个 <code>__init__.py</code> 文件，代表了这个 Module(Package) 本身。</li><li>Namespace package：如果不存在 <code>__init__.py</code>，Python 会将其创建为此类 Package。Namespace package 的特殊之处在于同名的 Package 可以出现在多个目录下，而 Import 完成之后又可以统一使用。</li></ol><p>不管是哪一种 Package，都会有 <code>__path__</code> 属性，指向目录的路径。属性值是个列表，这对于 Namespace package 尤为重要。除此之外，一个 Module 还有：</p><ul><li><code>__name__</code>：模块名称。</li><li><code>__file__</code>：文件位置。</li><li><code>__package__</code>：主要是为了在 Relative import 时计算起点位置。<ul><li>如果是 Package 则设置为 <code>__name__</code>。</li><li>如果非 Package 则设置为 Parent package 的名称（Top-level 的 Module 应为空字符串）。</li><li>如果以脚本执行，那么取值为 <code>None</code>。</li></ul></li></ul><h1 id=how-to-import>How to Import<a hidden class=anchor aria-hidden=true href=#how-to-import>#</a></h1><p>一般情况下 Import 都是通过 <code>import</code> 关键字完成的，可分为两大类：</p><ul><li>Absolute import：<code>from foo import bar as bat</code><ul><li>其中 <code>bar</code> 可以是 Function，Class 或者 Submodule。</li><li>如果 <code>import module.submodule</code>，则实际 Import 的是整个 <code>module</code>。</li><li>Wildcard import：<code>from module import *</code><ul><li>如果 <code>module</code> 中定义了 <code>__all__</code>，则只会 Import 其指定的部分。</li><li>如果没有 <code>__all__</code>，那么非 <code>_</code> 开头的属性都会被 Import。</li></ul></li></ul></li><li>Relative import：<code>from ..foo import bar</code><ul><li>这种方式会以当前 Module 为起点定位 <code>foo</code>，一般会出现两种错误：<ul><li>相对位置超出了 Top-level package：<code>ImportError: attempted relative import beyond top-level package</code></li><li>以脚本的方式运行：<code>ImportError: attempted relative import with no known parent package</code></li></ul></li><li>以模块的方式运行文件：<code>python -m package.module</code><ul><li>此时 <code>module</code> 的 <code>__name__</code> 仍然是 <code>__main__</code>，和脚本方式一样。</li><li>而 <code>__package__</code> 则不会是 <code>None</code>，而是 <code>package</code>。</li></ul></li></ul></li></ul><p>此外，Python 还提供了 <code>importlib</code>，这样就可以在代码中动态 Import。实际上，<code>__import__</code>（也就是 <code>import</code> 关键字） 和 <code>importlib.import_module</code> 都是基于同一套 Codebase 实现的。</p><h1 id=how-import-works>How Import Works<a hidden class=anchor aria-hidden=true href=#how-import-works>#</a></h1><p>先来看两个接口的实现：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__import__</span>(name, globals<span style=color:#f92672>=</span><span style=color:#66d9ef>None</span>, locals<span style=color:#f92672>=</span><span style=color:#66d9ef>None</span>, fromlist<span style=color:#f92672>=</span>(), level<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> level <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>        module <span style=color:#f92672>=</span> _gcd_import(name)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>        globals_ <span style=color:#f92672>=</span> globals <span style=color:#66d9ef>if</span> globals <span style=color:#f92672>is</span> <span style=color:#f92672>not</span> <span style=color:#66d9ef>None</span> <span style=color:#66d9ef>else</span> {}
</span></span><span style=display:flex><span>        package <span style=color:#f92672>=</span> _calc___package__(globals_)
</span></span><span style=display:flex><span>        module <span style=color:#f92672>=</span> _gcd_import(name, package, level)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> fromlist:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> level <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> _gcd_import(name<span style=color:#f92672>.</span>partition(<span style=color:#e6db74>&#39;.&#39;</span>)[<span style=color:#ae81ff>0</span>])
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>elif</span> <span style=color:#f92672>not</span> name:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> module
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>            cut_off <span style=color:#f92672>=</span> len(name) <span style=color:#f92672>-</span> len(name<span style=color:#f92672>.</span>partition(<span style=color:#e6db74>&#39;.&#39;</span>)[<span style=color:#ae81ff>0</span>])
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> sys<span style=color:#f92672>.</span>modules[module<span style=color:#f92672>.</span>__name__[:len(module<span style=color:#f92672>.</span>__name__)<span style=color:#f92672>-</span>cut_off]]
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>elif</span> hasattr(module, <span style=color:#e6db74>&#39;__path__&#39;</span>):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> _handle_fromlist(module, fromlist, _gcd_import)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> module
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>import_module</span>(name, package<span style=color:#f92672>=</span><span style=color:#66d9ef>None</span>):
</span></span><span style=display:flex><span>    level <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> name<span style=color:#f92672>.</span>startswith(<span style=color:#e6db74>&#39;.&#39;</span>):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> package:
</span></span><span style=display:flex><span>            msg <span style=color:#f92672>=</span> (<span style=color:#e6db74>&#34;the &#39;package&#39; argument is required to perform a relative &#34;</span>
</span></span><span style=display:flex><span>                   <span style=color:#e6db74>&#34;import for </span><span style=color:#e6db74>{!r}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>raise</span> <span style=color:#a6e22e>TypeError</span>(msg<span style=color:#f92672>.</span>format(name))
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> character <span style=color:#f92672>in</span> name:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> character <span style=color:#f92672>!=</span> <span style=color:#e6db74>&#39;.&#39;</span>:
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>            level <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> _bootstrap<span style=color:#f92672>.</span>_gcd_import(name[level:], package, level)
</span></span></code></pre></div><p>可以发现，两者在实际 Import 时调用的都是 <code>_gcd_import</code> 这个方法。<code>gcd</code> 的意思是 <code>greatest common denominator</code>，表示其作为两个接口的主要功能的公共函数。</p><p>相对来说，<code>__import__</code> 要更灵活一点，因为还提供了 <code>fromlist</code> 参数，可以指定要 Import 的具体属性，在代码中会对其做进一步的解析和校验。</p><p>下面从 <code>_gcd_import</code> 出发，梳理一下 Import 的具体流程：</p><p><img loading=lazy src=https://static.iamgodot.com/content/images/20220911182414.png alt></p><p>一开始的 Sanity check 和 Name resolving 主要是针对 Relative import 的情况，比较容易理解。接下来会在 <code>sys.modules</code> 中检查 Module 是否已经存在，避免重复开销。如果 Parent module 尚不存在，则以递归的方式先对其做 Import，再继续执行当前流程。</p><p>正式的 Import 主要包括 Find 和 Load 两大步骤。在大多数情况下，都是先定位到对应的 <code>*.py</code> 文件，读取到内存，最后生成一个 Module 对象并返回。</p><p>看上去很简单，但有几个问题要考虑：</p><ol><li>在多线程情况下共享 <code>sys.modules</code> 这个字典结构，必须保证操作的原子性，还要考虑到 Deadlock。</li><li>模块文件可能分散在系统的多个目录下，因此必须要实现一个有效的管理和搜索策略。</li><li>Import 作为底层功能，还牵涉到很多 I/O 操作，所以在速度上要尽可能地优化。</li></ol><p>先看多线程的处理。这里引入了 Global import lock 和 Module lock 两种锁。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># A dict mapping module names to weakrefs of _ModuleLock instances</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Dictionary protected by the global import lock</span>
</span></span><span style=display:flex><span>_module_locks <span style=color:#f92672>=</span> {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>_ModuleLockManager</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(self, name):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>_name <span style=color:#f92672>=</span> name
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>_lock <span style=color:#f92672>=</span> <span style=color:#66d9ef>None</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __enter__(self):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>_lock <span style=color:#f92672>=</span> _get_module_lock(self<span style=color:#f92672>.</span>_name)
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>_lock<span style=color:#f92672>.</span>acquire()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __exit__(self, <span style=color:#f92672>*</span>args, <span style=color:#f92672>**</span>kwargs):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>_lock<span style=color:#f92672>.</span>release()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>_get_module_lock</span>(name):
</span></span><span style=display:flex><span>    <span style=color:#75715e># 获取 Global lock</span>
</span></span><span style=display:flex><span>    _imp<span style=color:#f92672>.</span>acquire_lock()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>            <span style=color:#75715e># 尝试获取 Module lock</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e># 所有的 Module lock 都在一个字典中维护</span>
</span></span><span style=display:flex><span>            lock <span style=color:#f92672>=</span> _module_locks[name]()
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>except</span> <span style=color:#a6e22e>KeyError</span>:
</span></span><span style=display:flex><span>            lock <span style=color:#f92672>=</span> <span style=color:#66d9ef>None</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> lock <span style=color:#f92672>is</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> _thread <span style=color:#f92672>is</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>                lock <span style=color:#f92672>=</span> _DummyModuleLock(name)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>                lock <span style=color:#f92672>=</span> _ModuleLock(name)
</span></span><span style=display:flex><span>            <span style=color:#75715e># 这里通过 weakref 的 callback 避免内存泄漏</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>cb</span>(ref, name<span style=color:#f92672>=</span>name):
</span></span><span style=display:flex><span>                _imp<span style=color:#f92672>.</span>acquire_lock()
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> _module_locks<span style=color:#f92672>.</span>get(name) <span style=color:#f92672>is</span> ref:
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>del</span> _module_locks[name]
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>finally</span>:
</span></span><span style=display:flex><span>                    _imp<span style=color:#f92672>.</span>release_lock()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            _module_locks[name] <span style=color:#f92672>=</span> _weakref<span style=color:#f92672>.</span>ref(lock, cb)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>finally</span>:
</span></span><span style=display:flex><span>        _imp<span style=color:#f92672>.</span>release_lock()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> lock
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>_ModuleLock</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(self, name):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>lock <span style=color:#f92672>=</span> _thread<span style=color:#f92672>.</span>allocate_lock()
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>wakeup <span style=color:#f92672>=</span> _thread<span style=color:#f92672>.</span>allocate_lock()
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>name <span style=color:#f92672>=</span> name
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>owner <span style=color:#f92672>=</span> <span style=color:#66d9ef>None</span>
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>count <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>waiters <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>has_deadlock</span>(self):
</span></span><span style=display:flex><span>        <span style=color:#75715e># Deadlock avoidance for concurrent circular imports.</span>
</span></span><span style=display:flex><span>        me <span style=color:#f92672>=</span> _thread<span style=color:#f92672>.</span>get_ident()
</span></span><span style=display:flex><span>        tid <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>owner
</span></span><span style=display:flex><span>        seen <span style=color:#f92672>=</span> set()
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> <span style=color:#66d9ef>True</span>:
</span></span><span style=display:flex><span>            lock <span style=color:#f92672>=</span> _blocking_on<span style=color:#f92672>.</span>get(tid)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> lock <span style=color:#f92672>is</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>False</span>
</span></span><span style=display:flex><span>            tid <span style=color:#f92672>=</span> lock<span style=color:#f92672>.</span>owner
</span></span><span style=display:flex><span>            <span style=color:#75715e># 如果我等待的锁的 owner 在等待我手上的锁，说明出现 Deadlock</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> tid <span style=color:#f92672>==</span> me:
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>True</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> tid <span style=color:#f92672>in</span> seen:
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>False</span>
</span></span><span style=display:flex><span>            seen<span style=color:#f92672>.</span>add(tid)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>acquire</span>(self):
</span></span><span style=display:flex><span>        <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>release</span>(self):
</span></span><span style=display:flex><span>        <span style=color:#f92672>...</span>
</span></span></code></pre></div><p>下面来看 Module lock 的使用：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>_NEEDS_LOADING <span style=color:#f92672>=</span> object()  <span style=color:#75715e># 作为 Sentinel object</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>_find_and_load</span>(name, import_):
</span></span><span style=display:flex><span>    module <span style=color:#f92672>=</span> sys<span style=color:#f92672>.</span>modules<span style=color:#f92672>.</span>get(name, _NEEDS_LOADING)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (module <span style=color:#f92672>is</span> _NEEDS_LOADING <span style=color:#f92672>or</span>
</span></span><span style=display:flex><span>        getattr(getattr(module, <span style=color:#e6db74>&#34;__spec__&#34;</span>, <span style=color:#66d9ef>None</span>), <span style=color:#e6db74>&#34;_initializing&#34;</span>, <span style=color:#66d9ef>False</span>)):
</span></span><span style=display:flex><span>        <span style=color:#75715e># 这里先获取 Global lock 和 Module lock</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>with</span> _ModuleLockManager(name):
</span></span><span style=display:flex><span>            module <span style=color:#f92672>=</span> sys<span style=color:#f92672>.</span>modules<span style=color:#f92672>.</span>get(name, _NEEDS_LOADING)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> module <span style=color:#f92672>is</span> _NEEDS_LOADING:
</span></span><span style=display:flex><span>                <span style=color:#75715e># 开始真正的 Import</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> _find_and_load_unlocked(name, import_)
</span></span><span style=display:flex><span>        <span style=color:#75715e># 如果 _initializing 为 True，说明有其他 Thread 正在 Import</span>
</span></span><span style=display:flex><span>        _lock_unlock_module(name)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> module <span style=color:#f92672>is</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>        message <span style=color:#f92672>=</span> (<span style=color:#e6db74>&#39;import of </span><span style=color:#e6db74>{}</span><span style=color:#e6db74> halted; &#39;</span>
</span></span><span style=display:flex><span>                   <span style=color:#e6db74>&#39;None in sys.modules&#39;</span><span style=color:#f92672>.</span>format(name))
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>raise</span> <span style=color:#a6e22e>ModuleNotFoundError</span>(message, name<span style=color:#f92672>=</span>name)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> module
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>_lock_unlock_module</span>(name):
</span></span><span style=display:flex><span>    <span style=color:#75715e># 两个主要作用</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 一是通过 lock 的 acquire&amp;release 来保证 Initializing 的完成</span>
</span></span><span style=display:flex><span>    lock <span style=color:#f92672>=</span> _get_module_lock(name)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>        lock<span style=color:#f92672>.</span>acquire()
</span></span><span style=display:flex><span>    <span style=color:#75715e># 二是捕捉并忽略 Deadlock 异常</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>except</span> _DeadlockError:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>pass</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>        lock<span style=color:#f92672>.</span>release()
</span></span></code></pre></div><p>获取 Module lock 之后，下一步要找到 Spec，它决定了 Module 的类别与一些相关属性，以及后面加载要使用的 Loader。为了查找 Spec，解释器会分别尝试下面三种 Importer 的 <code>find_spec</code> 方法，这些 Importer 是在 <code>sys.meta_path</code> 中定义的：</p><ol><li><code>BuiltinImporter</code></li><li><code>FrozenImporter</code></li><li><code>PathFinder</code></li></ol><p>前两者针对的是预编译好的模块，最常用的其实是 <code>PathFinder</code>，因为 Python 自带的函数库和第三方库都要通过它找到模块文件再进行加载。这些文件分散在系统的多个路径下，为了方便管理，<code>sys.path</code> 中定义了一个目录列表，里面每个条目都代表一个特定的搜索路径。对于每个条目，<code>PathFinder</code> 会调用对应的 <code>PathEntryFinder</code>(其实是 <code>FileFinder</code>) 进行查找。</p><p>因为目录可能很多，所以这里又引入了缓存优化（前面的 <code>sys.modules</code> 也是一层缓存）：先在 <code>sys.path_importer_cache</code> 中寻找 <code>PathEntryFinder</code>，如果没有，再调用 <code>sys.path_hooks</code> 中的钩子函数做初始化创建并更新到 <code>cache</code> 中。</p><p>针对 Namespace package 的处理也在这部分：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>PathFinder</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@classmethod</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>_get_spec</span>(cls, fullname, path, target<span style=color:#f92672>=</span><span style=color:#66d9ef>None</span>):
</span></span><span style=display:flex><span>        namespace_path <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>        <span style=color:#75715e># 遍历 sys.path 中的每个条目</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> entry <span style=color:#f92672>in</span> path:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> isinstance(entry, (str, bytes)):
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e># 优先从 sys.path_importer_cache 中查找</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e># 如果没有则通过 sys.path_hooks 生成</span>
</span></span><span style=display:flex><span>            finder <span style=color:#f92672>=</span> cls<span style=color:#f92672>.</span>_path_importer_cache(entry)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> finder <span style=color:#f92672>is</span> <span style=color:#f92672>not</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> hasattr(finder, <span style=color:#e6db74>&#39;find_spec&#39;</span>):
</span></span><span style=display:flex><span>                    spec <span style=color:#f92672>=</span> finder<span style=color:#f92672>.</span>find_spec(fullname, target)
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>                    spec <span style=color:#f92672>=</span> cls<span style=color:#f92672>.</span>_legacy_get_spec(fullname, finder)
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> spec <span style=color:#f92672>is</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> spec<span style=color:#f92672>.</span>loader <span style=color:#f92672>is</span> <span style=color:#f92672>not</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> spec
</span></span><span style=display:flex><span>                portions <span style=color:#f92672>=</span> spec<span style=color:#f92672>.</span>submodule_search_locations
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> portions <span style=color:#f92672>is</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>raise</span> <span style=color:#a6e22e>ImportError</span>(<span style=color:#e6db74>&#39;spec missing loader&#39;</span>)
</span></span><span style=display:flex><span>                <span style=color:#75715e># 记录所有可能作为 Namespace package 的 path 目录</span>
</span></span><span style=display:flex><span>                namespace_path<span style=color:#f92672>.</span>extend(portions)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>            spec <span style=color:#f92672>=</span> _bootstrap<span style=color:#f92672>.</span>ModuleSpec(fullname, <span style=color:#66d9ef>None</span>)
</span></span><span style=display:flex><span>            spec<span style=color:#f92672>.</span>submodule_search_locations <span style=color:#f92672>=</span> namespace_path
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> spec
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@classmethod</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>find_spec</span>(cls, fullname, path<span style=color:#f92672>=</span><span style=color:#66d9ef>None</span>, target<span style=color:#f92672>=</span><span style=color:#66d9ef>None</span>):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> path <span style=color:#f92672>is</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>            path <span style=color:#f92672>=</span> sys<span style=color:#f92672>.</span>path
</span></span><span style=display:flex><span>        spec <span style=color:#f92672>=</span> cls<span style=color:#f92672>.</span>_get_spec(fullname, path, target)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> spec <span style=color:#f92672>is</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>None</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>elif</span> spec<span style=color:#f92672>.</span>loader <span style=color:#f92672>is</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>            namespace_path <span style=color:#f92672>=</span> spec<span style=color:#f92672>.</span>submodule_search_locations
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> namespace_path:
</span></span><span style=display:flex><span>                <span style=color:#75715e># 这里会创建针对 Namespace package 的 Spec</span>
</span></span><span style=display:flex><span>                spec<span style=color:#f92672>.</span>origin <span style=color:#f92672>=</span> <span style=color:#66d9ef>None</span>
</span></span><span style=display:flex><span>                spec<span style=color:#f92672>.</span>submodule_search_locations <span style=color:#f92672>=</span> _NamespacePath(fullname, namespace_path, cls<span style=color:#f92672>.</span>_get_spec)
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> spec
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>None</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> spec
</span></span></code></pre></div><p>找到 Spec 以后，也就确定了要使用的 Loader。一般来说，Load 就是执行 <code>*.py</code> 文件的内容，将里面的属性绑定到 Module object 上面。最后再返回这个 Object 便完成了 Import。</p><h1 id=partially-circular-import>Partially Circular Import<a hidden class=anchor aria-hidden=true href=#partially-circular-import>#</a></h1><p>对于下面这种情况：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># foo.py</span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> bar
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># bar.py</span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> foo
</span></span></code></pre></div><p>看起来会出现错误，其实是可以执行成功的。原因在于 Import 做了特殊处理，来看代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>_load_unlocked</span>(spec):
</span></span><span style=display:flex><span>    <span style=color:#75715e># 这里的 initializing 对应了前面的 _lock_unlock_module </span>
</span></span><span style=display:flex><span>    spec<span style=color:#f92672>.</span>_initializing <span style=color:#f92672>=</span> <span style=color:#66d9ef>True</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>        <span style=color:#75715e># 现在已经得到了 Spec，准备进行 Load</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># 但是在实际的 exec_module 之前会先将 Module object 放进 sys.modules</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># 这样在 Circular import 时缓存中就可以找到这个 Module object</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># 但是这个 Object 尚未完成加载，所以是 Partial 的</span>
</span></span><span style=display:flex><span>        sys<span style=color:#f92672>.</span>modules[spec<span style=color:#f92672>.</span>name] <span style=color:#f92672>=</span> module
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> spec<span style=color:#f92672>.</span>loader <span style=color:#f92672>is</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> spec<span style=color:#f92672>.</span>submodule_search_locations <span style=color:#f92672>is</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>raise</span> <span style=color:#a6e22e>ImportError</span>(<span style=color:#e6db74>&#39;missing loader&#39;</span>, name<span style=color:#f92672>=</span>spec<span style=color:#f92672>.</span>name)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>                spec<span style=color:#f92672>.</span>loader<span style=color:#f92672>.</span>exec_module(module)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>except</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>del</span> sys<span style=color:#f92672>.</span>modules[spec<span style=color:#f92672>.</span>name]
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>except</span> <span style=color:#a6e22e>KeyError</span>:
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>pass</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>raise</span>
</span></span><span style=display:flex><span>        module <span style=color:#f92672>=</span> sys<span style=color:#f92672>.</span>modules<span style=color:#f92672>.</span>pop(spec<span style=color:#f92672>.</span>name)
</span></span><span style=display:flex><span>        sys<span style=color:#f92672>.</span>modules[spec<span style=color:#f92672>.</span>name] <span style=color:#f92672>=</span> module
</span></span><span style=display:flex><span>        _verbose_message(<span style=color:#e6db74>&#39;import </span><span style=color:#e6db74>{!r}</span><span style=color:#e6db74> # </span><span style=color:#e6db74>{!r}</span><span style=color:#e6db74>&#39;</span>, spec<span style=color:#f92672>.</span>name, spec<span style=color:#f92672>.</span>loader)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>finally</span>:
</span></span><span style=display:flex><span>        spec<span style=color:#f92672>.</span>_initializing <span style=color:#f92672>=</span> <span style=color:#66d9ef>False</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> module
</span></span></code></pre></div><p>当然，如果使用不当也是会引发异常的。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># foo.py</span>
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> foo <span style=color:#f92672>import</span> a
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>a <span style=color:#f92672>=</span> <span style=color:#ae81ff>11</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 这种情况下 Import foo 会导致 ImportError</span>
</span></span><span style=display:flex><span><span style=color:#75715e># ImportError: cannot import name &#39;a&#39; from partially initialized module &#39;foo&#39; (most likely due to a circular import)</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># foo.py</span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> bar
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># bar.py</span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> foo
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>print(foo<span style=color:#f92672>.</span>a)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 这种情况下 Import foo 会导致 AttributeError</span>
</span></span><span style=display:flex><span><span style=color:#75715e># AttributeError: partially initialized module &#39;foo&#39; has no attribute &#39;a&#39; (most likely due to a circular import)</span>
</span></span></code></pre></div><p>原因就是尝试在 <code>foo</code> 模块仅仅 Partially imported 的情况下获取尚不存在的属性。</p><h1 id=reload>Reload<a hidden class=anchor aria-hidden=true href=#reload>#</a></h1><p>除了 <code>import_module</code>，<code>importlib</code> 还提供了一个 <code>reload</code> 接口，可以用来重新加载之前 Import 过的模块。</p><p><code>reload</code> 会刷新 <code>sys.modules</code> 中的 Module object，这没有问题。但是，对于 <code>from foo import bar</code> 这样的 Import 方式，<code>bar</code> 是不会单独更新的。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># foo.py</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>bar</span>():
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#39;bar&#39;</span>)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#75715e># 如果 import foo，然后这样使用 foo.bar()。Reload 是 OK 的。</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 如果再加上 from foo import bar，那么即使改变 bar 的代码再 reload(foo)，bar() 还是会保持原有的效果，即打印 `bar` 字符串。</span>
</span></span></code></pre></div><p>从源码来理解，这是因为以上涉及到的 Import 实现都只针对 Module object 的创建和更新。从字节码可以看到：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>➜ echo <span style=color:#e6db74>&#39;from os import path&#39;</span> | python -m dis
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>1</span>           <span style=color:#ae81ff>0</span> LOAD_CONST               <span style=color:#ae81ff>0</span> <span style=color:#f92672>(</span>0<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>              <span style=color:#ae81ff>2</span> LOAD_CONST               <span style=color:#ae81ff>1</span> <span style=color:#f92672>((</span><span style=color:#e6db74>&#39;path&#39;</span>,<span style=color:#f92672>))</span>
</span></span><span style=display:flex><span>              <span style=color:#ae81ff>4</span> IMPORT_NAME              <span style=color:#ae81ff>0</span> <span style=color:#f92672>(</span>os<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>              <span style=color:#ae81ff>6</span> IMPORT_FROM              <span style=color:#ae81ff>1</span> <span style=color:#f92672>(</span>path<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>              <span style=color:#ae81ff>8</span> STORE_NAME               <span style=color:#ae81ff>1</span> <span style=color:#f92672>(</span>path<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>             <span style=color:#ae81ff>10</span> POP_TOP
</span></span><span style=display:flex><span>             <span style=color:#ae81ff>12</span> LOAD_CONST               <span style=color:#ae81ff>2</span> <span style=color:#f92672>(</span>None<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>             <span style=color:#ae81ff>14</span> RETURN_VALUE
</span></span></code></pre></div><p><code>path</code> 的 Name binding 是通过 <code>STORE_NAME</code> 指令完成的，而 Import 的代码只负责 <code>IMPORT_NAME</code> 和 <code>IMPORT_FROM</code>，所以 <code>reload</code> 才会有 Module level 的限制。</p><hr><p><em>References</em></p><ul><li><p><a href=https://tenthousandmeters.com/blog/python-behind-the-scenes-11-how-the-python-import-system-works/>How the Python import system works</a></p></li><li><p><a href=https://docs.python.org/3/reference/import.html#import-related-module-attributes>Module attributes - Python Docs</a></p></li><li><p><a href=https://python3-cookbook.readthedocs.io/zh_CN/latest/c10/p06_reloading_modules.html>Reload - python3 Cookbook</a></p></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://iamgodot.com/tags/python/>python</a></li></ul><nav class=paginav><a class=next href=https://iamgodot.com/posts/visit-dali/><span class=title>Next Page »</span><br><span>游大理</span></a></nav></footer><script src=https://giscus.app/client.js data-repo=iamgodot/godot-blog-comments data-repo-id="MDEwOlJlcG9zaXRvcnkzOTk0Nzk0MTY=" data-category=Announcements data-category-id=DIC_kwDOF8-SeM4CO3OX data-mapping=pathname data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=dark_dimmed data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2020-2022 <a href=https://iamgodot.com>Godot's Blog</a></span>
<span>| <a href=http://beian.miit.gov.cn/ target=_blank>京ICP备20005558号-2</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>